#!/usr/bin/env bash

#     Copyright 2021 Adam Bromiley - Warwick Manufacturing Group, University of
#     Warwick.
#     
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# Utility functions for the Netkit Bash completion scripts


###############################################################################
# Write a newline-separated list of long options for the given command to
# standard output.
# Usage:
#   _get_get_command_options COMMAND
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - command name (must be present in $NETKIT_HOME/bin/)
# Returns:
#   None
# Example:
#   None
###############################################################################
_get_command_options() {
   # Get long options
   "$NETKIT_HOME/bin/$1" --help | grep --extended-regexp --only-matching "^(  -[[:alnum:]], | {6})--[[:alnum:]-]+=?" | awk --field-separator "," '{ gsub(/[[:blank:]]/, "", $NF); print $NF }'
   # Get short options
   # NOTE: we don't gather the short options because conventionally linux
   # utilities only autocomplete long ones.
   #"$NETKIT_HOME/bin/$1" --help | grep --extended-regexp --only-matching '^  -[[:alnum:]]' | tr -d "[:blank:]"
}


###############################################################################
# Expand '--ethN=' in a command's option array to '--eth1= --eth2= ...
# --eth${MAX_INTERFACES}='. The option list wrote to standard output will be
# space-separated, which should be fine given that command-line options do not
# have whitespace in.
# Usage:
#   _expand_eth_option [OPTION]...
# Globals:
#   None
# Arguments:
#   $1 - command name (must be present in $NETKIT_HOME/bin/)
# Returns:
#   None
# Example:
#   mapfile -t options < <(_get_command_options vstart)
#   mapfile -t options < <(_expand_eth_option "${options[@]}")
###############################################################################
_expand_eth_option() {
   local option i max_interfaces

   # We only want the value of MAX_INTERFACES from script_utils. Sourcing
   # script_utils in this shell would flood the user's environment with other
   # Netkit environment variables when they source this script inside .bashrc
   # (or similar) to get the completions. Therefore, we source in a subshell
   # and extract just the value of MAX_INTERFACES.
   # shellcheck source=../bin/script_utils
   max_interfaces=$(. "$NETKIT_HOME/bin/script_utils"; echo "$MAX_INTERFACES")

   for option in "$@"; do
      [ "$option" = "--ethN=" ] && continue
      echo "$option"
   done

   for ((i = 0; i <= max_interfaces; ++i)) do
      echo "--eth$i="
   done
}


###############################################################################
# Write a newline-separated list of subcommands for the given command to
# standard output.
# Usage:
#   _get_command_subcommands COMMAND
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - command name (must be present in $NETKIT_HOME/bin/)
# Returns:
#   None
# Example:
#   None
###############################################################################
_get_command_subcommands() {
   "$NETKIT_HOME/bin/$1" --help | grep --extended-regexp --only-matching "^  [[:alnum:]][[:alnum:]-]+" | tr -d "[:blank:]"
}


###############################################################################
# Get user parameter (option '-u|--user') from the command-line array. If not
# found, output '-'. Can be used to generate machine name completions owned by
# a specific user.
# Usage:
#   _get_netkit_user [ARGUMENT]...
# Globals:
#   r- COMP_WORDS
# Arguments:
#  ... - command-line arguments
# Returns:
#   None
# Example:
#   None
###############################################################################
_get_netkit_user() {
   local user_flag

   # Iterate over the command-line arguments
   for word in "$@"; do
      if [ -n "$user_flag" ]; then
         echo "$word"
         return
      fi

      # Check command-line arguments for -u|--user. If found, the next argument
      # will be the username.
      [ "$word" = "-u" ] || [ "$word" = "--user" ] && user_flag=1
   done

   echo "-"
}


###############################################################################
# Get lab directory parameter (option '-d') from the command-line array. If not
# found, output the current working directory. Can be used to generate machine
# name completions.
# Usage:
#   _get_lab_directory [ARGUMENT]...
# Globals:
#   r- COMP_WORDS
#   r- PWD
# Arguments:
#  ... - command-line arguments
# Returns:
#   None
# Example:
#   None
###############################################################################
_get_lab_directory() {
   local d_flag

   # Iterate over the command-line arguments
   for word in "$@"; do
      if [ -n "$d_flag" ]; then
         echo "$word"
         return
      fi

      # Check command-line arguments for -d. If found, the next argument will
      # be the lab directory path.
      [ "$word" = "-d" ] && d_flag=1
   done

   echo "$PWD"
}


###############################################################################
# Check if an array contains a string.
# Usage:
#   _array_contains QUERY ARRAY
# Globals:
#   None
# Arguments:
#   $1 - string to search for
#   $2 - word-expanded array to search
# Returns:
#   0 if array contains query, non-zero if not
# Example:
#   bar=( a b c )
#   if _array_contains "a" "${bar[@]}"; then echo "Found!"; fi
###############################################################################
_array_contains() {
   local query=$1
   local array=( "${@:2}" )

   local item

   for item in "${array[@]}"; do
      [ "$query" = "$item" ] && return 0
   done

   return 1
}


###############################################################################
# Set array variable to a list of machines in the lab taken from the directory
# listing. See $NETKIT_HOME/bin/script_utils for further information.
# Usage:
#   _get_lab_vhosts LAB_VHOSTS_NAME_REF DIR
# Globals:
#   None
# Arguments:
#   $1 - name reference to array variable
#   $2 - lab directory
# Returns:
#   None
# Example:
#   local lab_vhosts
#   _get_lab_vhosts "lab_vhosts" "/path/to/lab/directory"
#   echo "${lab_vhosts[*]}"
###############################################################################
_get_lab_vhosts() {
   local -n _get_lab_vhosts_lab_vhosts=$1
   local lab_directory=$2

   local lab_machines
   local vhost

   # Invalid hostnames (see $NETKIT_HOME/bin/script_utils)
   local invalid_hostnames=( "shared" "_test" )

   # Get lab.conf's LAB_MACHINES variable. This will override the directory
   # listing for the machine list.
   lab_machines=$(sed --quiet "0,/^LAB_MACHINES=/s///p" "$lab_directory/lab.conf" 2> /dev/null)
   IFS="," read -ra _get_lab_vhosts_lab_vhosts <<< "$lab_machines"

   if [ "${#_get_lab_vhosts_lab_vhosts[@]}" -eq 0 ]; then
      # Build list of virtual machines that are part of the lab from the
      # directory listing if LAB_MACHINES is not set.
      for dir in "$lab_directory/"*/; do
         # If there are no subdirectories, "$lab_directory/"*/ will expand to a
         # path to a directory named *; the for loop will still run over that
         # one string. shopt -s nullglob will avoid this issue but has global
         # implications. Avoid having to set nullglob by simply checking if the
         # directory exists.
         [ ! -d "$dir" ] && continue

         vhost=$(basename -- "$dir")

         # Avoid the shared and _test directories
         _array_contains "$vhost" "${invalid_hostnames[@]}" && continue

         _get_lab_vhosts_lab_vhosts+=( "$vhost" )
      done
   fi
}


if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$(basename -- "$0"): The NETKIT_HOME environment variable is not set"
   exit 1
fi
