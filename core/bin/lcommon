#!/bin/false
# shellcheck shell=bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is a support script for the Netkit lcommands. It is not intended for
# standalone usage.


###############################################################################
# Print a string with bold formatting.
# Usage:
#   bold_print $1
# Globals:
#   r- COLOR_BOLD
#   r- COLOR_NORMAL
# Arguments:
#   $1 - string to print
# Returns:
#   None
# Example:
#   None
###############################################################################
bold_print() {
   printf "%b%s%b\n" "$COLOR_BOLD" "$1" "$COLOR_NORMAL"
}


###############################################################################
# Check if an array contains a string.
# Usage:
#   array_contains QUERY ARRAY
# Globals:
#   None
# Arguments:
#   $1 - string to search for
#   $2 - word-expanded array to search
# Returns:
#   0 if array contains query, non-zero if not
# Example:
#   bar=( a b c )
#   if array_contains "a" "${bar[@]}"; then echo "Found!"; fi
###############################################################################
array_contains() {
   query=$1
   shift

   array=( "$@" )

   for item in "${array[@]}"; do
      [ "$query" = "$item" ] && return 0
   done

   return 1
}


###############################################################################
# Set VHOSTLIST to a list of machines in the lab taken from the directory
# listing. If VHOSTLIST is already set (such as by the user on the command
# line), machines not present in the lab are removed from the array.
# Usage:
#   build_vhostlist DIR
# Globals:
#   rw VHOSTLIST
# Arguments:
#   $1 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
build_vhostlist() {
   local lab_directory=$1

   # Build list of virtual machines that are part of the lab
   for dir in "$lab_directory"/*/; do
      vhost=$(basename "$dir")

      # Avoid the shared and _test directories
      if [ "$vhost" = "shared" ] || [ "$vhost" = "_test" ]; then
         continue
      fi

      vhosts+=( "$vhost" )
   done

   # If VHOSTLIST has already been set (typically explicitly by the user on the
   # command line), verify that the machines are in the lab.
   if [ "${#VHOSTLIST[@]}" -gt 0 ]; then
      vhostlist_bak=( "${VHOSTLIST[@]}" )
      unset VHOSTLIST

      for vhost in "${vhostlist_bak[@]}"; do
         if array_contains "$vhost" "${vhosts[@]}"; then
            VHOSTLIST+=( "$vhost" )
         else
            echo 1>&2 "Warning: '$vhost' is not part of the lab in '$lab_directory'"
         fi
      done
   else
      VHOSTLIST=( "${vhosts[@]}" )
   fi
}


###############################################################################
# From a lab info associative array (key is directory basename, value is the
# relevant attribute's value) construct a formatted list suitable for
# lab_welcome output (i.e. value1 (dir1, dir2, ...), value2 (dir3, dir4, ...),
# ...) and write to standard output.
# Usage:
#   generate_lab_info_str LAB_INFO
# Globals:
#   None
# Arguments:
#   $1 - lab information associative array name reference
# Returns:
#   None
# Example:
#   None
###############################################################################
generate_info_str() {
   local -n lab_info=$1

   local lab value
   local lab_info_str separator

   declare -A collated_lab_info_values

   # For each directory chosen, add its lab information value as a key to an
   # array with a value of directory listings. For example, for a lab_info
   # array of version numbers:
   #
   #     lab_info["lab3a"]="1.0"
   #     lab_info["lab3b"]="1.1"
   #     lab_info["lab3c"]="1.0"
   #     lab_info["lab3d"]="2.0"
   #
   # This would be transformed into collated_lab_info_values:
   #
   #     collated_lab_info_values["1.0"]="lab3a, lab3c"
   #     collated_lab_info_values["1.1"]="lab3b"
   #     collated_lab_info_values["2.0"]="lab3d"
   for lab in "${!lab_info[@]}"; do
      value=${lab_info[$lab]:-"<unknown>"}

      # Append the lab name to its relevant value's list if the value has been
      # seen before (exists as a key in the array). If not, start the list.
      if array_contains "$value" "${!collated_lab_info_values[@]}"; then
         collated_lab_info_values[$value]="${collated_lab_info_values[$value]}, $lab"
      else
         collated_lab_info_values[$value]=$lab
      fi
   done

   # collated_lab_info_values is then flattened into a string to display in the
   # lab_welcome dialog.
   if [ ${#collated_lab_info_values[@]} -gt 1 ]; then
      for value in "${!collated_lab_info_values[@]}"; do
         lab_info_str+="$separator$value (${collated_lab_info_values[$value]})"
         separator=", "
      done
   elif [ ${#collated_lab_info_values[@]} -eq 1 ]; then
      # If all labs share the same value, it is not necessary to display the
      # lab names.
      lab_info_str=${!collated_lab_info_values[*]}
   else
      # If no lab has the parameter defined.
      lab_info_str="<unknown>"
   fi

   echo "$lab_info_str"
}


###############################################################################
# Get the value of a parameter set in a lab's lab.conf file and write to
# standard output.
# Usage:
#   get_lab_variable DIRECTORY
# Globals:
#   None
# Arguments:
#   $1 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
get_lab_variable() {
   local variable=$1
   local lab_conf="$2/lab.conf"

   # Set lab variables from lab.conf. The sed expression prints only the first
   # matching line and deletes the variable name and equals sign.
   sed -n "0,/^[[:blank:]]*$variable=/s///p" "$lab_conf"
}


###############################################################################
# Print out information about the labs in the given directories. Unset values
# will be outputted as "<unknown>".
# Usage:
#   lab_welcome [DIRECTORY]...
# Globals:
#   r- COLOR_BOLD
#   r- COLOR_HIGHLIGHT
#   r- COLOR_NORMAL
#   r- SCRIPTNAME
# Arguments:
#  ... - list of lab directories
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_welcome() {
   local lab_directories=( "$@" )

   local dir lab lab_directories_str
   declare -A lab_versions lab_authors lab_emails lab_webs lab_descriptions

   printf -v lab_directories_str '%s, ' "${lab_directories[@]}"
   lab_directories_str=${lab_directories_str%", "}

   for dir in "${lab_directories[@]}"; do
         # Check that the lab directory exists
      if [ ! -d "$dir" ]; then
         echo 1>&2 "$SCRIPTNAME: $dir: No such directory"
         exit 1
      fi

      lab=$(basename "$dir")

      # We use associative arrays for printing the values with their respective
      # directory basename. SC2034 (variable appears unused) must be ignored
      # because the arrays are only referenced by name.
      # TODO: create 'LAB_MACHINES' variable, similar to the old 'machines'
      # variable.
      # shellcheck disable=SC2034
      lab_versions[$lab]=$(get_lab_variable "LAB_VERSION" "$dir")
      # shellcheck disable=SC2034
      lab_authors[$lab]=$(get_lab_variable "LAB_AUTHOR" "$dir")
      # shellcheck disable=SC2034
      lab_emails[$lab]=$(get_lab_variable "LAB_EMAIL" "$dir")
      # shellcheck disable=SC2034
      lab_webs[$lab]=$(get_lab_variable "LAB_WEB" "$dir")
      # shellcheck disable=SC2034
      lab_descriptions[$lab]=$(get_lab_variable "LAB_DESCRIPTION" "$dir")
   done

   # Convert the multi-lab arrays to flat, comma-separated lists and print
   echo "${COLOR_BOLD}Lab directory(ies)$COLOR_NORMAL: $COLOR_HIGHLIGHT$lab_directories_str$COLOR_NORMAL"
   echo "${COLOR_BOLD}Version(s)$COLOR_NORMAL:         $COLOR_HIGHLIGHT$(generate_info_str lab_versions)$COLOR_NORMAL"
   echo "${COLOR_BOLD}Author(s)$COLOR_NORMAL:          $COLOR_HIGHLIGHT$(generate_info_str lab_authors)$COLOR_NORMAL"
   echo "${COLOR_BOLD}Email(s)$COLOR_NORMAL:           $COLOR_HIGHLIGHT$(generate_info_str lab_emails)$COLOR_NORMAL"
   echo "${COLOR_BOLD}URL(s)$COLOR_NORMAL:             $COLOR_HIGHLIGHT$(generate_info_str lab_webs)$COLOR_NORMAL"
   echo "${COLOR_BOLD}Description(s)$COLOR_NORMAL:"
   echo "$COLOR_HIGHLIGHT$(generate_info_str lab_descriptions)$COLOR_NORMAL"
}


###############################################################################
# Remove temporary files from the lab directory and .netkit.
# Usage:
#   lab_clean DIR
# Globals:
#   r- MCONSOLE_DIR
#   rw VHOSTLIST
# Arguments:
#   $1 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_clean() {
   local lab_directory=$1

   build_vhostlist "$lab_directory"

   bold_print "Cleaning up lab inside '$lab_directory'..."

   for vhost in "${VHOSTLIST[@]}"; do
      # Remove files from the lab directory
      rm "${VERBOSE:+"--verbose"}" -r "${MCONSOLE_DIR:?}/$vhost"
      rm "${VERBOSE:+"--verbose"}" "$lab_directory/$vhost."{"ready","disk","log","testdone"}
   done

   rm "${VERBOSE:+"--verbose"}" "$lab_directory/readyfor.test"
}


###############################################################################
# Crash virtual machines of a Netkit lab.
# Usage:
#   lab_crash
# Globals:
#   r- KEEP_FILESYSTEM
#   r- KILL_MODE
#   r- LAB_DIRECTORY
#   r- VERBOSE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_crash() {
   local VCRASH_OPTIONS

   build_vhostlist "$LAB_DIRECTORY"

   [ -z "$VERBOSE" ]         && VCRASH_OPTIONS+=( "-q" )
   [ -z "$KEEP_FILESYSTEM" ] && VCRASH_OPTIONS+=( "-r" )
   [ -n "$KILL_MODE" ]       && VCRASH_OPTIONS+=( "-k" )
   
   for VM in "${VHOSTLIST[@]}"; do
      [ -z "$VERBOSE" ] && bold_print "Crashing '$VM'..."
      vcrash "${VCRASH_OPTIONS[@]}" "$VM" && rm -f "$LAB_DIRECTORY/$VM.ready"
   done
   
   bold_print "Removing readyfor.test..."
   rm -f "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Start a single virtual machine within a lab.
# Usage:
#   single_lab_vm_start MACHINE
# Globals:
#   r- BASE_VSTART_OPTIONS
#   r- FASTMODE
#   r- GRACE_TIME
#   r- LAB_DIRECTORY
#   r- TESTMODE
#   r- VERBOSE
# Arguments:
#   $1 - machine to start up
# Returns:
#   None
# Example:
#   None
###############################################################################
single_lab_vm_start() {
   local VSTART_OPTIONS
   local VM=$1

   # Generate vstart argument list
   if [ -e "$LAB_DIRECTORY/lab.conf" ]; then
      while IFS= read -r configuration; do
         # The [][] is ][ inside a bracket expression to match an opening or
         # closing square bracket. We know the machine name cannot contain
         # square brackets, so the option is the first instance of them.
         option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

         # Everything after the first '='
         value=${configuration#*=}

         # If option is all-digit, it must be a network interface specification
         [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]] && option="eth$option"

         if [ "${#option}" -eq 1 ]; then
            VSTART_OPTIONS+=( "-$option" )
         else
            VSTART_OPTIONS+=( "--$option" )
         fi

         # NOTE: if vstart is ever changed to have an option with an optional
         # argument (denoted with '::' in the option string), an exception when
         # appending the argument must be made (an '=' is required for long
         # options, no delimiter for short ones).
         [ -n "$value" ] && VSTART_OPTIONS+=( "$value" )
      done < <(grep "^[[:blank:]]*$VM\[.*\][[:blank:]]*=" "$LAB_DIRECTORY/lab.conf")
   fi
      
   # Add host lab and working directory
   VSTART_OPTIONS+=( "--hostlab" "$LAB_DIRECTORY" "--hostwd" "$PWD" )

   # Place virtual machine filesystem inside the lab directory
   VSTART_OPTIONS+=( "--filesystem" "$LAB_DIRECTORY/$VM.disk" )

   # Check if is a testing phase
   [ -n "$TESTMODE" ] && VSTART_OPTIONS+=( "--test" )
   
   # Remove .ready file, if existing
   [ -e "$LAB_DIRECTORY/$VM.ready" ] && rm -f "$LAB_DIRECTORY/$VM.ready"

   if [ -z "$VERBOSE" ]; then
      bold_print "Starting '$VM'..."
   else
      bold_print "Starting '$VM' with options '$BASE_VSTART_OPTIONS ${VSTART_OPTIONS[*]}'... "
   fi

   if ! vstart "${BASE_VSTART_OPTIONS[@]}" "${VSTART_OPTIONS[@]}" "$VM"; then
      echo 2>&1 "Error while starting virtual machine '$VM'"
      exit 1
   fi

   # Wait for virtual host startup script to create .ready file
   if [ -z "$FASTMODE" ]; then
      while [ ! -e "$LAB_DIRECTORY/$VM.ready" ]; do
         sleep 1
      done

      rm -f "$LAB_DIRECTORY/$VM.ready"
   fi
   
   # Wait for a specified amount of time before returning
   [ "$GRACE_TIME" -gt 0 ] && sleep "$GRACE_TIME"
}


###############################################################################
# Start virtual machines of a Netkit lab sequentially.
# Usage:
#   lab_start
# Globals:
#   r- LAB_DIRECTORY
#   r- MAKEFILE
#   r- PASSTHROUGH_OPTIONS
#   r- TESTMODE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start() {
   local BASE_VSTART_OPTIONS

   build_vhostlist "$LAB_DIRECTORY"

   [ -z "$VERBOSE" ] && BASE_VSTART_OPTIONS+=( "-q" )
   BASE_VSTART_OPTIONS+=( "${PASSTHROUGH_OPTIONS[@]}" )
   
   if [ "${#VHOSTLIST[@]}" -gt 0 ]; then
      for VM in "${VHOSTLIST[@]}"; do
         single_lab_vm_start "$VM"
      done
   else
      echo 1>&2 "Warning: there are no virtual machines to be started."
   fi
   
   # The readyfor.test file should not be created if we have been invoked
   # with the --makefile option (=launch a single machine and exit).
   [ -n "$TESTMODE" ] && [ -z "$MAKEFILE" ] && : > "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Start virtual machines of a Netkit lab simultaneously with GNU Make.
# Usage:
#   lab_start_parallel
# Globals:
#   r- LAB_DIRECTORY
#   r- MAKEFILE
#   r- MAX_SIMULTANEOUS_VMS
#   r- PASSTHROUGH_OPTIONS
#   r- TESTMODE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start_parallel() {
   build_vhostlist "$LAB_DIRECTORY"
   
   if [ "${#VHOSTLIST[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi
   
   # Pass "passthrough" options on to further invocations of this script
   [ -n "$VERBOSE" ] && PASSTHROUGH_STUFF+=( "-v" )
   for CURRENT_OPTION in "${PASSTHROUGH_OPTIONS[@]}"; do
      PASSTHROUGH_STUFF+=( "-o" "$CURRENT_OPTION" )
   done

   # Pass testmode along subsequent invocations of this script
   if [ -n "$TESTMODE" ]; then
      COMMAND_NAME="ltest"
   else
      COMMAND_NAME="lstart"
   fi
   
   # The make utility expects an empty argument when infinitely many jobs
   # should be used.
   [ "$MAX_SIMULTANEOUS_VMS" -eq 0 ] && MAX_SIMULTANEOUS_VMS=""


   cmd=( "$COMMAND_NAME" "-d" "$LAB_DIRECTORY" "${PASSTHROUGH_STUFF[@]}" "--makefile" )

   # We expand this array with the Q operator when writing to the Makefile.
   # This ensures escaping sufficient for reuse in a shell command.
   escaped_cmd=${cmd[*]@Q}

   # Make requires all dollar signs (whether quoted or not) to be escaped with
   # a second dollar sign.
   escaped_cmd=${escaped_cmd//$/\$$}

   # Labs are started in parallel with GNU Make, which automatically handles
   # lab.dep (which is formatted as Makefile targets).
   #
   # The script is invoked with each VM name as a target on the command line,
   # which directs Make to run:
   #   lstart [...] --makefile <machine>
   # for each machine. $* is a GNU Make automatic variable that expands to the
   # % (stem) in the target. In this usage it will expand to the machine name.
   #
   # The contents of lab.dep is copied in if it exists, which creates a target
   # for each machine with dependencies ("prerequisities" in Make).
   # NOTE: The dummy target is required, which has the unwanted side-effect
   # that machines cannot be named "dummy-prerequisite-to-force-remaking".
   # 
   # The Makefile must use Bash as the shell for correct handling of ANSI-C
   # expansions present after the previous Q-operator array expansion.
   tab=$(printf '\t')
   IFS='' read -r -d '' makefile_contents << EOF
SHELL := /bin/bash

%: dummy-prerequisite-to-force-remaking
${tab}[ '\$*' != "lab.dep" ] && $escaped_cmd '\$*'

dummy-prerequisite-to-force-remaking:
${tab}# Dummy line. Unuseful, yet necessary

$(cat "$LAB_DIRECTORY/lab.dep" 2> /dev/null)
EOF

   # Read the Makefile from stdin without implicit rules, and hide the output. It
   # it parallelised to the MAX_SIMULTANEOUS_VMS configuration option.
   make -irsC "$LAB_DIRECTORY" -f - -j "$MAX_SIMULTANEOUS_VMS" "${VHOSTLIST[@]}" <<< "$makefile_contents"

   
   # Signal that every machine is ready for testing once booted.
   [ -n "$TESTMODE" ] && : > "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Generate a DOT language graph from a list of lab.conf files and virtual
# machine names and write to standard output.
# Usage:
#   generate_dot_graph [LAB_CONF]...
# Globals:
#   r- VHOSTLIST
# Arguments:
#  ... - list of lab.conf files to analyse
# Returns:
#   None
# Example:
#   generate_dot_graph lab.conf | dot
###############################################################################
generate_dot_graph() {
   local lab_confs=( "$@" )

   # Global map parameters
   cat << EOF
graph netkit_jh_graph {
   overlap="prism";
   overlap_scaling=-6.0;
   resolution=400.0;
   splines="line";
EOF

   declare -A device_ids options

   while IFS= read -r configuration; do
      # The [][] is ][ inside a bracket expression to match an opening or
      # closing square bracket. We know the machine name cannot contain
      # square brackets, so the option is the first instance of them.
      vm=$(awk -F"[][]" '{ print $1 }' <<< "$configuration")
      option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

      # Everything after the first '='
      value=${configuration#*=}

      # Ignore if VM is not part of the lab
      array_contains "$vm" "${VHOSTLIST[@]}" || continue

      # If option is all-digit, it must be a network interface specification
      if [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]]; then
         # Ignore if it has already been seen
         [[ "${device_ids[$vm]}" =~ \ $option\  ]] && continue

         # Add an edge between the machine and its collision domain
         cat << EOF
   "$vm" -- "$value" [
      taillabel=<
         <TABLE BGCOLOR="white" BORDER="0" CELLPADDING="1" CELLSPACING="0">
            <TR>
               <TD>eth$option</TD>
            </TR>
         </TABLE>
      >,
      labeldistance=1.5,
      labelfontsize=8.0
   ];'
EOF

         domains+=( "$value" )

         # Device IDs cannot have whitespace, so a space-separated list is
         # safe.
         device_ids[$vm]+=" $option "
      else
         options[$vm]+="$option = $value<BR/>"
      fi
   done < <(grep --no-filename "^[[:blank:]].*\[.*\][[:blank:]]*=" "${lab_confs[@]}")
   # TODO: Replace .* in above grep (and any other similar search) with the
   # hostname regex.

   # Label each machine with its hostname and vstart options
   for vm in "${VHOSTLIST[@]}"; do
      cat << EOF
   "$vm" [
      shape=box,
      label=<
         $vm
         <FONT POINT-SIZE="10">
            <BR/>${options[$vm]}
         </FONT>
      >,
      height=0.5,
      width=0.5
   ];
EOF
   done

   # Remove bounding box from collision domain labels (just text)
   for domain in "${domains[@]}"; do
      cat << EOF
   "$domain" [
      shape=plaintext,
      width=0,
      height=0,
      margin=0
   ]
EOF
   done

   echo "}"
}


# This function creates a link-level topology map of the lab. Its argument is
# the name of the PNG file to save the map in.
lab_map() {
   local map_file=$1
   local lab_confs=( "${@:2}" )

   GRAPH_GENERATOR=$(which neato)
   if [ -z "$GRAPH_GENERATOR" ]; then
      echo 1>&2 "Error: the GraphViz library does not appear to be installed."
      echo 1>&2 "Please install the GraphViz library."
      return 1
   fi

   generate_dot_graph "${lab_confs[@]}" | "$GRAPH_GENERATOR" -Tpng -o"$map_file"
}


# Regular expression for a Debian-approved (and RFC-compliant) hostname
# label. This expression can be substituted directly into most Linux utility
# commands, such as egrep (grep -E).
#
# Debian standard for hostname 'labels' (hostname(7) man page):
#   - May consist of A-Z, a-z, 0-9, and - (hyphen)
#   - Cannot start or end with a - (hyphen)
#   - Are case-insensitive
#   - Can be 1 to 63 characters long
hostname_regex="([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}[a-zA-Z0-9])"


# ANSI color escape sequences
COLOR_HIGHLIGHT='\033[34;1m'
COLOR_NORMAL='\033[0m'
COLOR_BOLD='\033[1m'
