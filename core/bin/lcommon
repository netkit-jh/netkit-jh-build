#!/bin/false
# shellcheck shell=bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is a support script for the Netkit lcommands. It is not intended for
# standalone usage.

# by Stefano Pettini <spettini@users.sourceforge.net>, Fabio Ricci, and Massimo
# Rimondini

# Regular expression for a Debian-approved (and RFC-compliant) hostname
# label. This expression can be substituted directly into most Linux utility
# commands, such as egrep (grep -E).
#
# Debian standard for hostname 'labels' (hostname(7) man page):
#   - May consist of A-Z, a-z, 0-9, and - (hyphen)
#   - Cannot start or end with a - (hyphen)
#   - Are case-insensitive
#   - Can be 1 to 63 characters long
hostname_regex="([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}[a-zA-Z0-9])"

# ANSI color escape sequences
COLOR_HIGHLIGHT='\033[34;1m'
COLOR_NORMAL='\033[0m'
COLOR_BOLD='\033[1m'

if [ -f "${LAB_DIRECTORY}/lab.conf" ]; then
   # Set some lab variables from lab.conf.
   # Here we filter out array assignments (e.g. assignment of
   # network interfaces to collision domains) because they
   # are not supported by some shells. They will be handled
   # separately later on.

   LAB_VARIABLE_ASSIGNMENTS="$(grep -E '(^[ ]*LAB_[A-Z]+=(([^ ]*[ ]*$)|(.*)))|(^[ ]*machines=((.*)|(\\".*\\"[ ]*$)))' ${LAB_DIRECTORY}/lab.conf | sed -r 's/machines=([^\"])/machines=\"\1/; /machines=/ s/([^\"])[ ]*$/\1\"/' | sed -r 's/LAB_([A-Z]+)=([^\"])/LAB_\1=\"\2/; /LAB_([A-Z]+)=/ s/([^\"])[ ]*$/\1\"/')"
   eval "$LAB_VARIABLE_ASSIGNMENTS"
fi


###############################################################################
# Print a string with bold formatting.
# Usage:
#   bold_print $1
# Globals:
#   r- COLOR_BOLD
#   r- COLOR_NORMAL
# Arguments:
#   $1 - string to print
# Returns:
#   None
# Example:
#   None
###############################################################################
bold_print() {
   printf "%b%s%b\n" "$COLOR_BOLD" "$1" "$COLOR_NORMAL"
}


###############################################################################
# Check if an array contains a string.
# Usage:
#   array_contains QUERY ARRAY
# Globals:
#   None
# Arguments:
#   $1 - string to search for
#   $2 - word-expanded array to search
# Returns:
#   0 if array contains query, non-zero if not
# Example:
#   bar=( a b c )
#   if array_contains "a" "${bar[@]}"; then echo "Found!"; fi
###############################################################################
array_contains() {
   query=$1
   shift

   array=( "$@" )

   for item in "${array[@]}"; do
      [ "$query" = "$item" ] && return 0
   done

   return 1
}


###############################################################################
# Set VHOSTLIST to a list of machines in the lab taken from lab.conf or the
# directory listing. If VHOSTLIST is already set (such as by the user on the
# command line), machines not present in the lab are removed from the array.
# Usage:
#   build_vhostlist
# Globals:
#   rw VHOSTLIST
#   -w machines
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
build_vhostlist() {
   if [ -n "$machines" ]; then
      # Assume list of virtual machines is the one documented inside lab.conf
      lab_hosts=( "$machines" )
   else
      # Build list of virtual machines that are part of the lab
      for LAB_ITEM in "${LAB_DIRECTORY}"/*/; do
         dir=$(basename "$LAB_ITEM")

         # Handle error if no directories exist (the for loop will still run
         # once). Also avoid the shared and _test directories (if exist).
         if [ ! -e "$LAB_ITEM" ] || [ "$dir" = "shared" ] || [ "$dir" = "_test" ]; then
            continue
         fi

         lab_hosts+=( "$LAB_ITEM" )
      done
   fi

   # Check that virtual machines passed by command line are in the lab
   if [ "${#VHOSTLIST[@]}" -gt 0 ]; then
      ORIGINAL_VHOSTLIST=( "${VHOSTLIST[@]}" )
      unset VHOSTLIST

      for host in "${ORIGINAL_VHOSTLIST[@]}"; do
         if array_contains "$host" "${lab_hosts[@]}"; then
            VHOSTLIST+=( "$host" )
         else
            echo 1>&2 "Warning: '$CURRENT_HOST' is not part of the lab in '$LAB_DIRECTORY'"
         fi
      done
   else
      VHOSTLIST=( "${lab_hosts[@]}" )
   fi
}


###############################################################################
# Print out information about the lab.
# Usage:
#   lab_welcome
# Globals:
#   rw LAB_VERSION
#   rw LAB_AUTHOR
#   rw LAB_EMAIL
#   rw LAB_WEB
#   rw LAB_DESCRIPTION
#   r- LAB_DIRECTORY
#   r- COLOR_NORMAL
#   r- COLOR_BOLD
#   r- COLOR_HIGHLIGHT
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_welcome() {
   [ -z "$LAB_VERSION" ] &&     LAB_VERSION="${COLOR_NORMAL}<unknown>"
   [ -z "$LAB_AUTHOR" ] &&      LAB_AUTHOR="${COLOR_NORMAL}<unknown>"
   [ -z "$LAB_EMAIL" ] &&       LAB_EMAIL="${COLOR_NORMAL}<unknown>"
   [ -z "$LAB_WEB" ] &&         LAB_WEB="${COLOR_NORMAL}<unknown>"
   [ -z "$LAB_DESCRIPTION" ] && LAB_DESCRIPTION="${COLOR_NORMAL}<unknown>"

   echo "${COLOR_BOLD}Lab directory${COLOR_NORMAL}:    ${COLOR_HIGHLIGHT}${LAB_DIRECTORY}${COLOR_NORMAL}"
   echo "${COLOR_BOLD}Version(s)${COLOR_NORMAL}:       ${COLOR_HIGHLIGHT}${LAB_VERSION}${COLOR_NORMAL}"
   echo "${COLOR_BOLD}Author(s)${COLOR_NORMAL}:        ${COLOR_HIGHLIGHT}${LAB_AUTHOR}${COLOR_NORMAL}"
   echo "${COLOR_BOLD}Email(s)${COLOR_NORMAL}:         ${COLOR_HIGHLIGHT}${LAB_EMAIL}${COLOR_NORMAL}"
   echo "${COLOR_BOLD}Web(s)${COLOR_NORMAL}:           ${COLOR_HIGHLIGHT}${LAB_WEB}${COLOR_NORMAL}"
   echo "${COLOR_BOLD}Description(s)${COLOR_NORMAL}:"
   echo "${COLOR_HIGHLIGHT}${LAB_DESCRIPTION}${COLOR_NORMAL}"
}


###############################################################################
# Remove temporary files from the lab directory and .netkit.
# Usage:
#   lab_clean
# Globals:
#   rw VHOSTLIST
#   r- LAB_DIRECTORY
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_clean() {
   build_vhostlist

   bold_print "Cleaning up lab inside '$LAB_DIRECTORY'..."

   [ -n "$VERBOSE" ] && rm_verbose="--verbose"

   for host in "${VHOSTLIST[@]}"; do
      # Remove files from the lab directory
      rm "${rm_verbose:+"$rm_verbose"}" -r "${MCONSOLE_DIR:?}/$host"
      rm "${rm_verbose:+"$rm_verbose"}" "$LAB_DIRECTORY/$host."{"ready","disk","log","testdone"}
   done

   rm "${rm_verbose:+"$rm_verbose"}" "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Crash virtual machines of a Netkit lab.
# Usage:
#   lab_crash
# Globals:
#   r- KEEP_FILESYSTEM
#   r- KILL_MODE
#   r- LAB_DIRECTORY
#   r- VERBOSE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_crash() {
   local VCRASH_OPTIONS

   build_vhostlist

   [ -z "$VERBOSE" ]         && VCRASH_OPTIONS+=( "-q" )
   [ -z "$KEEP_FILESYSTEM" ] && VCRASH_OPTIONS+=( "-r" )
   [ -n "$KILL_MODE" ]       && VCRASH_OPTIONS+=( "-k" )
   
   for VM in "${VHOSTLIST[@]}"; do
      [ -z "$VERBOSE" ] && bold_print "Crashing '$VM'..."
      vcrash "${VCRASH_OPTIONS[@]}" "$VM" && rm -f "$LAB_DIRECTORY/$VM.ready"
   done
   
   bold_print "Removing readyfor.test..."
   rm -f "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Start a single virtual machine within a lab.
# Usage:
#   single_lab_vm_start MACHINE
# Globals:
#   r- BASE_VSTART_OPTIONS
#   r- FASTMODE
#   r- GRACE_TIME
#   r- LAB_DIRECTORY
#   r- TESTMODE
#   r- VERBOSE
# Arguments:
#   $1 - machine to start up
# Returns:
#   None
# Example:
#   None
###############################################################################
single_lab_vm_start() {
   local VSTART_OPTIONS
   local VM=$1

   # Generate vstart argument list
   if [ -e "$LAB_DIRECTORY/lab.conf" ]; then
      while IFS= read -r configuration; do
         # The [][] is ][ inside a bracket expression to match an opening or
         # closing square bracket. We know the machine name cannot contain
         # square brackets, so the option is the first instance of them.
         option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

         # Everything after the first '='
         value=${configuration#*=}

         # If option is all-digit, it must be a network interface specification
         [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]] && option="eth$option"

         if [ "${#option}" -eq 1 ]; then
            VSTART_OPTIONS+=( "-$option" )
         else
            VSTART_OPTIONS+=( "--$option" )
         fi

         # NOTE: if vstart is ever changed to have an option with an optional
         # argument (denoted with '::' in the option string), an exception when
         # appending the argument must be made (an '=' is required for long
         # options, no delimiter for short ones).
         [ -n "$value" ] && VSTART_OPTIONS+=( "$value" )
      done < <(grep "^[[:blank:]]*$VM\[.*\][[:blank:]]*=" "$LAB_DIRECTORY/lab.conf")
   fi
      
   # Add host lab and working directory
   VSTART_OPTIONS+=( "--hostlab" "$LAB_DIRECTORY" "--hostwd" "$PWD" )

   # Place virtual machine filesystem inside the lab directory
   VSTART_OPTIONS+=( "--filesystem" "$LAB_DIRECTORY/$VM.disk" )

   # Check if is a testing phase
   [ -n "$TESTMODE" ] && VSTART_OPTIONS+=( "--test" )
   
   # Remove .ready file, if existing
   [ -e "$LAB_DIRECTORY/$VM.ready" ] && rm -f "$LAB_DIRECTORY/$VM.ready"

   if [ -z "$VERBOSE" ]; then
      bold_print "Starting '$VM'..."
   else
      bold_print "Starting '$VM' with options '$BASE_VSTART_OPTIONS ${VSTART_OPTIONS[*]}'... "
   fi

   if ! vstart "${BASE_VSTART_OPTIONS[@]}" "${VSTART_OPTIONS[@]}" "$VM"; then
      echo 2>&1 "Error while starting virtual machine '$VM'"
      exit 1
   fi

   # Wait for virtual host startup script to create .ready file
   if [ -z "$FASTMODE" ]; then
      while [ ! -e "$LAB_DIRECTORY/$VM.ready" ]; do
         sleep 1
      done

      rm -f "$LAB_DIRECTORY/$VM.ready"
   fi
   
   # Wait for a specified amount of time before returning
   [ "$GRACE_TIME" -gt 0 ] && sleep "$GRACE_TIME"
}


###############################################################################
# Start virtual machines of a Netkit lab sequentially.
# Usage:
#   lab_start
# Globals:
#   r- LAB_DIRECTORY
#   r- MAKEFILE
#   r- PASSTHROUGH_OPTIONS
#   r- TESTMODE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start() {
   local BASE_VSTART_OPTIONS

   build_vhostlist

   [ -z "$VERBOSE" ] && BASE_VSTART_OPTIONS+=( "-q" )
   BASE_VSTART_OPTIONS+=( "${PASSTHROUGH_OPTIONS[@]}" )
   
   if [ "${#VHOSTLIST[@]}" -gt 0 ]; then
      for VM in "${VHOSTLIST[@]}"; do
         single_lab_vm_start "$VM"
      done
   else
      echo 1>&2 "Warning: there are no virtual machines to be started."
   fi
   
   # The readyfor.test file should not be created if we have been invoked
   # with the --makefile option (=launch a single machine and exit).
   [ -n "$TESTMODE" ] && [ -z "$MAKEFILE" ] && : > "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Start virtual machines of a Netkit lab simultaneously with GNU Make.
# Usage:
#   lab_start_parallel
# Globals:
#   r- LAB_DIRECTORY
#   r- MAKEFILE
#   r- MAX_SIMULTANEOUS_VMS
#   r- PASSTHROUGH_OPTIONS
#   r- TESTMODE
#   rw VHOSTLIST
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start_parallel() {
   build_vhostlist
   
   if [ "${#VHOSTLIST[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi
   
   # Pass "passthrough" options on to further invocations of this script
   [ -n "$VERBOSE" ] && PASSTHROUGH_STUFF+=( "-v" )
   for CURRENT_OPTION in "${PASSTHROUGH_OPTIONS[@]}"; do
      PASSTHROUGH_STUFF+=( "-o" "$CURRENT_OPTION" )
   done

   # Pass testmode along subsequent invocations of this script
   if [ -n "$TESTMODE" ]; then
      COMMAND_NAME="ltest"
   else
      COMMAND_NAME="lstart"
   fi
   
   # The make utility expects an empty argument when infinitely many jobs
   # should be used.
   [ "$MAX_SIMULTANEOUS_VMS" -eq 0 ] && MAX_SIMULTANEOUS_VMS=""


   cmd=( "$COMMAND_NAME" "-d" "$LAB_DIRECTORY" "${PASSTHROUGH_STUFF[@]}" "--makefile" )

   # We expand this array with the Q operator when writing to the Makefile.
   # This ensures escaping sufficient for reuse in a shell command.
   escaped_cmd=${cmd[*]@Q}

   # Make requires all dollar signs (whether quoted or not) to be escaped with
   # a second dollar sign.
   escaped_cmd=${escaped_cmd//$/\$$}

   # Tabs are required for Makefile indentations
   tab=$(printf '\t')

   # Labs are started in parallel with GNU Make, which automatically handles
   # lab.dep (which is formatted as Makefile targets).
   #
   # The script is invoked with each VM name as a target on the command line,
   # which directs Make to run:
   #   lstart [...] --makefile <machine>
   # for each machine. $* is a GNU Make automatic variable that expands to the
   # % (stem) in the target. In this usage it will expand to the machine name.
   #
   # The contents of lab.dep is copied in if it exists, which creates a target
   # for each machine with dependencies ("prerequisities" in Make).
   # NOTE: The dummy target is required, which has the unwanted side-effect
   # that machines cannot be named "dummy-prerequisite-to-force-remaking".
   # 
   # The Makefile must use Bash as the shell for correct handling of ANSI-C
   # expansions present after the previous Q-operator array expansion.
   IFS='' read -r -d '' makefile_contents << EOF
SHELL := /bin/bash

%: dummy-prerequisite-to-force-remaking
${tab}[ '\$*' != "lab.dep" ] && $escaped_cmd '\$*'

dummy-prerequisite-to-force-remaking:
${tab}# Dummy line. Unuseful, yet necessary

$(cat "$LAB_DIRECTORY/lab.dep" 2> /dev/null)
EOF

   # Read the Makefile from stdin without implicit rules, and hide the output. It
   # it parallelised to the MAX_SIMULTANEOUS_VMS configuration option.
   make -irsC "$LAB_DIRECTORY" -f - -j "$MAX_SIMULTANEOUS_VMS" "${VHOSTLIST[@]}" <<< "$makefile_contents"

   
   # Signal that every machine is ready for testing once booted.
   [ -n "$TESTMODE" ] && : > "$LAB_DIRECTORY/readyfor.test"
}


###############################################################################
# Generate a DOT language graph from a list of lab.conf files and virtual
# machine names and write to standard output.
# Usage:
#   generate_dot_graph [LAB_CONF]...
# Globals:
#   r- VHOSTLIST
# Arguments:
#  ... - list of lab.conf files to analyse
# Returns:
#   None
# Example:
#   generate_dot_graph lab.conf | dot
###############################################################################
generate_dot_graph() {
   local lab_confs=( "$@" )

   # Global map parameters
   cat << EOF
graph netkit_jh_graph {
   overlap="prism";
   overlap_scaling=-6.0;
   resolution=400.0;
   splines="line";
EOF

   declare -A device_ids options

   while IFS= read -r configuration; do
      # The [][] is ][ inside a bracket expression to match an opening or
      # closing square bracket. We know the machine name cannot contain
      # square brackets, so the option is the first instance of them.
      vm=$(awk -F"[][]" '{ print $1 }' <<< "$configuration")
      option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

      # Everything after the first '='
      value=${configuration#*=}

      # Ignore if VM is not part of the lab
      array_contains "$vm" "${VHOSTLIST[@]}" || continue

      # If option is all-digit, it must be a network interface specification
      if [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]]; then
         # Ignore if it has already been seen
         [[ "${device_ids[$vm]}" =~ \ $option\  ]] && continue

         # Add an edge between the machine and its collision domain
         cat << EOF
   "$vm" -- "$value" [
      taillabel=<
         <TABLE BGCOLOR="white" BORDER="0" CELLPADDING="1" CELLSPACING="0">
            <TR>
               <TD>eth$option</TD>
            </TR>
         </TABLE>
      >,
      labeldistance=1.5,
      labelfontsize=8.0
   ];'
EOF

         domains+=( "$value" )

         # Device IDs cannot have whitespace, so a space-separated list is
         # safe.
         device_ids[$vm]+=" $option "
      else
         options[$vm]+="$option = $value<BR/>"
      fi
   done < <(grep --no-filename "^[[:blank:]].*\[.*\][[:blank:]]*=" "${lab_confs[@]}")
   # TODO: Replace .* in above grep (and any other similar search) with the
   # hostname regex.

   # Label each machine with its hostname and vstart options
   for vm in "${VHOSTLIST[@]}"; do
      cat << EOF
   "$vm" [
      shape=box,
      label=<
         $vm
         <FONT POINT-SIZE="10">
            <BR/>${options[$vm]}
         </FONT>
      >,
      height=0.5,
      width=0.5
   ];
EOF
   done

   # Remove bounding box from collision domain labels (just text)
   for domain in "${domains[@]}"; do
      cat << EOF
   "$domain" [
      shape=plaintext,
      width=0,
      height=0,
      margin=0
   ]
EOF
   done

   echo "}"
}


# This function creates a link-level topology map of the lab. Its argument is
# the name of the PNG file to save the map in.
lab_map() {
   local map_file=$1
   local lab_confs=( "${@:2}" )

   GRAPH_GENERATOR=$(which neato)
   if [ -z "$GRAPH_GENERATOR" ]; then
      echo 1>&2 "Error: the GraphViz library does not appear to be installed."
      echo 1>&2 "Please install the GraphViz library."
      return 1
   fi

   generate_dot_graph "${lab_confs[@]}" | "$GRAPH_GENERATOR" -Tpng -o"$map_file"
}
