#!/bin/false
# shellcheck shell=bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is a support script for the Netkit lcommands. It is not intended for
# standalone usage.


###############################################################################
# Print a string with bold formatting.
# Usage:
#   bold_print MESSAGE
# Globals:
#   r- color_bold
#   r- color_normal
# Arguments:
#   $1 - string to print
# Returns:
#   None
# Example:
#   None
###############################################################################
bold_print() {
   printf "%b%s%b\n" "$color_bold" "$1" "$color_normal"
}


###############################################################################
# Check if an array contains a string.
# Usage:
#   array_contains QUERY ARRAY
# Globals:
#   None
# Arguments:
#   $1 - string to search for
#   $2 - word-expanded array to search
# Returns:
#   0 if array contains query, non-zero if not
# Example:
#   bar=( a b c )
#   if array_contains "a" "${bar[@]}"; then echo "Found!"; fi
###############################################################################
array_contains() {
   local query=$1
   local array=( "${@:2}" )

   local item

   for item in "${array[@]}"; do
      [ "$query" = "$item" ] && return 0
   done

   return 1
}


###############################################################################
# Set VHOSTLIST to a list of machines in the lab taken from the directory
# listing. If VHOSTLIST is already set (such as by the user on the command
# line), machines not present in the lab are removed from the array.
# Usage:
#   build_vhostlist DIR
# Globals:
#   rw VHOSTLIST
# Arguments:
#   $1 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
build_vhostlist() {
   local lab_directory=$1

   local vhost
   local lab_dir_vhosts lab_conf_vhosts cmdline_vhosts
   local lab_dir_vhosts_override

   # Build list of virtual machines that are part of the lab
   # TODO: should LAB_MACHINES override this?
   for dir in "$lab_directory"/*/; do
      vhost=$(basename "$dir")

      # Avoid the shared and _test directories
      if [ "$vhost" = "shared" ] || [ "$vhost" = "_test" ]; then
         continue
      fi

      lab_dir_vhosts+=( "$vhost" )
   done

   # Get machine list override from lab.conf LAB_MACHINES and the command line.
   # If either are set, they will override the directory listing for machine
   # names. The command-line specification takes precedence over the
   # LAB_MACHINES variable.
   # Note: LAB_MACHINES is a comma-separated (whitespace is not ignored) list.
   # This means if hostname_regex allows, machine names cannot have commas in
   # them.
   # TODO: allow commas (if so desired) in LAB_MACHINES hostnames with quotes
   # or escape sequences.
   IFS="," read -r -a lab_conf_vhosts <<< "$(get_lab_variable "LAB_MACHINES" "$lab_directory")"
   cmdline_vhosts=( "${VHOSTLIST[@]}" )

   [ "${#lab_conf_vhosts[@]}" -gt 0 ] && lab_dir_vhosts_override=( "${lab_conf_vhosts[@]}" )
   [ "${#cmdline_vhosts[@]}" -gt 0 ] &&  lab_dir_vhosts_override=( "${cmdline_vhosts[@]}" )

   # If the user has explicitly provided a machine list (via command line or
   # LAB_MACHINES), verify that the machines are in the lab.
   if [ "${#lab_dir_vhosts_override[@]}" -gt 0 ]; then
      unset VHOSTLIST

      for vhost in "${lab_dir_vhosts_override[@]}"; do
         if array_contains "$vhost" "${lab_dir_vhosts[@]}"; then
            VHOSTLIST+=( "$vhost" )
         else
            echo 1>&2 "Warning: '$vhost' is not part of the lab in '$lab_directory'"
         fi
      done
   else
      VHOSTLIST=( "${lab_dir_vhosts[@]}" )
   fi

   validate_hostnames "${VHOSTLIST[@]}"
}


###############################################################################
# From a lab info associative array (key is directory basename, value is the
# relevant attribute's value) construct a formatted list suitable for
# lab_welcome output (i.e. value1 (dir1, dir2, ...), value2 (dir3, dir4, ...),
# ...) and write to standard output.
# Usage:
#   generate_lab_info_str LAB_INFO
# Globals:
#   None
# Arguments:
#   $1 - lab information associative array name reference
# Returns:
#   None
# Example:
#   None
###############################################################################
generate_info_str() {
   local -n lab_info=$1

   local lab value
   local lab_info_str separator

   declare -A collated_lab_info_values

   # For each directory chosen, add its lab information value as a key to an
   # array with a value of directory listings. For example, for a lab_info
   # array of version numbers:
   #
   #     lab_info["lab3a"]="1.0"
   #     lab_info["lab3b"]="1.1"
   #     lab_info["lab3c"]="1.0"
   #     lab_info["lab3d"]="2.0"
   #
   # This would be transformed into collated_lab_info_values:
   #
   #     collated_lab_info_values["1.0"]="lab3a, lab3c"
   #     collated_lab_info_values["1.1"]="lab3b"
   #     collated_lab_info_values["2.0"]="lab3d"
   for lab in "${!lab_info[@]}"; do
      value=${lab_info[$lab]:-"<unknown>"}

      # Append the lab name to its relevant value's list if the value has been
      # seen before (exists as a key in the array). If not, start the list.
      if array_contains "$value" "${!collated_lab_info_values[@]}"; then
         collated_lab_info_values[$value]="${collated_lab_info_values[$value]}, $lab"
      else
         collated_lab_info_values[$value]=$lab
      fi
   done

   # collated_lab_info_values is then flattened into a string to display in the
   # lab_welcome dialog.
   if [ ${#collated_lab_info_values[@]} -gt 1 ]; then
      for value in "${!collated_lab_info_values[@]}"; do
         lab_info_str+="$separator$value (${collated_lab_info_values[$value]})"

         # Comma-separate subsequent interfaces
         separator=", "
      done
   elif [ ${#collated_lab_info_values[@]} -eq 1 ]; then
      # If all labs share the same value, it is not necessary to display the
      # lab names.
      lab_info_str=${!collated_lab_info_values[*]}
   else
      # If no lab has the parameter defined.
      lab_info_str="<unknown>"
   fi

   echo "$lab_info_str"
}


###############################################################################
# Get the value of a parameter set in a lab's lab.conf file and write to
# standard output.
# Usage:
#   get_lab_variable VARIABLE DIR
# Globals:
#   None
# Arguments:
#   $1 - lab variable name
#   $2 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
get_lab_variable() {
   local variable=$1
   local lab_conf="$2/lab.conf"

   # Set lab variables from lab.conf. The sed expression prints only the first
   # matching line and deletes the variable name and equals sign.
   sed -n "0,/^[[:blank:]]*$variable=/s///p" "$lab_conf"
}


###############################################################################
# Print out information about the labs in the given directories. Unset values
# will be outputted as "<unknown>".
# Usage:
#   lab_welcome [DIRECTORY]...
# Globals:
#   r- color_blue
#   r- color_bold
#   r- color_normal
#   r- SCRIPTNAME
# Arguments:
#  ... - list of lab directories
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_welcome() {
   local lab_directories=( "$@" )

   local lab_directories_str
   local dir lab

   declare -A lab_versions lab_authors lab_emails lab_webs lab_descriptions

   printf -v lab_directories_str '%s, ' "${lab_directories[@]}"
   lab_directories_str=${lab_directories_str%", "}

   for dir in "${lab_directories[@]}"; do
         # Check that the lab directory exists
      if [ ! -d "$dir" ]; then
         echo 1>&2 "$SCRIPTNAME: $dir: No such directory"
         exit 1
      fi

      lab=$(basename "$dir")

      # We use associative arrays for printing the values with their respective
      # directory basename. SC2034 (variable appears unused) must be ignored
      # because the arrays are only referenced by name.
      # shellcheck disable=SC2034
      lab_versions[$lab]=$(get_lab_variable "LAB_VERSION" "$dir")
      # shellcheck disable=SC2034
      lab_authors[$lab]=$(get_lab_variable "LAB_AUTHOR" "$dir")
      # shellcheck disable=SC2034
      lab_emails[$lab]=$(get_lab_variable "LAB_EMAIL" "$dir")
      # shellcheck disable=SC2034
      lab_webs[$lab]=$(get_lab_variable "LAB_WEB" "$dir")
      # shellcheck disable=SC2034
      lab_descriptions[$lab]=$(get_lab_variable "LAB_DESCRIPTION" "$dir")
   done

   # Convert the multi-lab arrays to flat, comma-separated lists and print
   # TODO: echo -e (or similar) for this and all other output
   echo "${color_bold}Lab directory(ies)$color_normal: $color_blue$lab_directories_str$color_normal"
   echo "${color_bold}Version(s)$color_normal:         $color_blue$(generate_info_str lab_versions)$color_normal"
   echo "${color_bold}Author(s)$color_normal:          $color_blue$(generate_info_str lab_authors)$color_normal"
   echo "${color_bold}Email(s)$color_normal:           $color_blue$(generate_info_str lab_emails)$color_normal"
   echo "${color_bold}URL(s)$color_normal:             $color_blue$(generate_info_str lab_webs)$color_normal"
   echo "${color_bold}Description(s)$color_normal:"
   echo "$color_blue$(generate_info_str lab_descriptions)$color_normal"
}


###############################################################################
# Remove temporary files from the lab directory and .netkit.
# Usage:
#   lab_clean DIR
# Globals:
#   r- MCONSOLE_DIR
#   rw VHOSTLIST
# Arguments:
#   $1 - lab directory
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_clean() {
   local lab_directory=$1

   local vhost

   build_vhostlist "$lab_directory"

   bold_print "Cleaning up lab inside '$lab_directory'..."

   for vhost in "${VHOSTLIST[@]}"; do
      # Remove files from the lab directory
      rm ${VERBOSE:+"--verbose"} -r "${MCONSOLE_DIR:?}/$vhost"
      rm ${VERBOSE:+"--verbose"} "$lab_directory/$vhost."{"ready","disk","log","testdone"}
   done

   rm ${VERBOSE:+"--verbose"} "$lab_directory/readyfor.test"
}


###############################################################################
# Crash virtual machines of a Netkit lab.
# Usage:
#   lab_crash DIR KEEP_FS KILL
# Globals:
#   r- VERBOSE
#   rw VHOSTLIST
# Arguments:
#   $1 - lab directory
#   $2 - set to 1 to keep the filesystem, empty string for otherwise
#   $3 - set to 1 to kill machine process, empty string for otherwise
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_crash() {
   local lab_directory=$1
   local keep_fs=$2
   local kill_mode=$3

   local vcrash_args vhost

   build_vhostlist "$lab_directory"

   [ -z "$VERBOSE" ]   && vcrash_args+=( "-q" )
   [ -z "$keep_fs" ]   && vcrash_args+=( "-r" )
   [ -n "$kill_mode" ] && vcrash_args+=( "-k" )
   
   for vhost in "${VHOSTLIST[@]}"; do
      [ -n "$VERBOSE" ] && bold_print "Crashing '$vhost'..."
      vcrash "${vcrash_args[@]}" "$vhost" && rm -f "$lab_directory/$vhost.ready"
   done
   
   bold_print "Removing readyfor.test..."
   rm -f "$lab_directory/readyfor.test"
}


###############################################################################
# Start a single virtual machine within a lab.
# Usage:
#   single_lab_vm_start FAST_MODE DIR MACHINE [PASSTHROUGH]...
# Globals:
#   r- GRACE_TIME
#   r- VERBOSE
# Arguments:
#   $1 - set to 1 for fast mode, empty string otherwise
#   $2 - lab directory
#   $3 - machine to start up
#  ... - options to passthrough to vstart (appended on)
# Returns:
#   None
# Example:
#   None
###############################################################################
single_lab_vm_start() {
   local fast_mode=$1
   local lab_directory=$2
   local vm=$3
   local passthrough_args=( "${@:4}" )

   local configuration option value

   # Add host lab and working directory, and place filesystem inside the lab
   # directory.
   local vstart_args=( "--hostlab" "$lab_directory" "--hostwd" "$PWD" "--filesystem" "$lab_directory/$vm.disk" )

   # Generate vstart argument list
   if [ -e "$lab_directory/lab.conf" ]; then
      while IFS= read -r configuration; do
         # The [][] is ][ inside a bracket expression to match an opening or
         # closing square bracket. We know the machine name cannot contain
         # square brackets, so the option is the first instance of them.
         option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

         # Everything after the first '='
         value=${configuration#*=}

         # If option is all-digit, it must be a network interface specification
         [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]] && option="eth$option"

         if [ "${#option}" -eq 1 ]; then
            vstart_args+=( "-$option" )
         else
            vstart_args+=( "--$option" )
         fi

         # NOTE: if vstart is ever changed to have an option with an optional
         # argument (denoted with '::' in the option string), an exception when
         # appending the argument must be made (an '=' is required for long
         # options, no delimiter for short ones).
         [ -n "$value" ] && vstart_args+=( "$value" )
      done < <(grep "^[[:blank:]]*$vm\[.*\][[:blank:]]*=" "$lab_directory/lab.conf")
   fi
   
   # Remove .ready file, if existing
   [ -e "$lab_directory/$vm.ready" ] && rm -f "$lab_directory/$vm.ready"

   if [ -z "$VERBOSE" ]; then
      bold_print "Starting '$vm'..."
   else
      bold_print "Starting '$vm' with options '${vstart_args[*]} ${passthrough_args[*]}'... "
   fi

   if ! vstart "${vstart_args[@]}" "${passthrough_args[@]}" "$vm"; then
      echo 2>&1 "Error while starting virtual machine '$vm'"
      exit 1
   fi

   # Wait for virtual host startup script to create .ready file
   if [ -z "$fast_mode" ]; then
      while [ ! -e "$lab_directory/$vm.ready" ]; do
         sleep 1
      done

      rm -f "$lab_directory/$vm.ready"
   fi
   
   # Wait for a specified amount of time before returning
   [ "$GRACE_TIME" -gt 0 ] && sleep "$GRACE_TIME"
}


###############################################################################
# Start virtual machines of a Netkit lab sequentially.
# Usage:
#   lab_start FAST_MODE TEST_MODE MAKEFILE DIR [PASSTHROUGH]...
# Globals:
#   rw VHOSTLIST
# Arguments:
#   $1 - set to 1 for fast mode, empty string otherwise
#   $2 - set to 1 for test mode, empty string otherwise
#   $3 - used internally when lstart is invoked with Make
#   $4 - lab directory
#  ... - array of options to pass through into vstart
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start() {
   local fast_mode=$1
   local test_mode=$2
   local makefile=$3
   local lab_directory=$4
   local passthrough_args=( "${@:5}" )

   local vhost

   build_vhostlist "$lab_directory"

   if [ "${#VHOSTLIST[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi

   # We prepend so passthrough_args can override 
   [ -z "$VERBOSE" ] && passthrough_args=( "-q" "${passthrough_args[@]}" )

   # TODO: global rename of vhost to vm? Or vice-versa
   for vhost in "${VHOSTLIST[@]}"; do
      single_lab_vm_start "$fast_mode" "$lab_directory" "$vhost" "${passthrough_args[@]}"
   done
   
   # The readyfor.test file should not be created if we have been invoked
   # with the --makefile option (=launch a single machine and exit).
   [ -n "$test_mode" ] && [ -z "$makefile" ] && : > "$lab_directory/readyfor.test"
}


###############################################################################
# Start virtual machines of a Netkit lab simultaneously with GNU Make.
# Usage:
#   lab_start_parallel TEST_MODE DIR [PASSTHROUGH]...
# Globals:
#   r- MAX_SIMULTANEOUS_VMS
#   rw VHOSTLIST
# Arguments:
#   $1 - set to 1 for test mode, empty string otherwise
#   $2 - lab directory
#  ... - array of options to pass through into vstart
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start_parallel() {
   local test_mode=$1
   local lab_directory=$2
   local passthrough_args=( "${@:3}" )

   local lstart_args arg
   local lstart_cmd escaped_lstart_cmd
   local tab makefile_contents

   build_vhostlist "$lab_directory"
   
   if [ "${#VHOSTLIST[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi
   
   # Pass "passthrough" options on to the second invocation of lstart/ltest
   [ -n "$VERBOSE" ] && lstart_args+=( "-v" )

   for arg in "${passthrough_args[@]}"; do
      lstart_args+=( "-o" "$arg" )
   done

   # Pass testmode along subsequent invocations of this script
   if [ -n "$test_mode" ]; then
      program_name="ltest"
   else
      program_name="lstart"
   fi
   
   # The make utility expects an empty argument to -j when infinitely many jobs
   # should be used.
   [ "$MAX_SIMULTANEOUS_VMS" -eq 0 ] && unset MAX_SIMULTANEOUS_VMS


   lstart_cmd=( "$program_name" "-d" "$lab_directory" "--makefile" "${lstart_args[@]}" )

   # We expand this array with the Q operator when writing to the Makefile.
   # This ensures escaping sufficient for reuse in a shell command.
   escaped_lstart_cmd=${lstart_cmd[*]@Q}

   # Make requires all dollar signs (whether quoted or not) to be escaped with
   # a second dollar sign.
   escaped_lstart_cmd=${escaped_lstart_cmd//$/\$$}

   # Labs are started in parallel with GNU Make, which automatically handles
   # lab.dep (which is formatted as Makefile targets).
   #
   # The script is invoked with each VM name as a target on the command line,
   # which directs Make to run:
   #   lstart [...] --makefile <machine>
   # for each machine. $* is a GNU Make automatic variable that expands to the
   # % (stem) in the target. In this usage it will expand to the machine name.
   #
   # The contents of lab.dep is copied in if it exists, which creates a target
   # for each machine with dependencies ("prerequisities" in Make).
   # NOTE: The dummy target is required, which has the unwanted side-effect
   # that machines cannot be named "dummy-prerequisite-to-force-remaking".
   # 
   # The Makefile must use Bash as the shell for correct handling of ANSI-C
   # expansions present after the previous Q-operator array expansion.
   tab=$(printf '\t')
   IFS='' read -r -d '' makefile_contents << EOF
SHELL := /bin/bash

%: dummy-prerequisite-to-force-remaking
${tab}[ '\$*' != "lab.dep" ] && $escaped_lstart_cmd '\$*'

dummy-prerequisite-to-force-remaking:
${tab}# Dummy line. Unuseful, yet necessary

$(cat "$lab_directory/lab.dep" 2> /dev/null)
EOF

   # Read the Makefile from stdin without implicit rules, and hide the output. It
   # it parallelised to the MAX_SIMULTANEOUS_VMS configuration option.
   make -irsC "$lab_directory" -f - -j ${MAX_SIMULTANEOUS_VMS:+"$MAX_SIMULTANEOUS_VMS"} "${VHOSTLIST[@]}" <<< "$makefile_contents"

   
   # Signal that every machine is ready for testing once booted.
   [ -n "$test_mode" ] && : > "$lab_directory/readyfor.test"
}


###############################################################################
# Generate a DOT language graph from a list of lab.conf files and virtual
# machine names and write to standard output.
# Usage:
#   generate_dot_graph [LAB_CONF]...
# Globals:
#   r- VHOSTLIST
# Arguments:
#  ... - list of lab.conf files to analyse
# Returns:
#   None
# Example:
#   generate_dot_graph lab.conf | dot
###############################################################################
generate_dot_graph() {
   local lab_confs=( "$@" )

   local configuration vm option value
   local hub_name hub_names

   declare -A device_ids options

   # Global map parameters
   cat << EOF
graph netkit_jh_graph {
   overlap="prism";
   overlap_scaling=-6.0;
   resolution=400.0;
   splines="line";
EOF

   while IFS= read -r configuration; do
      # The [][] is ][ inside a bracket expression to match an opening or
      # closing square bracket. We know the machine name cannot contain
      # square brackets, so the option is the first instance of them.
      vm=$(awk -F"[][]" '{ print $1 }' <<< "$configuration")
      option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

      # Everything after the first '='
      value=${configuration#*=}

      # Ignore if VM is not part of the lab
      array_contains "$vm" "${VHOSTLIST[@]}" || continue

      # If option is all-digit, it must be a network interface specification
      if [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]]; then
         # Ignore if it has already been seen
         [[ "${device_ids[$vm]}" =~ \ $option\  ]] && continue

         # Add an edge between the machine and its collision domain
         cat << EOF
   "$vm" -- "$value" [
      taillabel=<
         <TABLE BGCOLOR="white" BORDER="0" CELLPADDING="1" CELLSPACING="0">
            <TR>
               <TD>eth$option</TD>
            </TR>
         </TABLE>
      >,
      labeldistance=1.5,
      labelfontsize=8.0
   ];'
EOF

         hub_names+=( "$value" )

         # Device IDs cannot have whitespace, so a space-separated list is
         # safe.
         device_ids[$vm]+=" $option "
      else
         options[$vm]+="$option = $value<BR/>"
      fi
   done < <(grep --no-filename "^[[:blank:]].*\[.*\][[:blank:]]*=" "${lab_confs[@]}")
   # TODO: Replace .* in above grep (and any other similar search) with the
   # hostname regex.

   # Label each machine with its hostname and vstart options
   for vm in "${VHOSTLIST[@]}"; do
      cat << EOF
   "$vm" [
      shape=box,
      label=<
         $vm
         <FONT POINT-SIZE="10">
            <BR/>${options[$vm]}
         </FONT>
      >,
      height=0.5,
      width=0.5
   ];
EOF
   done

   # Remove bounding box from collision domain labels (just text)
   for hub_name in "${hub_names[@]}"; do
      cat << EOF
   "$hub_name" [
      shape=plaintext,
      width=0,
      height=0,
      margin=0
   ]
EOF
   done

   echo "}"
}


# This function creates a link-level topology map of the lab. Its argument is
# the name of the PNG file to save the map in.
lab_map() {
   local map_file=$1
   local lab_confs=( "${@:2}" )

   # TODO: check for its existence in setup scripts
   local graph_generator="neato"

   if ! command -v "$graph_generator" > /dev/null 2>&1; then
      echo 1>&2 "$SCRIPTNAME: $graph_generator: Graphviz graph generator not found"
      exit 1
   fi

   generate_dot_graph "${lab_confs[@]}" | "$graph_generator" -Tpng -o"$map_file"
}


# ANSI color escape sequences
color_normal='\033[0m'
color_bold='\033[1m'
color_red='\033[31;1m'
color_green='\033[32;1m'
color_yellow='\033[33;1m'
color_blue='\033[34;1m'
