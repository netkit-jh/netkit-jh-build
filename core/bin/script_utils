#!/bin/false
# shellcheck shell=bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This script contains support definitions, functions and other shell stuff for
# use within the other Netkit scripts. It is not intended for standalone usage.
# NOTE: it is assumed that the NETKIT_HOME environment variable is set. This
# should be enforced by the calling script(s).


# Guard to prevent sourcing the script multiple times
[ -n "$SCRIPT_UTILS_SRC" ] && return
SCRIPT_UTILS_SRC=1


###############################################################################
# Check if string is a valid IPv4 dotted-quad address.
# Usage:
#   is_inet_addr ADDR
# Globals:
#   r- inet_regex
# Arguments:
#   $1 - IPv4 address string
# Returns:
#   Returns 0 on success, non-zero if an invalid address.
# Example:
#   None
###############################################################################
is_inet_addr() {
   local addr=$1
   [[ "$addr" =~ ^$inet_regex$ ]] && return 0 || return 1
}


###############################################################################
# Validate a list of hostnames against the hostname_regex pattern.
# Usage:
#   validate_hostnames [HOSTNAME]...
# Globals:
#   r- hostname_regex
#   r- SCRIPTNAME
# Arguments:
#  ... - list of hostnames to validate
# Returns:
#   None. Exits with a non-zero code on an invalid hostname.
# Example:
#   None
###############################################################################
validate_hostnames() {
   local hostnames=( "$@" )

   local hostname

   for hostname in "${hostnames[@]}"; do
      if [[ ! "$hostname" =~ ^$hostname_regex$ ]]; then
         echo 1>&2 "$SCRIPTNAME: $hostname: Invalid hostname"
         exit 1
      fi
   done
}


###############################################################################
# Validate a list of collision domain names against the
# collision_domain_name_regex pattern.
# Usage:
#   validate_collision_domain_names [DOMAIN]...
# Globals:
#   r- collision_domain_name_regex
# Arguments:
#  ... - list of collision domain names to validate
# Returns:
#   0 if all valid, non-zero on an invalid hostname
# Example:
#   None
###############################################################################
validate_collision_domain_names() {
   local collision_domain_names=( "$@" )

   local collision_domain_name

   for collision_domain_name in "${collision_domain_names[@]}"; do
      [[ ! "$collision_domain_name" =~ ^$collision_domain_name_regex$ ]] && return 1
   done

   return 0
}


###############################################################################
# Check if a string contains sub-strings.
# Usage:
#   string_contains STRING [QUERY]...
# Globals:
#   None
# Arguments:
#   $1 - string to search
#  ... - string(s) to search for
# Returns:
#   0 if string contains at least one query, non-zero if not
# Example:
#   None
###############################################################################
string_contains() {
   local string=$1
   local queries=( "${@:2}" )

   local query

   for query in "${queries[@]}"; do
      [[ "$string" == *"$query"* ]] && return 0
   done

   return 1
}


###############################################################################
# Check if an array contains a string.
# Usage:
#   array_contains QUERY ARRAY
# Globals:
#   None
# Arguments:
#   $1 - string to search for
#   $2 - word-expanded array to search
# Returns:
#   0 if array contains query, non-zero if not
# Example:
#   bar=( a b c )
#   if array_contains "a" "${bar[@]}"; then echo "Found!"; fi
###############################################################################
array_contains() {
   local query=$1
   local array=( "${@:2}" )

   local item

   for item in "${array[@]}"; do
      [ "$query" = "$item" ] && return 0
   done

   return 1
}


###############################################################################
# Write commands to the Netkit-JH log file.
# Usage:
#   log_write ...
# Globals:
#   r- LOGFILENAME
#   r- USER_ID
# Arguments:
#  ... Log message
# Returns:
#   echo returns 0 on success, non-zero on failure (if file is not writable or
#   cannot be created).
# Example:
#   None
###############################################################################
log_write() {
   [ -n "$LOGFILENAME" ] && echo "$(date --iso-8601=seconds) $USER_ID $*" >> "$LOGFILENAME"
}


###############################################################################
# Write the "try --help" message to standard error.
# Usage:
#   try_help
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
try_help() {
   echo 1>&2 "Try '$SCRIPTNAME --help' for more information."
}


###############################################################################
# Write the standard --help command-line option usage to standard output.
# Usage:
#   help_option
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
help_option() {
   echo "      --help          display this help and exit"
}


###############################################################################
# Write the standard --version command-line option usage to standard output.
# Usage:
#   version_option
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
version_option() {
   echo "      --version       output version information and exit"
}


###############################################################################
# Write the Netkit-JH core, filesystem, and kernel versions, and host kernel
# release version to standard output.
# Usage:
#   show_version
# Globals:
#   r- NETKIT_HOME
#   r- VM_KERNEL
#   r- VM_MODEL_FS
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
show_version() {
   local netkit_version
   local kernel_filepath kernel_filename kernel_version
   local filesystem_version_long filesystem_version

   # Netkit version information
   echo -n "Netkit version:            "

   if netkit_version=$(grep "Netkit version" "$NETKIT_HOME/netkit-version" 2> /dev/null); then
      netkit_version=${netkit_version##"Netkit version "}

      if [[ "$netkit_version" =~ ^([0-9]+[.-])+[0-9]+[a-zA-Z]*$ ]]; then
         echo "$netkit_version"
      else
         echo "<unknown>"
      fi
   else
      echo "<unknown>"
   fi
   
   # Netkit kernel version information
   echo -n "Netkit kernel version:     "

   if [ -e "$VM_KERNEL" ]; then
      kernel_filepath=$VM_KERNEL

      # By default, the compiled kernel is a symbolic link
      [ -L "$kernel_filepath" ] && kernel_filepath=$(readlink "$kernel_filepath")
      
      kernel_filename=$(basename "$kernel_filepath")
      kernel_version=${kernel_filename##"netkit-kernel-"}

      if [ "$kernel_version" = "$kernel_filename" ]; then
         echo "<unknown>"
      else
         echo "$kernel_version"
      fi
   else
      echo "<unknown>"
   fi

   # Netkit filesystem version information
   echo -n "Netkit filesystem version: "
   filesystem_version_long=$(cat "$NETKIT_HOME/fs/netkit-filesystem-version" 2> /dev/null)
   filesystem_version=${filesystem_version_long##"Netkit-JH filesystem version "}
   echo "${filesystem_version:-"<unknown>"}"
   
   # Host kernel version information
   echo -n "Host kernel version:       "
   uname -r
}


###############################################################################
# Test if a file is being used by a process.
# Usage:
#   file_in_use FILE
# Globals:
#   None
# Arguments:
#   $1 - file to test
# Returns:
#   Returns 0 if the file is in use by a process, non-zero if not or on failure
#   (e.g., if file does not exist).
# Example:
#   None
###############################################################################
file_in_use() {
   lsof -f -- "$1" > /dev/null 2>&1
}


###############################################################################
# Write the tap interface name assigned to a user to standard output.
# Usage:
#   get_tap_interface USER
# Globals:
#   None
# Arguments:
#   $1 - owner of the network interface
# Returns:
#   None
# Example:
#   None
###############################################################################
get_tap_interface() {
   local target_user=$1

   local user_md5

   # We name Netkit tap devices after the user who owns them. Linux network
   # interface names are case-sensitive and:
   #   - Must not be empty
   #   - Must be less than 16 characters
   #   - Must not contain '/' or whitespace
   # Usernames in Linux have different requirements. There's a possibility, for
   # example, where two usernames with a common prefix create Netkit tap
   # devices. If the prefix is longer than 8 characters, their tap devices will
   # have the same name and be indistuinguishable; for example, users
   # 'foobarbaz_steve' and 'foobarbaz_brian' both create the tap device named
   # 'netkit_foobarba'. Using the MD5 digest of the target user and truncating
   # to 8 chracters will be sufficient for ensuring uniqueness on a system with
   # many users.
   user_md5=$(printf "%s" "$target_user" | md5sum)

   echo "netkit_${user_md5:0:8}"
}


###############################################################################
# Write the socket filepath assigned to a user and collision domain to standard
# output. The MD5 digest of the user's name is used to prevent issues with
# invalid characters in the username.
# Usage:
#   get_hub_socket DOMAIN
# Globals:
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- USER_ID
# Arguments:
#   $1 - name of collision domain
# Returns:
#   None
# Example:
#   None
###############################################################################
get_hub_socket() {
   local domain=$1
   
   local user_md5

   user_md5=$(printf "%s" "$USER_ID" | md5sum | awk '{ print $1 }')
   echo "$HUB_SOCKET_DIR/${HUB_SOCKET_PREFIX}_${user_md5}_$domain$HUB_SOCKET_EXTENSION"
}


###############################################################################
# Create a special 'tap' hub that can connect a guest to an interface on the
# host. NAT rules are created to allow access to the Internet through the host
# interface.
# Usage:
#   start_inet_hub JUST_PRINT HUB ADDR
# Globals:
#   r- HUB_LOG
#   r- NETKIT_HOME
#   r- USER_ID
# Arguments:
#   $1 - set to 1 if only doing a dry run, otherwise pass an empty string
#   $2 - hub socket filepath
#   $3 - address of the tap interface on the host
# Returns:
#   None. Exits with a non-zero code on a configuration error
# Example:
#   None
###############################################################################
start_inet_hub() {
   local just_print=$1
   local hub_socket=$2
   local tap_address=$3

   local manage_tuntap_cmd
   local interface_name uml_switch_cmd printed_uml_switch_cmd line_buffered_uml_switch_cmd
   local hub_log_cmd

   if [ ! -S "$hub_socket" ] || ! file_in_use "$hub_socket"; then
      # Either socket does not exist yet or it is still unused
      manage_tuntap_cmd=( "$NETKIT_HOME/bin/manage_tuntap" "start" "$USER_ID" "$tap_address" )

      echo "******** Starting Internet connected virtual hub ********"
      echo "   (host) $tap_address"
      echo "********     (root privileges are required)      ********"

      if [ -n "$just_print" ]; then
         echo "Not running ==> ${manage_tuntap_cmd[*]}"
      else
         echo "Running ==> ${manage_tuntap_cmd[*]}"

         if "${manage_tuntap_cmd[@]}"; then
            echo 1>&2 "Error while configuring the tunnel."
            exit 1
         fi
      fi

      echo "************** Abandoning root privileges ***************"

      interface_name=$(get_tap_interface "$USER_ID")
      uml_switch_cmd=( "$NETKIT_HOME/bin/uml_switch" "-tap" "$interface_name" "-hub" "-unix" "$hub_socket" )
      printed_uml_switch_cmd="${uml_switch_cmd[*]} < /dev/null &"

      # We need to disable buffering on standard output, otherwise the hub log
      # may miss vital log messages when uml_switch is killed.
      line_buffered_uml_switch_cmd=( "stdbuf" "--output=0" "${uml_switch_cmd[@]}" )

      # shellcheck disable=SC2016
      hub_log_cmd=( "stdbuf" "--output=0" \
                    "awk" "--assign" "HUB=$hub_socket" "--assign" "USER=$USER_ID" "--assign" "TIME=$(date --iso-8601=seconds)" \
                    '{printf "%s %15s %25s %s\n", TIME, USER, HUB, $0}' )

      if [ -n "$just_print" ]; then
         echo "Not running ==> $printed_uml_switch_cmd"
      else
         echo "Running ==> $printed_uml_switch_cmd"
         "${line_buffered_uml_switch_cmd[@]}" < /dev/null 2>&1 | "${hub_log_cmd[@]}" >> "$HUB_LOG" &
      fi
   fi

   # Wait for uml_switch to start
   while [ -z "$just_print" ] && [ ! -S "$hub_socket" ]; do
      sleep 1
   done
}


###############################################################################
# Start a virtual network hub.
# Usage:
#   start_hub JUST_PRINT HUB
# Globals:
#   r- HUB_LOG
#   r- NETKIT_HOME
#   r- USER_ID
# Arguments:
#   $1 - set to 1 if only doing a dry run, otherwise pass an empty string
#   $2 - hub socket filepath
# Returns:
#   None. Exits with a non-zero code on a configuration error
# Example:
#   None
###############################################################################
start_hub() {
   local just_print=$1
   local hub_socket=$2

   local uml_switch_cmd printed_uml_switch_cmd line_buffered_uml_switch_cmd
   local hub_log_cmd

   # Socket already exists but is not used
   if [ ! -S "$hub_socket" ] || ! file_in_use "$hub_socket"; then
      uml_switch_cmd=( "$NETKIT_HOME/bin/uml_switch" "-hub" "-unix" "$hub_socket" )
      printed_uml_switch_cmd="${uml_switch_cmd[*]} < /dev/null &"

      # We need to disable buffering on standard output, otherwise the hub log
      # may miss vital log messages when uml_switch is killed.
      line_buffered_uml_switch_cmd=( "stdbuf" "--output=0" "${uml_switch_cmd[@]}" )
   
      # shellcheck disable=SC2016
      hub_log_cmd=( "stdbuf" "--output=0" \
                    "awk" "--assign" "HUB=$hub_socket" "--assign" "USER=$USER_ID" "--assign" "TIME=$(date --iso-8601=seconds)" \
                    '{printf "%s %15s %25s %s\n", TIME, USER, HUB, $0}' )
      
      if [ -n "$just_print" ]; then
         echo "Not running ==> $printed_uml_switch_cmd"
      else
         echo "Running ==> $printed_uml_switch_cmd"
         "${line_buffered_uml_switch_cmd[@]}" < /dev/null 2>&1 | "${hub_log_cmd[@]}" >> "$HUB_LOG" &
      fi
   fi

   # Wait for uml_switch to start
   while [ -z "$just_print" ] && [ ! -S "$hub_socket" ]; do
      sleep 1
   done
}


###############################################################################
# Start all hubs specified in an array.
# Usage:
#   run_hubs JUST_PRINT [HUB[,ADDR]]...
# Globals:
#   r- HUB_LOG
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- NETKIT_HOME
#   r- USER_ID
# Arguments:
#   $1 - set to 1 if only doing a dry run, otherwise pass an empty string
#  ... - list of hub names optionally paired with an IP address (for a tap
#        interface).
# Returns:
#   None. Exits with a non-zero code on a configuration error
# Example:
#   run_hubs "" hub1 hub2 tap,10.0.0.1 hub3
###############################################################################
run_hubs() {
   local just_print=$1
   local hub_specifications=( "${@:2}" )

   local hub_specification hub_name tap_address hub_socket

   for hub_specification in "${hub_specifications[@]}"; do
      IFS=, read -r hub_name tap_address <<< "$hub_specification"

      hub_socket=$(get_hub_socket "$hub_name")

      if [ -n "$tap_address" ]; then
         start_inet_hub "$just_print" "$hub_socket" "$tap_address"
      else
         start_hub "$just_print" "$hub_socket"
      fi
   done
}


###############################################################################
# Stop and remove all unused virtual hubs.
# Usage:
#   clean_hubs [HUB[,ADDR]]...
# Globals:
#   r- HUB_LOG
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- NETKIT_HOME
#   r- USER_ID
# Arguments:
#  ... - list of hub names optionally paired with an IP address (address goes
#        unused but exists as an option if reusing a list used as input to
#        run_hubs).
# Returns:
#   None
# Example:
#   None
###############################################################################
clean_hubs() {
   local hub_specifications=( "$@" )

   local hub_specification hub_name hub_socket
   local hub_pid

   for hub_specification in "${hub_specifications[@]}"; do
      IFS=, read -r hub_name _ <<< "$hub_specification"

      hub_socket=$(get_hub_socket "$hub_name")

      # Avoid attempting to kill hubs for which the socket file does not exist
      # any more. Such situation may occur if user accidentally deleted it
      # (in which case the hub can safely be killed by using vclean), or if
      # a virtual machine has two (or more) network interfaces attached to the
      # same hub (in which case the script attempts to kill it twice).
      [ ! -e "$hub_socket" ] && continue

      if file_in_use "$hub_socket"; then
         # We get the oldest process to limit output to a single PID
         hub_pid=$(pgrep --oldest --euid="$USER_ID" --full "^$NETKIT_HOME/bin/uml_switch[[:blank:]].*$hub_socket")
         if [ "$(lsof -a -U -p "$hub_pid" -Fn | grep --count "^n$hub_socket")" -le 1 ]; then
            # No more virtual machines are using the switch connected to this socket
            kill "$hub_pid" && rm "$hub_socket"
         fi
      else
         # There are no switches connected to this socket - remove it
         rm "$hub_socket"
      fi
   done
}


###############################################################################
# Check if machine, by name, is online.
# Usage:
#   get_machine_state USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Returns 0 if online, non-zero if not.
# Example:
#   None
###############################################################################
get_machine_state() {
   local target_user=$1
   local vhost=$2
   get_vhost_pid_by_name "$target_user" "$vhost" > /dev/null
}


###############################################################################
# Get the process ID of a machine by its name and, optionally, owner.
# Usage:
#   get_vhost_pid_by_name USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Prints the PID to stdout. Returns 0 on success, non-zero on failure.
# Example:
#   None
###############################################################################
get_vhost_pid_by_name() {
   local target_user=$1
   local vhost=$2

   local full_command_regex
   local pid pgid full_command
   local first_iteration argument umid


   # Quick filter for pgrep. It is not 100% accurate, returning multiple
   # instances if there is a machine called "foo" and "foo bar". We hence do
   # further processing - this filter just removes processes which definitely
   # are not matches.
   full_command_regex="^$VM_KERNEL.*[[:blank:]]umid=$vhost(\$|[[:blank:]])"

   # The process hierarchy looks like this:
   #
   #    PID  PGID  Process
   #     ?    ?     vstart
   #                    \
   #     x    x           - netkit-kernel
   #                           |
   #     a    x                +--- netkit-kernel
   #     b    x                +--- netkit-kernel
   #     c    x                +--- netkit-kernel
   #     ...  ...              +--- ...
   #
   #    (PID = process ID, PGID = process group ID)
   #
   # The main (parent) netkit-kernel process is the group leader of the
   # netkit-kernel child processes, because its PID == PGID.
   # The children are all part of this group.
   #
   # We only care about the parent kernel process, so we skip over PIDs that
   # are not group leaders.

   # Iterate over the PIDs of running Netkit instances with name matches.
   for pid in $(pgrep ${target_user:+"--euid=$target_user"} --full "$full_command_regex"); do
      # Get the process group ID (PGID)
      pgid=$(ps --no-headers --format pgid --pid "$pid")

      # Ignore if not a process leader
      [ "$pgid" -ne "$pid" ] && continue

      # Full command used to invoke the process
      mapfile -d "" -t full_command < "/proc/$pid/cmdline"

      first_iteration=true
      for argument in "${full_command[@]}"; do
         # Skip program name
         if $first_iteration; then
            first_iteration=false
            continue
         fi

         if [[ "$argument" =~ ^umid=.*$ ]]; then
            umid=${argument#*=}

            if [ "$umid" = "$vhost" ]; then
               echo "$pid"
               return 0
            else
               break
            fi
         fi
      done
   done

   return 1
}


###############################################################################
# Get a list of all of the process IDs of a machine by its name and,
# optionally, owner.
# Usage:
#   get_vhost_all_pids_by_name USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Prints an IFS separated list of PIDs related to MACHINE to stdout. Returns
#   0 if the machine exists, non-zero otherwise.
# Example:
#   for pid in $(get_vhost_all_pids_by_name "" "foobar"); do echo $pid; done
###############################################################################
get_vhost_all_pids_by_name() {
   local target_user=$1
   local vhost=$2

   local full_command_regex
   local pid full_command
   local first_iteration argument umid pids


   # Quick filter for pgrep. It is not 100% accurate, returning multiple
   # instances if there is a machine called "foo" and "foo bar". We hence do
   # further processing - this filter just removes processes which definitely
   # are not matches.
   full_command_regex="^$VM_KERNEL.*[[:blank:]]umid=$vhost(\$|[[:blank:]])"

   # See get_vhost_pid_by_name for a process hierarchy explanation.

   # Iterate over the PIDs of running Netkit instances with name matches.
   for pid in $(pgrep ${target_user:+"--euid=$target_user"} --full "$full_command_regex"); do
      # Full command used to invoke the process
      mapfile -d "" -t full_command < "/proc/$pid/cmdline"

      first_iteration=true
      for argument in "${full_command[@]}"; do
         # Skip program name
         if $first_iteration; then
            first_iteration=false
            continue
         fi

         if [[ "$argument" =~ ^umid=.*$ ]]; then
            umid=${argument#*=}

            if [ "$umid" = "$vhost" ]; then
               pids+=( "$pid" )
            fi

            break
         fi
      done
   done

   echo "${pids[*]}"

   [ "${#pids[@]}" -gt 0 ] && return 0 || return 1
}


###############################################################################
# Fill the vhost_info and vhost_sockets global arrays with information about a
# running virtual machine.
# Usage:
#   get_vhost_info_by_pid PID
# Globals:
#   r- MCONSOLE_DIR
#   rw vhost_info
#   rw vhost_sockets
# Arguments:
#   $1 - process ID of the machine
# Returns:
#   None
# Example:
#   None
###############################################################################
get_vhost_info_by_pid() {
   local pid=$1

   local first_iteration argument option value
   local device_id
   local vhost_info_other

   # Unset the globals
   unset vhost_info
   unset vhost_sockets

   declare -A -g vhost_info

   vhost_info["pid"]=$pid

   # Effective user ID of the process (full username if not too long)
   vhost_info["owner"]=$(ps --no-headers --format euser --pid "$pid")

   # Total virtual memory usage of the process.
   # Logically this should be the sum of every process in the group (PGID),
   # however in practice just taking the value of the parent process is enough.
   # The value should equate to roughly the size of the machine's memory.
   vhost_info["memory_usage"]=$(ps --no-headers --format vsize --pid "$pid")

   # Full command used to invoke the process.
   # Why not parse the output of ps? Whitespace in the program name or
   # arguments is impossible to deal with. /proc/$pid/cmdline stores argv with
   # null-byte field separators, which is the only character that cannot be
   # present in a Linux filepath.
   # vhost_info[full_command] will store a quoted and escaped command string
   # suitable for reuse as a shell command.
   mapfile -d "" -t full_command < "/proc/$pid/cmdline"
   vhost_info["full_command"]=${full_command[*]@Q}

   first_iteration=true
   for argument in "${full_command[@]}"; do
      if $first_iteration; then
         vhost_info["kernel"]=$argument
         first_iteration=false
         continue
      fi

      # UML options are key=value pairs. ${argument#*=} removes the key= prefix
      # from argument (the single # permits usage of further equals signs in
      # the argument).
      option=${argument%%=*}
      value=${argument#*=}

      # Edge-cases that can only be matched with regular expressions (or with
      # extglob enabled, which cannot be done.)
      if [[ "$option" =~ ^eth([0-9]|[1-9][0-9]+)$ ]]; then
         # Interface number
         device_id=${option#eth}

         # Array of UML socket filepaths indexed by the interface number.
         # NOTE: we assume transport mode is 'daemon'
         # Disable SC2034 check (unused variable) - it is used elsewhere as a
         # global.
         # shellcheck disable=SC2034
         vhost_sockets[$device_id]=${value#daemon,,,}
         continue
      fi

      # Most of the command-line options can be matched with basic pattern
      # matching.
      # NOTE: some non-UML parameters will be enclosed in escaped double quotes
      # to allow for whitespace in them.
      case $option in
         con0)
            # NOTE: tmux sessions are identified later in the command line with
            # a dummy option.
            case $value in
               xterm)      vhost_info["con0"]=$value;;
               fd:0,fd:1)  vhost_info["con0"]="this";;
               pty)        vhost_info["con0"]=$value;;
               port:*)     vhost_info["con0"]=$value;;
               null)       vhost_info["con0"]="none";;
            esac
            ;;
         con1)
            case $value in
               xterm)      vhost_info["con1"]=$value;;
               fd:0,fd:1)  vhost_info["con1"]="this";;
               pty)        vhost_info["con1"]=$value;;
               port:*)     vhost_info["con1"]=$value;;
               null)       vhost_info["con1"]="none";;
            esac
            ;;
         \"exec)       vhost_info["boot_cmd"]=${value%\"};;
         \"hosthome)   vhost_info["hosthome"]=${value%\"};;
         \"hostlab)    vhost_info["hostlab"]=${value%\"};;
         # Memory is NOT adjusted by the skew here
         mem)        vhost_info["mem"]=$value;;
         \"modules)    vhost_info["modules"]=${value%\"};;
         tmux)       vhost_info["con0"]="tmux";;
         \"ubd0)
            # The ubd0 value is disk,fs or fs
            vhost_info["disk"]=${value%%,*}
            vhost_info["fs"]=${value#*,}

            # The parameter expansions result in equal values if a single,
            # shared filesystem is used.
            [ "${vhost_info["disk"]}" = "${vhost_info["fs"]}" ] && unset vhost_info["disk"]

            vhost_info["fs"]=${vhost_info[fs]%\"}
            ;;
         umid)       vhost_info["umid"]=$value;;
         *)          vhost_info_other+=( "$argument" )
      esac
   done

   vhost_info["other"]="${vhost_info_other[*]}"

   # The UML console socket filepath
   vhost_info["mconsole"]="$MCONSOLE_DIR/${vhost_info[umid]}/mconsole"
}


###############################################################################
# Fill the vhost_info and vhost_sockets global arrays with information about a
# running virtual machine by machine name and, optionally, user.
# Usage:
#   get_vhost_info_by_name USER VM
# Globals:
#   rw vhost_info
#   rw vhost_sockets
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   0 on success, non-zero on failure
# Example:
#   None
###############################################################################
get_vhost_info_by_name() {
   local target_user=$1
   local vhost=$2

   local pid

   if ! pid=$(get_vhost_pid_by_name "$target_user" "$vhost"); then
      return 1
   fi

   get_vhost_info_by_pid "$pid"
   return 0
}


###############################################################################
# Check for invalid substrings in a variable and exit with an error.
# Usage:
#   validate_variable VALUE VARIABLE [QUERY]...
# Globals:
#   None
# Arguments:
#   $1 - value of variable
#   $2 - name of variable
#  ... - list of invalid substrings to search for
# Returns:
#   None. Function exits with non-zero code on failure.
# Example:
#   None
###############################################################################
validate_variable() {
   local value=$1
   local variable=$2
   local queries=( "${@:3}" )

   if string_contains "$value" "${queries[@]}"; then
      echo 1>&2 "$variable: Invalid character in configuration parameter"
      exit 1
   fi
}


###############################################################################
# Check for invalid substrings in netkit.conf variable values.
# Usage:
#   validate_netkit_conf_variables
# Globals:
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_PREFIX
#   r- HUB_SOCKET_EXTENSION
#   r- VM_MODEL_FS
# Arguments:
#   None
# Returns:
#   None. Function exits with non-zero code on failure.
# Example:
#   None
###############################################################################
validate_netkit_conf_variables() {
   validate_variable "$HUB_SOCKET_DIR"       "HUB_SOCKET_DIR"       " " ","
   validate_variable "$HUB_SOCKET_PREFIX"    "HUB_SOCKET_PREFIX"    " " "," "/"
   validate_variable "$HUB_SOCKET_EXTENSION" "HUB_SOCKET_EXTENSION" " " "," "/"
   validate_variable "$VM_MODEL_FS"          "VM_MODEL_FS"          " " "," ":"
}


###############################################################################
# Create a directory with 777 permissions. If a file with the same path already
# exists, an error is thrown.
# Usage:
#   netkit_dir_check DIR
# Globals:
#   None
# Arguments:
#   $1 - directory filepath
# Returns:
#   None. Function exits with non-zero code on failure.
# Example:
#   None
###############################################################################
netkit_dir_check() {
   local dir=$1
   mkdir --parents "$dir" || exit 1
   chmod 777 "$dir"
}


# Override all locale settings to avoid localisation errors
export LC_ALL=C


# Regular expression for matching an IPv4 address with range validation
inet_regex="((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])"

# Regular expression for a Debian-approved (and RFC-compliant) hostname
# label. This expression can be substituted directly into most Linux utility
# commands, such as egrep (grep -E).
#
# Debian standard for hostname 'labels' (hostname(7) man page):
#   - May consist of A-Z, a-z, 0-9, and - (hyphen)
#   - Cannot start or end with a - (hyphen)
#   - Are case-insensitive
#   - Can be 1 to 63 characters long
# NOTE: must not allow the following characters:
#         []          - for lab.conf parsing
#         ,           - for LAB_MACHINES parsing
#         ,:[:blank:] - for the ubd argument (.disk file is named after host)
hostname_regex="([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,62}[a-zA-Z0-9])"

# Regular expression for matching a collision domain name. This choice is
# arbitrary (though some characters MUST be avoided), but should allow for all
# reasonable use-cases.
# NOTE: must not allow commas, forward slashes, or whitespace.
collision_domain_name_regex="([[:alnum:]_.-]+)"


# Read Netkit configuration in order of file localisation (per system, per
# install, per user).
# TODO: move into own source script
# shellcheck disable=SC1091
[ -f /etc/netkit.conf ] && . "/etc/netkit.conf"
# shellcheck source=../netkit.conf
[ -f "$NETKIT_HOME/netkit.conf" ] && . "$NETKIT_HOME/netkit.conf"
# shellcheck disable=SC1091
[ -f "$HOME/.netkit/netkit.conf" ] && . "$HOME/.netkit/netkit.conf"


# Assign default values to undefined parameters
: "${LOGFILENAME:=""}"
: "${MCONSOLE_DIR:="$HOME/.netkit/mconsole"}"
: "${HUB_SOCKET_DIR:="$HOME/.netkit/hubs"}"
: "${HUB_SOCKET_PREFIX:="vhub"}"
: "${HUB_SOCKET_EXTENSION:=".cnct"}"
: "${HUB_LOG:="$HUB_SOCKET_DIR/vhubs.log"}"
: "${VPACKAGE_MOUNT_POINT:="/mnt/netkit-fs-mount-point/"}"
: "${VM_MEMORY:=32}"
: "${VM_MEMORY_SKEW:=4}"
: "${VM_MODEL_FS:="$NETKIT_HOME/fs/netkit-fs"}"
: "${VM_KERNEL:="$NETKIT_HOME/kernel/netkit-kernel"}"
: "${VM_CON0:=xterm}"
: "${VM_CON1:=none}"
: "${TERM_TYPE:=xterm}"
: "${MAX_INTERFACES:=40}"
: "${MIN_MEM:=12}"
: "${MAX_MEM:=512}"
: "${MAX_SIMULTANEOUS_VMS:=5}"
: "${GRACE_TIME:=0}"
: "${TMUX_OPEN_TERMS:="no"}"
: "${CHECK_FOR_UPDATES:="yes"}"
: "${UPDATE_CHECK_PERIOD:=5}"

# Check whether some environment variables override default settings
[ -n "$NETKIT_FILESYSTEM" ] && VM_MODEL_FS=$NETKIT_FILESYSTEM
[ -n "$NETKIT_MEMORY" ] &&     VM_MEMORY=$NETKIT_MEMORY
[ -n "$NETKIT_KERNEL" ] &&     VM_KERNEL=$NETKIT_KERNEL
[ -n "$NETKIT_TERM" ] &&       TERM_TYPE=$NETKIT_TERM

# Check for invalid values in netkit.conf variables
validate_netkit_conf_variables


# Set the global USER_ID variable
USER_ID=$(id -un)


# Ensure critical directories exist
netkit_dir_check "$HOME/.netkit"
netkit_dir_check "$HUB_SOCKET_DIR"
netkit_dir_check "$MCONSOLE_DIR"
