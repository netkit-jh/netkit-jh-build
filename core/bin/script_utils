#!/bin/false
# shellcheck shell=bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This script contains support definitions, functions and other shell stuff for
# use within the other Netkit scripts. It is not intended for standalone usage.

# Here we assume that the NETKIT_HOME environment variable has been properly set
# (other scripts will take care about that).

# force language to avoid localization errors
export LANG=C

# Read Netkit configuration
# There must be multiple ShellCheck directives to mask warnings

# shellcheck source=../netkit.conf
[ -f /etc/netkit.conf ] && . "/etc/netkit.conf"

# shellcheck source=../netkit.conf
[ -f "$NETKIT_HOME/netkit.conf" ] && . "$NETKIT_HOME/netkit.conf"

# shellcheck source=../netkit.conf
[ -f "$HOME/.netkit/netkit.conf" ] && . "$HOME/.netkit/netkit.conf"

# Assign default values to undefined parameters
: ${LOGFILENAME:=""}
: ${MCONSOLE_DIR:="$HOME/.netkit/mconsole"}
: ${HUB_SOCKET_DIR:="$HOME/.netkit/hubs"}
: ${HUB_SOCKET_PREFIX:="vhub"}
: ${HUB_SOCKET_EXTENSION:=".cnct"}
: ${HUB_LOG:="$HUB_SOCKET_DIR/vhubs.log"}
: ${VM_MEMORY:=32}
: ${VM_MEMORY_SKEW:=4}
: ${VM_MODEL_FS:="$NETKIT_HOME/fs/netkit-fs"}
: ${VM_KERNEL:="$NETKIT_HOME/kernel/netkit-kernel"}
: ${VM_CON0:=xterm}
: ${VM_CON1:=none}
: ${CON0_PORTHELPER:="no"}
: ${TERM_TYPE:=xterm}
: ${MAX_INTERFACES:=40}
: ${MIN_MEM:=12}
: ${MAX_MEM:=512}
: ${MAX_SIMULTANEOUS_VMS:=5}
: ${GRACE_TIME:=0}
: ${USE_SUDO:="yes"}
: ${TMUX_OPEN_TERMS:="no"}
: ${CHECK_FOR_UPDATES:="yes"}
: ${UPDATE_CHECK_PERIOD:=5}

# Check whether some environment variables override default settings
[ ! -z "$NETKIT_FILESYSTEM" ] && VM_MODEL_FS=$NETKIT_FILESYSTEM
[ ! -z "$NETKIT_MEMORY" ] && VM_MEMORY=$NETKIT_MEMORY
[ ! -z "$NETKIT_KERNEL" ] && VM_KERNEL=$NETKIT_KERNEL
[ ! -z "$NETKIT_CON0" ] && VM_CON0=$NETKIT_CON0
[ ! -z "$NETKIT_CON1" ] && VM_CON1=$NETKIT_CON1
[ ! -z "$NETKIT_TERM" ] && TERM_TYPE=$NETKIT_TERM


# This function implements on-the-fly replacement of substrings on environment
# variables. Arguments are: the name of the environment variable (the *name*,
# not its value!), the regular expression to be searched for, and the
# replacement string.
varReplace() {
   local VARIABLE_NAME REGEXP REPLACE_STRING VARIABLE_VALUE
   VARIABLE_NAME="$1"
   REGEXP="$2"
   REPLACE_STRING="$3"
   eval VARIABLE_VALUE='$'"${VARIABLE_NAME}"
   echo "${VARIABLE_VALUE}" | awk "{gsub(/${REGEXP}/, \"${REPLACE_STRING}\"); print}"
}


# This function checks whether its argument contains spaces
checkSpaces() {
   STRING="$1"
   if containsRegexp STRING " "; then
      echo 1>&2 "$SCRIPTNAME: Argument '$STRING' contains spaces. They are not allowed"
      exit 1
   fi
}


###############################################################################
# Check if string is a valid IPv4 dotted-quad address.
# Usage:
#   is_inet_addr ADDR
# Globals:
#   None
# Arguments:
#   $1 - IPv4 address string
# Returns:
#   Returns 0 on success, non-zero if an invalid address.
# Example:
#   None
###############################################################################
is_inet_addr() {
   inet_regex="((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])"
   [[ "$1" =~ $inet_regex ]] && return 0 || return 1
}


# This function converts a relative path to an absolute path, if needed
makeAbsolutePath() {
   ARGUMENT=$(echo "$1" | awk '{gsub("^ *",""); print}')
   if containsRegexp ARGUMENT '^/' || containsRegexp ARGUMENT '^~' || containsRegexp ARGUMENT '^\$'; then
      # This is an absolute path
      eval echo $ARGUMENT
   else
      # This is a relative path
      eval echo "${PWD}/$ARGUMENT"
   fi
}


# This function searches for a regexp inside a variable value. Arguments are:
# the name of the environment variable (the *name*, not its value!) and the
# regular expression to be searched for.
containsRegexp() {
   local VARIABLE_NAME VARIABLE_VALUE REGEXP
   VARIABLE_NAME="$1"
   REGEXP="$2"
   eval VARIABLE_VALUE='$'"${VARIABLE_NAME}"
   echo "$VARIABLE_VALUE" | grep -q "$REGEXP" >/dev/null
   return $?
}


###############################################################################
# Write commands to the Netkit-JH log file.
# Usage:
#   log_write ...
# Globals:
#   r- LOGFILENAME
# Arguments:
#  ... Log message
# Returns:
#   echo returns 0 on success, non-zero on failure (if file is not writable,
#   cannot be created, or the filename is not specified).
# Example:
#   None
###############################################################################
log_write() {
   echo "$(date +"%Y/%m/%d %H:%M:%S") $(id -nu) $*" 2> /dev/null >> "$LOGFILENAME"
}


###############################################################################
# Write the "try --help" message to standard error.
# Usage:
#   try_help
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
try_help() {
   echo 1>&2 "Try '$SCRIPTNAME --help' for more information."
}


###############################################################################
# Write the standard --help command-line option usage to standard output.
# Usage:
#   help_option
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
help_option() {
   echo "      --help          display this help and exit"
}


###############################################################################
# Write the standard --version command-line option usage to standard output.
# Usage:
#   version_option
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
version_option() {
   echo "      --version       output version information and exit"
}


###############################################################################
# Write the Netkit-JH core, filesystem, and kernel versions, and host kernel
# release version to standard output.
# Usage:
#   show_version
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
show_version() {
   local netkit_version
   local kernel_filepath kernel_filename kernel_version
   local filesystem_filepath filesystem_filename filesystem_version
   
   # Netkit version information
   echo -n "Netkit version:            "

   if netkit_version=$(grep "Netkit version" "$NETKIT_HOME/netkit-version" 2> /dev/null); then
      netkit_version="${netkit_version##"Netkit version "}"

      if [[ "$netkit_version" =~ ^([0-9]+[.-])+[0-9]+[a-zA-Z]*$ ]]; then
         echo "$netkit_version"
      else
         echo "<unknown>"
      fi
   else
      echo "<unknown>"
   fi
   
   # Netkit kernel version information
   echo -n "Netkit kernel version:     "

   if [ -e "$VM_KERNEL" ]; then
      kernel_filepath=$VM_KERNEL

      # By default, the compiled kernel is a symbolic link
      [ -L "$kernel_filepath" ] && kernel_filepath=$(readlink "$kernel_filepath")
      
      kernel_filename=$(basename "$kernel_filepath")
      kernel_version=${kernel_filename##"netkit-kernel-"}

      if [ "$kernel_version" = "$kernel_filename" ]; then
         echo "<unknown>"
      else
         echo "$kernel_version"
      fi
   else
      echo "<unknown>"
   fi

   # Netkit filesystem version information
   echo -n "Netkit filesystem version: "

   if [ -e "$VM_MODEL_FS" ]; then
      filesystem_filepath=$VM_MODEL_FS

      # By default, the filesystem is a symbolic link
      [ -L "$filesystem_filepath" ] && filesystem_filepath=$(readlink "$filesystem_filepath")

      filesystem_filename=$(basename "$filesystem_filepath")
      filesystem_version=${filesystem_filename##"netkit-fs-"}

      if [ "$filesystem_version" = "$filesystem_filename" ]; then
         echo "<unknown>"
      else
         echo "$filesystem_version"
      fi
   fi
   
   # Host kernel version information
   echo -n "Host kernel version:       "
   uname -r
}


# This function creates a directory and sets global permissions for it.
# If the directory already exists, an error is issued.
ensureDir() {
   if [ ! -e "$1" ]; then
      mkdir "$1"
      chmod 777 "$1"
   elif [ ! -d "$1" ]; then
      echo 1>&2 "File $1 exists: unable to create directory $1. Sorry..."
      exit 1
   fi
}




# Ensure personal Netkit dir exists
ensureDir $HOME/.netkit
# Ensure hub socket dir exists
ensureDir $HUB_SOCKET_DIR
# Ensure mconsole dir exists
ensureDir $MCONSOLE_DIR

USERID=$(id -un)


###############################################################################
# Execute a command and write the argument list to stdout.
# Usage:
#   run_command DRY_RUN PRINTED_CMD CMD...
# Globals:
#   r- BE_QUIET
# Arguments:
#   $1 - set to 1 if only doing a dry run of the command that would be ran.
#        Otherwise pass an empty string.
#   $2 - the command to print. If an empty string, this will be set to the
#        actual command that is ran.
#  ... - the command to run as a separated argument list.
# Returns:
#   Returns the exit status of the command.
# Example:
#   None
###############################################################################
run_command() {
   dry_run=$1
   printed_cmd=$2
   shift
   shift

   cmd=( "$@" )

   # If the command to print has not been explicitly given, we print the one
   # being executed.
   [ -z "$printed_cmd" ] && printed_cmd=$*

   if [ -n "$dry_run" ] && [ -z "$BE_QUIET" ]; then
      echo "Not running ==> $printed_cmd"
      return
   fi

   [ -z "$BE_QUIET" ] && echo "Running ==> $printed_cmd"
   "${cmd[@]}"
}


###############################################################################
# Test if a file is being used by a process.
# Usage:
#   file_in_use FILE
# Globals:
#   None
# Arguments:
#   $1 - file to test
# Returns:
#   Returns 0 if the file is in use by a process, non-zero if not or on failure
#   (e.g., if file does not exist).
# Example:
#   None
###############################################################################
file_in_use() {
   lsof -f -- "$1" > /dev/null 2>&1
}


# This function starts a special hub that is connected to the Internet, if it
# does not exist yet (this operation requires administrative privileges).
# Arguments are: hub name, tap interface IP address, guest interface IP address.
startInetHub() {
   local HUB_COMMAND COMPLETE_COMMAND TAP_DEVICE TUNTAP_COMMAND

   if [ ! -S "$1" ] || ! file_in_use "$1"; then
      # Either socket does not exist yet or it is still unused
      if [ "$USE_SUDO" = "yes" ]; then
         TUNTAP_COMMAND=( "sudo" "-p" "$USER's password:" "$NETKIT_HOME/bin/manage_tuntap" "$NETKIT_HOME" "start" "$USER" "$2" "$3" "$1" )
      else
         TUNTAP_COMMAND=( "su" "-mc" "$NETKIT_HOME/bin/manage_tuntap" "$NETKIT_HOME" "start" "$USER" "$2" "$3" "$1" )
      fi
      if [ -z "$BE_QUIET" ]; then
         echo "******** Starting Internet connected virtual hub ********"
         echo "   $TAP_ADDRESS (host side) - $GUEST_ADDRESS (guest side)"
         echo "********     (root privileges are required)      ********"
         run_command "$JUST_PRINT" \
                     "$NETKIT_HOME/bin/manage_tuntap $NETKIT_HOME start $USER $2 $3 $1" \
                     "${TUNTAP_COMMAND[@]}" || \
            { echo 1>&2 "Error while configuring the tunnel."; exit 1; }
         echo "************** Abandoning root privileges ***************"
         echo
      else
         run_command "$JUST_PRINT" \
                     "$NETKIT_HOME/bin/manage_tuntap $NETKIT_HOME start $USER $2 $3 $1" \
                     "${TUNTAP_COMMAND[@]}" > /dev/null || \
            { echo 1>&2 "Error while configuring the tunnel."; exit 1; }
      fi

      TAP_DEVICE="nk_tap_$USER"

      # TODO: run_command "$JUST_PRINT" "$HUB_COMMAND" "$COMPLETE_COMMAND"
      "$NETKIT_HOME/bin/uml_switch" -tap "$TAP_DEVICE" -hub -unix "$1" < /dev/null 2>&1 | awk -v SWITCHNAME="$1" -v USER="$USERID" -v CURRENTDATE="$(date +"%Y/%m/%d %H:%M:%S")" '{ printf "%s %15s %25s %s\n", CURRENTDATE, USER, SWITCHNAME, $0 }' > "$HUB_LOG" &
   fi
   
   # Wait for uml_switch to start
   while [ -z "$JUST_PRINT" -a ! -S "$1" ]; do
      sleep 1
   done
}


# This function starts a hub, if it does not exist yet
startHub() {
   # Socket already exists but is not used
   if [ ! -S "$1" ] || ! file_in_use "$1"; then
      # TODO: run_command "$JUST_PRINT" "$HUB_COMMAND" "$COMPLETE_COMMAND"
      "$NETKIT_HOME/bin/uml_switch" -hub -unix "$1" < /dev/null 2>&1  | awk -v SWITCHNAME="$1" -v USER="$USERID" -v CURRENTDATE="$(date +"%Y/%m/%d %H:%M:%S")" '{printf "%s %15s %25s %s\n", CURRENTDATE, USER, SWITCHNAME, $0}' > "$HUB_LOG" &
   fi
   
   # Wait for uml_switch to start
   while [ -z "$JUST_PRINT" -a ! -S "$1" ]; do
      sleep 1
   done
}


# This function starts all the hubs inside a given list
runHubs() {
   local hub_name BASE_HUB_NAME ACTUAL_HUB_NAME TAP_ADDRESS GUEST_ADDRESS

   hubs=( "$@" )

   for hub_name in "${hubs[@]}"; do
      BASE_HUB_NAME=$(varReplace hub_name ".*_" "")

      if [ "${BASE_HUB_NAME#tap${HUB_SOCKET_EXTENSION},}" != "$BASE_HUB_NAME" ]; then
         IFS=, read -r ACTUAL_HUB_NAME TAP_ADDRESS GUEST_ADDRESS <<< "$hub_name"
         startInetHub "$ACTUAL_HUB_NAME" "$TAP_ADDRESS" "$GUEST_ADDRESS"
      else
         # This is a normal hub
         startHub "$hub_name"
      fi
   done
}


# This function takes as argument a list of sockets used by virtual hubs, stops
# those that are not used by any virtual machine and deletes the corresponding
# sockets.
cleanHubs() {
   local FULL_HUB_NAME BASE_HUB_NAME
   while [ $# -gt 0 ]; do
      FULL_HUB_NAME=$1
      BASE_HUB_NAME="$(varReplace FULL_HUB_NAME ".*_" "")"
      if [ "${BASE_HUB_NAME#tap${HUB_SOCKET_EXTENSION},}" != "$BASE_HUB_NAME" ]; then
         # This is an Internet connected hub
         FULL_HUB_NAME=$(echo $FULL_HUB_NAME | awk -v FS="," '{print $1}')
      fi
      
      # Avoid attempting to kill hubs for which the socket file does not exist
      # any more. Such situation may occur if user accidentally deleted it
      # (in which case the hub can safely be killed by using vclean), or if
      # a virtual machine has two (or more) network interfaces attached to the
      # same hub (in which case the script attempts to kill it twice).
      if [ ! -e "$FULL_HUB_NAME" ]; then
         shift
         continue
      fi
      
      if file_in_use $FULL_HUB_NAME; then
         SWITCH_PROCESS=$(ps -wwwwwweo pid,command --sort=pid | grep "uml_switch.*$FULL_HUB_NAME" | grep -v "grep uml_switch" | awk '{print $1}' | head -n 1)
         if [ $(lsof -p $SWITCH_PROCESS 2>/dev/null | grep -c $FULL_HUB_NAME) -le 1 ]; then
            # No more virtual machines are using the switch connected to this socket
            kill $SWITCH_PROCESS > /dev/null 2>&1 && rm -f $FULL_HUB_NAME
         fi
      else
         # There are no switches connected to this socket: just remove it
         rm -f $FULL_HUB_NAME
      fi
      shift
   done
}


###############################################################################
# Remove the filesystem of a virtual machine.
# Usage:
#   remove_fs FILE
# Globals:
#   None
# Arguments:
#   $1 - filesystem filepath
# Returns:
#   None
# Example:
#   None
###############################################################################
remove_fs() {
   rm --verbose "$1"
}


###############################################################################
# Check if machine, by name, is online.
# Usage:
#   get_machine_state USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Returns 0 if online, non-zero if not.
# Example:
#   None
###############################################################################
get_machine_state() {
   user=$1
   name=$2
   get_vm_pid_by_name "$user" "$name" > /dev/null
}


###############################################################################
# Get the process ID of a machine by its name and, optionally, owner.
# Usage:
#   get_vm_pid_by_name USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Prints the PID to stdout. Returns 0 on success, non-zero on failure.
# Example:
#   None
###############################################################################
get_vm_pid_by_name() {
   user=$1
   name=$2

   [ -n "$user" ] && pgrep_euid="--euid"

   # Quick filter for pgrep. It is not 100% accurate, returning multiple
   # instances if there is a machine called "foo" and "foo bar". We hence do
   # further processing - this filter just removes processes which definitely
   # are not matches.
   full_command_regex="^$NETKIT_HOME/kernel/netkit-kernel.*[[:blank:]]umid=${name}(\$|[[:blank:]].+)"

   # The process hierarchy looks like this:
   #
   #    PID  PGID  Process
   #     ?    ?     vstart
   #                    \
   #     x    x           - netkit-kernel
   #                           |
   #     a    x                +--- netkit-kernel
   #     b    x                +--- netkit-kernel
   #     c    x                +--- netkit-kernel
   #     ...  ...              +--- ...
   #
   #    (PID = process ID, PGID = process group ID)
   #
   # The main (parent) netkit-kernel process is the group leader of the
   # netkit-kernel child processes, because its PID == PGID.
   # The children are all part of this group.
   #
   # We only care about the parent kernel process, so we skip over PIDs that
   # are not group leaders.

   # Iterate over the PIDs of running Netkit instances with name matches.
   for pid in $(pgrep ${pgrep_euid:+"$pgrep_euid"} ${user:+"$user"} --full "$full_command_regex"); do
      # Get the process group ID (PGID)
      pgid=$(ps --no-headers --format pgid --pid "$pid")

      # Ignore if not a process leader
      [ "$pgid" -ne "$pid" ] && continue

      # Full command used to invoke the process
      full_command=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

      first_iteration=true
      while IFS="" read -r argument; do
         # Skip program name
         if $first_iteration; then
            first_iteration=false
            continue
         fi

         if [[ "$argument" =~ ^umid=.*$ ]]; then
            umid=${argument#*=}

            if [ "$umid" = "$name" ]; then
               echo "$pid"
               return 0
            else
               break
            fi
         fi
      done <<< "$full_command"
   done

   return 1
}


###############################################################################
# Get a list of all of the process IDs of a machine by its name and,
# optionally, owner.
# Usage:
#   get_vm_all_pids_by_name USER MACHINE
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   Prints an IFS separated list of PIDs related to MACHINE to stdout. Returns
#   0 if the machine exists, non-zero otherwise.
# Example:
#   for pid in $(get_vm_all_pids_by_name "" "foobar"); do echo $pid; done
###############################################################################
get_vm_all_pids_by_name() {
   local vm_pids

   user=$1
   name=$2

   [ -n "$user" ] && pgrep_euid="--euid"

   # Quick filter for pgrep. It is not 100% accurate, returning multiple
   # instances if there is a machine called "foo" and "foo bar". We hence do
   # further processing - this filter just removes processes which definitely
   # are not matches.
   full_command_regex="^$NETKIT_HOME/kernel/netkit-kernel.*[[:blank:]]umid=${name}(\$|[[:blank:]].+)"

   # See get_vm_pid_by_name for a process hierarchy explanation.

   # Iterate over the PIDs of running Netkit instances with name matches.
   for pid in $(pgrep ${pgrep_euid:+"$pgrep_euid"} ${user:+"$user"} --full "$full_command_regex"); do
      # Full command used to invoke the process
      full_command=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

      first_iteration=true
      while IFS="" read -r argument; do
         # Skip program name
         if $first_iteration; then
            first_iteration=false
            continue
         fi

         if [[ "$argument" =~ ^umid=.*$ ]]; then
            umid=${argument#*=}

            if [ "$umid" = "$name" ]; then
               vm_pids+=( "$pid" )
            fi

            break
         fi
      done <<< "$full_command"
   done

   echo "${vm_pids[*]}"

   [ "${#vm_pids[@]}" -gt 0 ] && return 0 || return 1
}


###############################################################################
# Fill the vm_info and vm_uml_sockets global arrays with information about a
# running virtual machine.
# Usage:
#   get_vm_info_by_pid PID
# Globals:
#   rw vm_info
#   rw vm_uml_sockets
# Arguments:
#   $1 - process ID of the machine
# Returns:
#   None
# Example:
#   None
###############################################################################
get_vm_info_by_pid() {
   local argument first_iteration key n pid uml_socket value

   pid=$1

   # Unset the globals incase the
   unset vm_info
   unset vm_uml_sockets

   declare -A vm_info

   vm_info["pid"]=$pid

   # Effective user ID of the process (full username if not too long)
   vm_info["owner"]=$(ps --no-headers --format euser --pid "$pid")

   # Total virtual memory usage of the process.
   # Logically this should be the sum of every process in the group (PGID),
   # however in practice just taking the value of the parent process is enough.
   # The value should equate to roughly the size of the machine's memory.
   vm_info["memory_usage"]=$(ps --no-headers --format vsize --pid "$pid")

   # Full command used to invoke the process.
   # Why not parse the output of ps? Whitespace in the program name or
   # arguments is impossible to deal with. /proc/$pid/cmdline stores argv with
   # null-byte field separators, which is the only character that cannot be
   # present in a Linux filepath. This will still break if a newline is present
   # in the command, but if a user is doing that then they are just asking for
   # an error somewhere down the line to be honest.
   vm_info["full_command"]=$(xargs -0 printf "%s\n" < "/proc/$pid/cmdline")

   first_iteration=true
   while IFS="" read -r argument; do
      if $first_iteration; then
         vm_info["kernel"]=$argument
         first_iteration=false
         continue
      fi

      # As per the manual, UML options are key=value pairs.
      # ${argument#*=} removes the key= prefix from argument (the single #
      # permits usage of further equals signs in the argument).

      # Edge-cases that can only be matched with regular expressions (or with
      # extglob enabled, which cannot be done.)
      if [[ "$argument" =~ ^eth[0-9]+=.*$ ]]; then
         key=${argument%%=*}
         value=${argument#*=}

         # Interface number
         n=${key#eth}

         # UML socket filepath (assuming transport mode is daemon)
         uml_socket=${value#daemon,,,*}

         # Array of UML sockets indexed by the interface number.
         # Disable SC2034 check (unused variable) - it is used eslewhere.
         # shellcheck disable=SC2034
         vm_uml_sockets[$n]=$uml_socket
         continue
      fi

      # Most of the command-line options can be matched with basic pattern
      # matching:
      case "$argument" in
         con0=* )
            value=${argument#*=}
            case "$value" in
               xterm)      vm_info["con0"]=$value;;
               fd:0,fd:1)  vm_info["con0"]="this";;
               pty)        vm_info["con0"]=$value;;
               port:*)     vm_info["con0"]=$value;;
               null)       vm_info["con0"]="none";;
            esac
            ;;
         con1=*)
            value=${argument#*=}
            case "$value" in
               xterm)      vm_info["con1"]=$value;;
               fd:0,fd:1)  vm_info["con1"]="this";;
               pty)        vm_info["con1"]=$value;;
               port:*)     vm_info["con1"]=$value;;
               null)       vm_info["con1"]="none";;
            esac
            ;;
         exec=*)     vm_info["boot_cmd"]=${argument#*=};;
         hosthome=*) vm_info["hosthome"]=${argument#*=};;
         hostlab=*)  vm_info["hostlab"]=${argument#*=};;
         hostwd=*)   vm_info["hostwd"]=${argument#*=};;
         # Memory is NOT adjusted by the skew here
         mem=*)      vm_info["mem"]=${argument#*=};;
         modules=*)  vm_info["modules"]=${argument#*=};;
         name=*)     vm_info["name"]=${argument#*=};;
         title=*)    vm_info["title"]=${argument#*=};;
         udb0=*)
            value=${argument#*=}

            # The udb0 value is disk,fs or fs
            vm_info["disk"]=${value%%,*}
            vm_info["fs"]=${value#*,}

            # The parameter expansions result in equal values if a single,
            # shared filesystem is used.
            [ "${vm_info["disk"]}" = "${vm_info["fs"]}" ] && unset vm_info["disk"]
            ;;
         umid=*)     vm_info["umid"]=${argument#*=};;
         *)          vm_info["other"]="${vm_info["$other"]} $argument"
      esac
   done <<< "${vm_info["full_command"]}"

   # The UML console socket filepath
   vm_info["mconsole"]=$MCONSOLE_DIR/${vm_info["umid"]}/mconsole
}


###############################################################################
# Fill the vm_info and vm_uml_sockets global arrays with information about a
# running virtual machine by machine name and, optionally, user.
# Usage:
#   get_vm_info_by_name USER VM
# Globals:
#   rw vm_info
#   rw vm_uml_sockets
# Arguments:
#   $1 - owner of the machine; pass an empty string for all users
#   $2 - machine name
# Returns:
#   0 on success, non-zero on failure
# Example:
#   None
###############################################################################
get_vm_info_by_name() {
   user=$1
   vm=$2

   if ! pid=$(get_vm_pid_by_name "$user" "$vm"); then
      return 1
   fi

   get_vm_info_by_pid "$pid"
   return 0
}
