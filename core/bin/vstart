#!/bin/bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vstart script, which is used to start virtual machines with
# given parameters.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not properly set;"
   echo 1>&2 "please set it as described in the Netkit documentation and try again."
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


# This function is used to print the vstart usage
help() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE"
   cat << END_OF_HELP
Start MACHINE with a given configuration.

You can use the following options to adjust the virtual machine parameters:
      --ethN=DOMAIN     Equip machine with a network interface ethN, where N is
                        a number between 0 and $((MAX_INTERFACES - 1)).
                        It will be connected to the DOMAIN collision domain
                        (network segment).
                        The special domain 'tap' is reserved: when connected to
                        it, an external network can be reached through this
                        interface. A 'tap' interface is declared as follows:
                        --ethN=tap,TAP_ADDRESS,GUEST_ADDRESS
                        where TAP_ADDRESS is the IP address of the host side
                        of the interface and GUEST_ADDRESS is the IP address of
                        the interface inside the virtual machine. TAP_ADDRESS
                        and GUEST_ADDRESS must be on the same subnetwork which,
                        in turn, must not exist on your host network.
                        Note:
                        - Using 'tap' domains performs host-side operations
                          with administrative privileges. The script will take
                          care of asking you for the root password if and when
                          required.
                        - TAP_ADDRESS is mandatory, but is only taken into
                          account when a 'tap' collision domain is first used.
                          The script only uses one 'tap' collision domain for
                          each user on the host machine.
                        - Host-side configurations are not automatically
                          removed when halting machines: you should use the
                          vclean script instead.
                        Please read the Netkit-JH documentation before using
                        'tap' collision domains.
  -k, --kernel=FILENAME Use FILENAME as the UML kernel for the virtual machine.
                        Default kernel is:
                        $VM_KERNEL
  -M, --mem=MEM         Give the virtual machine MEM MB of RAM. Allowed values
                        span from $MIN_MEM MB to $MAX_MEM MB, defaulting to $VM_MEMORY MB.

Filesystem settings can be tuned by using the following options:
  -H, --no-hosthome         Do not mount host filesystem inside the machine.
  -m, --model-fs=FILENAME   Use the specified filesystem image as a model for
                            the virtual machine. FILENAME will not be altered
                            in any way unless the --no-cow option is used.
                            Default model filesystem is:
                            $VM_MODEL_FS
  -f, --filesystem=FILENAME Use FILENAME as a filesystem for the machine. By
                            default, MACHINE.disk is used. Do not use this in
                            conjunction with --no-cow.
  -D, --hide-disk-file      Hide the virtual machine filesystem (.disk file).
                            The virtual machine will continue to operate
                            normally. Do not use this in conjunction with
                            --no-cow.
  -W, --no-cow              Avoid using copy-on-write (COW); every change to
                            the virtual machine filesystem is applied directly
                            to the model filesystem.

Console settings can be altered by the following options:
      --con0=MODE
      --con1=MODE       Attach the virtual machine primary (con0) and secondary
                        (con1) consoles to different devices or terminal
                        emulators.
                        Allowed values for MODE are:
                          xterm      attach to a terminal emulator application
                          this       attach to stdin/stdout, i.e., use current
                                     terminal; only one console at a time can
                                     be set to 'this'.
                          pty        attach to a pseudo-terminal
                          port:N     attach to TCP port N
                          none       disable console
                        Default mode for con0 is ${VM_CON0}.
                        Default mode for con1 is ${VM_CON1}.
      --xterm=TYPE      Specify the terminal emulator application. The
                        following values are supported:
                          alacritty    use the lightweight Alacritty terminal
                          gnome        use xtermGNOME Terminal
                          kitty        use the lightweight Kitty terminal
                          konsole      use the KDE Konsole
                          konsole-tab  same as above, but different virtual
                                       machines are opened in different Konsole
                                       tabs of the same window
                          wsl          use Windows Subsystem for Linux (WSL) in
                                       a conhost.exe window
                          wt           use Windows Subsystem for Linux (WSL) in
                                       a Windows Terminal window
                          xterm        use the standard xterm (default)
                          

If wanting to set up a lab, the following options are relevant:
  -e, --exec=FILENAME   Run a specified command or script inside the virtual
                        machine during the boot phase.
  -l, --hostlab=DIR     Tell the virtual machine that the base directory for a
                        Netkit-JH laboratory is DIR.
  -w, --hostwd=DIR      Set the lab working directory to DIR.

Miscellaneous options:
      --append=PARAM    Append additional kernel command line parameters when
                        running the virtual machine kernel; PARAM can also be
                        an OPTION=VALUE pair. This option can be used multiple
                        times. Parameters will be passed to the kernel in the
                        same order in which they are provided.
      --debug           Run the virtual machine under a GDB instance to report
                        more messages than with --verbose, and for further
                        debugging. The process requires a SIGINT delivery with
                        kill -INT <pid> to start debugging (if the session
                        booted successfully.)
  -F, --foreground      Do not launch the virtual machine in background (the
                        latter being the default behavior). Note that virtual
                        hubs are always started in background, regardless of
                        this option. This is the default when using 'this' as
                        the console mode.
  --tmux-attached       Run each VM in tmux and start a terminal attached to
                        the tmux session. This is equivalent to VM_CON0=tmux
                        and TMUX_OPEN_TERMS=yes in netkit.conf.
  --tmux-detached       Run each VM in a tmux session without opening
                        terminals. This is the same as VM_CON0=tmux and
                        TMUX_OPEN_TERMS=no in netkit.conf.
  -h, --help            Show this help.
  -p, --print           Do not start anything, just show which commands would
                        be executed.
  -q, --quiet           Quiet mode (suppress any output except errors and
                        warnings).
  -v, --verbose         Tell the virtual machine kernel to report verbose
                        messages during boot.
      --version         Print version information and exit.

Note: unless otherwise stated, whitespace is not permitted in any option
argument. It is also prohibited in filepaths, including the path to the current
directory at the time vstart is invoked.
END_OF_HELP
}


# Output vhalt's usage to stderr
# Usage: usage
usage() {
   echo 1>&2 "Usage: $SCRIPTNAME [OPTION]... MACHINE"
   echo 1>&2 "Try '$SCRIPTNAME --help' for more information."
}


# Get command line options
LONG_OPTS="append:,con0:,con1:,debug,exec:,filesystem:,foreground,help,hide-disk-file,hostlab:,hostwd:,kernel:,mem:,model-fs:,no-cow,no-hosthome,print,quiet,test,tmux-attached,tmux-detached,verbose,version,xterm:"
SHORT_OPTS="De:Ff:Hhk:Ll:M:m:pqvWw:"

for i in $(seq 0 $MAX_INTERFACES); do
   LONG_OPTS="$LONG_OPTS,eth$i:"
done

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage
   exit 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      --append)
         ADDITIONAL_ARG="$2"
         shift

         checkSpaces "$ADDITIONAL_ARG"
         KERNEL_APPEND="$KERNEL_APPEND $ADDITIONAL_ARG"
         ;;
      --con0|--con1)
         CON="$2"
         shift

         case "$CON" in
            xterm|this|pty|port:*|none)
               checkSpaces "$CON"
               [ "$1" = "--con0" ] && VM_CON0="$CON" || VM_CON1="$CON"
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: $CON: Unrecognized console"
               exit 1
               ;;
         esac
         ;;
      -D|--hide-disk-file)
         REMOVE_FS=1
         ;;
      --debug)
         DEBUG=1
         ;;
      -e|--exec)
         VM_EXEC="$2"
         shift
         ;;
      --eth*)
         OPT="$1"
         DOMAIN="$2"
         shift

         if containsRegexp DOMAIN "_"; then
            echo 1>&2 "$SCRIPTNAME: $DOMAIN: Invalid collision domain - underscores are not allowed"
            exit 1
         fi

         if containsRegexp DOMAIN "," || containsRegexp DOMAIN "\\."; then
            # If not a tap specification, but its name contains a comma
            if [ "${DOMAIN#tap,}" = "$DOMAIN" ]; then
               echo 1>&2 "$SCRIPTNAME: $DOMAIN: Invalid collision domain - commas and periods are only valid for tap interface specification"
               exit 1
            fi
         fi

         checkSpaces "$DOMAIN"
         ETH_INTERFACES="$ETH_INTERFACES ${OPT#--}=$DOMAIN"
         ;;
      -F|--foreground)
         RUN_IN_FOREGROUND=1
         ;;
      -f|--filesystem)
         VM_FS="$2"
         shift

         if containsRegexp CURRENT_ARGUMENT ","; then
            echo 1>&2 "$SCRIPTNAME: $VM_FS: Invalid filesystem - commas are not allowed"
            exit 1
         fi

         checkSpaces "$VM_FS"
         VM_FS=$(makeAbsolutePath "$VM_FS")
         ;;
      -H|--no-hosthome)
         NO_HOSTHOME=1
         ;;
      -h|--help)
         help
         exit 0
         ;;
      -k|--kernel)
         VM_KERNEL="$2"
         shift

         checkSpaces "$VM_KERNEL"
         VM_KERNEL=$(makeAbsolutePath "$VM_KERNEL")
         ;;
      -l|--hostlab)
         VM_HOSTLAB="$2"
         shift
         checkSpaces "$VM_HOSTLAB"
         ;;
      -M|--mem)
         VM_MEMORY="$2"
         shift

         if [ "$VM_MEMORY" -lt "$MIN_MEM" ] || [ "$VM_MEMORY" -gt "$MAX_MEM" ]; then
            echo 1>&2 "$SCRIPTNAME: Memory out of permitted range (min: $MIN_MEM MB; max: $MAX_MEM MB)"
            exit 1
         fi
         ;;
      -m|--model-fs)
         VM_MODEL_FS="$2"
         shift

         if containsRegexp VM_MODEL_FS ","; then
            echo 1>&2 "$SCRIPTNAME: $VM_MODEL_FS: Invalid filesystem - commas are not allowed"
            exit 1
         fi

         checkSpaces "$VM_MODEL_FS"
         VM_MODEL_FS=$(makeAbsolutePath "$VM_MODEL_FS")
         ;;
      -p|--print)
         JUST_PRINT=1
         ;;
      -q|--quiet)
         BE_QUIET=1
         ;;
      --test)
         KERNEL_APPEND="$KERNEL_APPEND test"
         ;;
      --tmux-attached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=yes
         ;;
      --tmux-detached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=no
         ;;
      -v|--verbose)
         VERBOSE=1
         ;;
      --version)
         showVersion
         exit 0
         ;;
      -W|--no-cow)
         USE_MODEL_FS=1
         ;;
      -w|--hostwd)
         VM_HOSTWD="$2"
         shift
         checkSpaces "$VM_HOSTWD"
         ;;
      --xterm)
         TERM_TYPE="$2"
         shift

         case "$TERM_TYPE" in
            konsole|konsole-tab|gnome|xterm|alacritty|kitty|wsl|wt)
               checkSpaces "$TERM_TYPE"
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: $TERM_TYPE: Unsupported terminal emulator"
               exit 1
               ;;
         esac
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage
         exit 1
         ;;
   esac

   shift
done

# Parse virtual machine name
if [ $# -eq 1 ]; then
   VM_NAME=$1
   checkSpaces "$VM_NAME"
   shift
elif [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage
   exit 1
else
   echo 1>&2 "$SCRIPTNAME: Too many machine names"
   usage
   exit 1
fi


# Check whether user is trying to attach more than one console to stdin/stdout
if [ "$VM_CON0" = "this" ] && [ "$VM_CON1" = "this" ]; then
   echo 1>&2 "$SCRIPTNAME: Only one console can be attached to the current terminal"
   exit 1
fi

# Check whether a COW filesystem has been explictly provided when using the --no-cow option
if [ -n "$USE_MODEL_FS" ] && [ -n "$VM_FS" ]; then
   echo 1>&2 "$SCRIPTNAME: Cannot provide a filesystem name with --no-cow"
   exit 1
fi   

# Check whether the user asked to hide the virtual machine filesystem while using the --no-cow option
if [ -n "$REMOVE_FS" ] && [ -n "$USE_MODEL_FS" ]; then
   echo 1>&2 "$SCRIPTNAME: Cannot hide the filesystem when using --no-cow"
   exit 1
fi

# Check whether the path to the current directory contains spaces
if containsRegexp PWD " "; then
   echo 1>&2 "$SCRIPTNAME: Current working directory path contains spaces"
   exit 1
fi

# Check whether the requested terminal emulator application exists
if [ "$VM_CON0" = "tmux" ] && [ "$TMUX_OPEN_TERMS" = "yes" ] || [ "$VM_CON0" = "xterm" ] || [ "$VM_CON1" = "xterm" ]; then
   # Some xterm option arguments are not their relevant executable's name. We
   # hence map these edge cases here.
   case "$TERM_TYPE" in
      gnome)         TERM_EXE="gnome-terminal";;
      konsole-tab)   TERM_EXE="konsole";;
      wsl)           TERM_EXE="wsl.exe";;
      wt)            TERM_EXE="wt.exe";;
      *)             TERM_EXE=$TERM_TYPE;;
   esac

   if ! command -v "$TERM_EXE" > /dev/null 2>&1; then
      echo 1>&2 "$SCRIPTNAME: $TERM_EXE: Terminal emulator not found"
      exit 1
   fi
fi


# This function prepares network interfaces for use.
setup_interfaces() {
   local device hub_name hub_socket tap_address
   local guest_address enabled_default_route used_devices
   
   first_iteration=true
   while [ $# -gt 0 ]; do
      device=${1%%=*}
      hub_name=${1#*=}

      # Check if interface has already been configured
      if [[ " $used_devices " == *" $device "* ]]; then
         echo 1>&2 "$SCRIPTNAME: $device: Duplicate interface"
         exit 1
      fi

      # Remember that this network interface has been configured
      used_devices="$used_devices $device"

      # Check if tap interface (regular hubs cannot be named with commas)
      if [[ "$hub_name" == tap,* ]]; then
         # Format: tap,tap_address,guest_address
         IFS=, read -r hub_name tap_address guest_address <<< "$hub_name"

         if ! is_inet_addr "$tap_address"; then
            echo 1>&2 "$SCRIPTNAME: $tap_address: Invalid tap address"
            exit 1
         fi

         if ! is_inet_addr "$guest_address"; then
            echo 1>&2 "$SCRIPTNAME: $guest_address: Invalid guest address"
            exit 1
         fi
      else
         # This is a normal (i.e., not 'tap') collision domain
         unset tap_address guest_address
      fi
      
      hub_socket="$HUB_SOCKET_DIR/${HUB_SOCKET_PREFIX}_${USERID}_$hub_name$HUB_SOCKET_EXTENSION"

      KERNELCMD="$KERNELCMD $device=daemon,,,$hub_socket"
      
      if [ -n "$tap_address" ]; then
         HUBLIST+=( "$hub_socket,$tap_address,$guest_address" )

         KERNELCMD="$KERNELCMD autoconf_$device=$guest_address"

         # Ensure the default route is specified only once
         if [ -z "$enabled_default_route" ]; then
            KERNELCMD="$KERNELCMD def_route=$tap_address"
            enabled_default_route=1
         fi
      else
         HUBLIST+=( "$hub_socket" )
      fi

      if $first_iteration; then
         first_iteration=false
      elif [ -z "$BE_QUIET" ]; then
         echo -n "               "
      fi

      [ -z "$BE_QUIET" ] && echo "$device @ $hub_name ($hub_socket)"

      shift
   done
}



################## Building kernel command line ##################

: "${VM_FS:="$PWD/$VM_NAME.disk"}"
KERNELCMD="$VM_KERNEL"

check_filesystem() {
   FS=$1

   FS_TYPE=$(stat -f "$FS" | grep -w Type)
   FS_TYPE=${FS_TYPE#*Type: }

   if echo "$FS_TYPE" | grep -vqE "(ext[2,3,4])|(ntfs)|(ntfs-3g)|(fuse)|(reiser)|(jfs)|(xfs)"; then
      echo 1>&2 "$SCRIPTNAME: Filesystem '$FS_TYPE' does not seem to support sparse files, this may result in performance loss and disk space consumption"
   fi
}

# Check if model fs or cow fs are on a filesystem supporting sparse files
if [ -z "$USE_MODEL_FS" ]; then
   check_filesystem "$VM_MODEL_FS"
else
   check_filesystem "$VM_FS"
fi

if [ -z "$BE_QUIET" ]; then
   echo "============= Starting virtual machine '$VM_NAME' ============="
   echo "   Kernel:     $VM_KERNEL"
fi


##### Setup kernel modules directory
KERNEL_MODULES_DIRECTORY=$(dirname "$VM_KERNEL")/modules

if [ -d "$KERNEL_MODULES_DIRECTORY" ]; then
   [ -z "$BE_QUIET" ] && echo "   Modules:    $KERNEL_MODULES_DIRECTORY"
   KERNELCMD="$KERNELCMD modules=$KERNEL_MODULES_DIRECTORY"
fi


##### Set virtual machine name
KERNELCMD="$KERNELCMD name=$VM_NAME title=$VM_NAME umid=$VM_NAME"


##### Set memory amount
[ -z "$BE_QUIET" ] && echo "   Memory:     $VM_MEMORY MB"
VM_MEMORY=$((VM_MEMORY + VM_MEMORY_SKEW))
KERNELCMD="$KERNELCMD mem=${VM_MEMORY}M"


##### Filesystem settings
[ -z "$BE_QUIET" ] && echo "   Model fs:   $VM_MODEL_FS"

if [ -n "$USE_MODEL_FS" ]; then
   [ -z "$BE_QUIET" ] && echo "   Filesystem: using model fs (no COW)"

   # Use model fs as virtual machine filesystem (do not use COW)
   KERNELCMD="$KERNELCMD ubd0=$VM_MODEL_FS"

   VM_FS="$VM_MODEL_FS"
else
   [ -z "$BE_QUIET" ] && echo -n "   Filesystem: $VM_FS"

   # Explicitly declaring the model fs name is redundant after the COW file has
   # been created. Nevertheless, this is needed in order to later get
   # information about the virtual machine (i.e., by using vlist).
   KERNELCMD="$KERNELCMD ubd0=${VM_FS},${VM_MODEL_FS}"

   [ -z "$BE_QUIET" ] && [ ! -f "$VM_FS" ] && echo " (new)" || echo
fi

# Append a boot option that specifies the root filesystem
KERNELCMD="$KERNELCMD root=98:0"

# The following root= options should also be valid
# KERNELCMD="$KERNELCMD root=/dev/ubd/disc0/part1"
# KERNELCMD="$KERNELCMD root=/dev/ubda1"


##### Setup mconsole directory
KERNELCMD="$KERNELCMD uml_dir=$MCONSOLE_DIR"


##### Setup network interfaces
if [ -n "$ETH_INTERFACES" ]; then
   [ -z "$BE_QUIET" ] && echo -n "   Interfaces: "
   setup_interfaces $ETH_INTERFACES
fi

##### Set HOSTHOME
if [ -z "$NO_HOSTHOME" ]; then
   [ -z "$BE_QUIET" ] && echo "   Hostfs at:  $HOME"
   KERNELCMD="$KERNELCMD hosthome=$HOME"
fi


##### Check whether virtual machine already exists
if [ -z "$JUST_PRINT" ] && get_machine_state "$USERID" "$VM_NAME"; then
   echo 1>&2 "$SCRIPTNAME: Virtual machine '$VM_NAME' is already running. Please halt it before starting a new one or use a different virtual machine name"
   exit 1
fi


##### Check whether filesystem is already in use
if [ -z "$JUST_PRINT" ] && file_in_use "$VM_FS"; then
   echo 1>&2 "$SCRIPTNAME: Filesystem '$VM_FS' is already in use. Please use a different filesystem or virtual machine name"
   exit 1
fi


##### Append exec, hostlab and hostwd parameters, if any
if [ -n "$VM_EXEC" ]; then
   [ -z "$BE_QUIET" ] && echo "   Boot cmd:   '$VM_EXEC'"
   KERNELCMD="$KERNELCMD exec=\"$VM_EXEC\""
fi

if [ -n "$VM_HOSTLAB" ]; then
   [ -z "$BE_QUIET" ] && echo "   Hostlab at: $VM_HOSTLAB"
   KERNELCMD="$KERNELCMD hostlab=$VM_HOSTLAB"
fi

if [ -n "$VM_HOSTWD" ]; then
   [ -z "$BE_QUIET" ] && echo "   Host WD at: $VM_HOSTWD"
   KERNELCMD="$KERNELCMD hostwd=$VM_HOSTWD"
fi


##### Set verbosity parameter (is 'verbose' by default)
if [ -n "$DEBUG" ]; then
   KERNELCMD="gdb --args $KERNELCMD"
elif [ -z "$VERBOSE" ]; then
   KERNELCMD="$KERNELCMD quiet"
fi

##### Bypass port helper, if required (only allowed for the primary terminal)
if [ $VM_CON0 = "xterm" ] && [ "$CON0_PORTHELPER" != "yes" ]; then
   VM_CON0="this_noporthelper"
fi

##### Attach terminals
case $VM_CON0 in
   none)                      KERNELCMD="$KERNELCMD con0=null";;
   xterm)                     KERNELCMD="$KERNELCMD con0=xterm";;
   this|this_noporthelper)    KERNELCMD="$KERNELCMD con0=fd:0,fd:1";;
   pty)                       KERNELCMD="$KERNELCMD con0=pty";;
   port:*)                    KERNELCMD="$KERNELCMD con0=$VM_CON0";;
esac

case $VM_CON1 in
   none)    KERNELCMD="$KERNELCMD con1=null";;
   xterm)   KERNELCMD="$KERNELCMD con1=xterm";;
   this)    KERNELCMD="$KERNELCMD con1=fd:0,fd:1";;
   pty)     KERNELCMD="$KERNELCMD con1=pty";;
   port:*)  KERNELCMD="$KERNELCMD con1=$VM_CON1";;
esac



##### Disable SELinux
KERNELCMD="$KERNELCMD SELINUX_INIT=0"


##### Setup a proper terminal emulator
case $TERM_TYPE in
   gnome)         KERNELCMD="$KERNELCMD xterm=gnome-terminal,-t,-x";;
   konsole)       KERNELCMD="$KERNELCMD xterm=konsole,-T,-e";;
   konsole-tab)   KERNELCMD="$KERNELCMD xterm=$NETKIT_HOME/bin/konsole-tabs.sh,-T,-e";;
esac

##### Append any other user provided parameters
if [ -n "$KERNEL_APPEND" ]; then
   [ -z "$BE_QUIET" ] && echo "   Other args: $KERNEL_APPEND"
   KERNELCMD="$KERNELCMD $KERNEL_APPEND"
fi

[ -z "$BE_QUIET" ] && echo

# Add our blocking script to the execution order
if [ "$VM_CON0" = "xterm" ] || [ "$VM_CON0" = "this_noporthelper" ]; then
    KERNELCMD="$NETKIT_HOME/bin/block-wrapper $TERM_TYPE $VM_NAME $KERNELCMD"
fi

# Set up tmux
if [ "$VM_CON0" = "tmux" ]; then
   if ! command -v "tmux" > /dev/null 2>&1; then
      echo 1>&2 "$SCRIPTNAME: tmux could not be found"
      exit 1
   fi
   
   KERNELCMD="$NETKIT_HOME/bin/block-wrapper tmux $VM_NAME $KERNELCMD"
fi

##### Actually start network hubs
eval runHubs "${HUBLIST[@]}"

##### Prepare the cleanHubs function for execution after a virtual machine stops
export cleanHubs

#### Start machine in background unless otherwise requested
if [ -z "$RUN_IN_FOREGROUND" ] && [ "$VM_CON0" != "this" ] && [ "$VM_CON1" != "this" ]; then
   BACKGROUND="&"
fi

### Invocation of uml_mconsole is needed in order to "wake up" port-helper if
### it ever hangs when booting the virtual machine.
if [ "$CON0_PORTHELPER" = "yes" ]; then
   WAKEUP_PORTHELPER="{ sleep 5; $NETKIT_HOME/bin/uml_mconsole $VM_NAME help > /dev/null 2>&1; } &"
fi

### Remove .disk file, if requested
if [ -n "$REMOVE_FS" ]; then
   REMOVE_FS_COMMAND="{ while [ ! -f $VM_FS ]; do sleep 1; done; rm -f $VM_FS; } &"
fi

### Completely hide primary console, if requested to
if [ "$VM_CON0" = "none" ]; then
   REDIRECT_CONSOLE="> /dev/null 2>&1"
fi

run_command "$JUST_PRINT" "$KERNELCMD" "{ $WAKEUP_PORTHELPER $REMOVE_FS_COMMAND $KERNELCMD; cleanHubs ${HUBLIST[*]}; } $REDIRECT_CONSOLE $BACKGROUND"

# Connect to the tmux session if TMUX_OPEN_TERMS is set
if [ "$TMUX_OPEN_TERMS" = "yes" ] && [ "$VM_CON0" = "tmux" ]; then
    vconnect -m "$VM_NAME" --terminal --interval 5 --retry-count 20 &> /dev/null &
fi
