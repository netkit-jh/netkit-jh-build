#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vstart script, which is used to start virtual machines with
# given parameters.


###############################################################################
# Write vstart's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE"
}


###############################################################################
# Write vstart's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Start MACHINE with a given configuration.

You can use the following options to adjust the virtual machine parameters:
      --ethN=DOMAIN   equip machine with a network interface ethN, where N is a
                        number between 0 and $((MAX_INTERFACES - 1)). It will be connected to the
                        DOMAIN collision domain (network segment). The special
                        domain 'tap' is reserved: when connected to it, an
                        external network can be reached through this interface.
                        A 'tap' interface is declared as follows:
                        --ethN=tap,TAP_ADDRESS,GUEST_ADDRESS
                        where TAP_ADDRESS is the IP address of the host side of
                        the interface and GUEST_ADDRESS is the IP address of
                        the interface inside the virtual machine. TAP_ADDRESS
                        and GUEST_ADDRESS must be on the same subnetwork which,
                        in turn, must not exist on your host network.
                        Note:
                        - Using 'tap' domains performs host-side operations
                           with administrative privileges. The script will take
                           care of asking you for the root password if and when
                           required.
                        - TAP_ADDRESS is mandatory, but is only taken into
                           account when a 'tap' collision domain is first used.
                           The script only uses one 'tap' collision domain for
                           each user on the host machine.
                        - Host-side configurations are not automatically
                           removed when halting machines: you should use the
                           vclean script instead.
  -k, --kernel=FILENAME  use FILENAME as the UML kernel for the virtual
                          machine. The default kernel is:
                          $VM_KERNEL
  -M, --mem=MEM       give the virtual machine MEM MB of RAM. Allowed values
                        span from $MIN_MEM MB to $MAX_MEM MB, defaulting to $VM_MEMORY MB

Filesystem settings can be tuned by using the following options:
  -H, --no-hosthome   do not mount host filesystem inside the machine
  -m, --model-fs=FILENAME  use the specified filesystem image as a model for
                            the virtual machine. FILENAME will not be altered
                            in any way unless the --no-cow option is used. The
                            default model filesystem is:
                            $VM_MODEL_FS
  -f, --filesystem=FILENAME  use FILENAME as a filesystem for the machine. By
                              default, MACHINE.disk is used. Do not use this in
                              conjunction with --no-cow
  -D, --hide-disk-file  hide the virtual machine filesystem (.disk file). The
                         virtual machine will continue to operate normally. Do
                         not use this in conjunction with --no-cow
  -W, --no-cow        avoid using copy-on-write (COW); every change to the
                        virtual machine filesystem is applied directly to the
                        model filesystem

Console settings can be altered by the following options:
      --con0=MODE
      --con1=MODE     attach the virtual machine primary (con0) and secondary
                        (con1) consoles to different devices or terminal
                        emulators.
                        Allowed values for MODE are:
                          xterm   attach to a terminal emulator application
                          this    attach to stdin/stdout, i.e., use current
                                   terminal; only one console at a time can be
                                   set to 'this'.
                          pty     attach to a pseudo-terminal
                          port:N  attach to TCP port N
                          none    disable console
                        The default modes for con0 and con1, respectively, are
                        ${VM_CON0} and ${VM_CON1}
      --xterm=TYPE    specify the terminal emulator application. The following
                        values are supported:
                          alacritty    use the lightweight Alacritty terminal
                          gnome        use xtermGNOME Terminal
                          kitty        use the lightweight Kitty terminal
                          konsole      use the KDE Konsole
                          konsole-tab  same as above, but different virtual
                                        machines are opened in different
                                        Konsole tabs of the same window
                          wsl          use Windows Subsystem for Linux (WSL) in
                                        a conhost.exe window
                          wt           use Windows Subsystem for Linux (WSL) in
                                        a Windows Terminal window
                          xterm        use the standard xterm (default)

If wanting to set up a lab, the following options are relevant:
  -e, --exec=FILENAME  run a specified command or script inside the virtual
                        machine during the boot phase
  -l, --hostlab=DIR   tell the virtual machine that the base directory for a
                        Netkit-JH laboratory is DIR
  -w, --hostwd=DIR    set the lab working directory to DIR

Miscellaneous:
$(help_option)
      --append=PARAM  append additional kernel command line parameters when
                        running the virtual machine kernel; PARAM can also be
                        an OPTION=VALUE pair. This option can be used multiple
                        times. Parameters will be passed to the kernel in the
                        same order in which they are provided
      --debug         run the virtual machine under a GDB instance to report
                        more messages than with --verbose, and for further
                        debugging. The process requires a SIGINT delivery with
                        kill -INT <pid> to start debugging (if the session
                        booted successfully)
  -F, --foreground    do not launch the virtual machine in background (the
                        latter being the default behavior). Note that virtual
                        hubs are always started in background, regardless of
                        this option. This is the default when using 'this' as
                        the console mode
  -p, --print         do not start anything, just show which commands would be
                        executed
  -q, --quiet         quiet mode (suppress any output except errors and
                        warnings)
  --tmux-attached     run each VM in tmux and start a terminal attached to the
                        tmux session. This is equivalent to VM_CON0=tmux and
                        TMUX_OPEN_TERMS=yes in netkit.conf
  --tmux-detached     run each VM in a tmux session without opening terminals.
                        This is the same as VM_CON0=tmux and TMUX_OPEN_TERMS=no
                        in netkit.conf
  -v, --verbose       show debugging messages during the boot sequence
$(version_option)

Note: unless otherwise stated, whitespace is not permitted in any option
argument. It is also prohibited in filepaths, including the path to the current
directory at the time vstart is invoked.

END_OF_HELP

   exit "$status"
}


###############################################################################
# Warn if file is located on a filesystem that does not support sparse files.
# Usage:
#   check_filesystem FILE
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - file on target filesystem
# Returns:
#   None
# Example:
#   None
###############################################################################
check_filesystem() {
   file=$1

   fs_type=$(stat -f "$file" | grep -w Type)
   fs_type=${fs_type#*Type: }

   if [[ "$fs_type" =~ ^(ext[2-4]|ntfs|ntfs-3g|fuse|reiser|jfs|xfs)$ ]]; then
      echo 1>&2 "$SCRIPTNAME: Filesystem '$fs_type' does not seem to support sparse files, this may result in performance loss and disk space consumption"
   fi
}


###############################################################################
# Append network interface specifications to the kernel invocation command.
# Usage:
#   setup_interfaces [INTERFACE]...
# Globals:
#   r- BE_QUIET
#   -w HUBLIST
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- KERNELCMD
#   r- SCRIPTNAME
#   r- USER_ID
# Arguments:
#  ... - list of interfaces
# Returns:
#   None. Will exit with usage 1 on invalid specification.
# Example:
#   None
###############################################################################
setup_interfaces() {
   local device hub_name hub_socket tap_address
   local guest_address enabled_default_route used_devices
   
   first_iteration=true
   while [ $# -gt 0 ]; do
      device=${1%%=*}
      hub_specification=${1#*=}

      # Check if interface has already been configured
      if [[ " $used_devices " == *" $device "* ]]; then
         echo 1>&2 "$SCRIPTNAME: $device: Duplicate interface"
         usage 1
      fi

      # Remember that this network interface has been configured
      used_devices="$used_devices $device"

      # Check if tap interface (regular hubs cannot be named with commas)
      if [[ "$hub_specification" == tap,* ]]; then
         # Format: tap,tap_address,guest_address
         IFS=, read -r hub_name tap_address guest_address <<< "$hub_specification"

         if ! is_inet_addr "$tap_address"; then
            echo 1>&2 "$SCRIPTNAME: $tap_address: Invalid tap address"
            usage 1
         fi

         if ! is_inet_addr "$guest_address"; then
            echo 1>&2 "$SCRIPTNAME: $guest_address: Invalid guest address"
            usage 1
         fi
      else
         # This is a normal (i.e., not 'tap') collision domain
         unset tap_address guest_address
         hub_name=$hub_specification
      fi
      
      hub_socket="$HUB_SOCKET_DIR/${HUB_SOCKET_PREFIX}_${USER_ID}_$hub_name$HUB_SOCKET_EXTENSION"

      KERNELCMD="$KERNELCMD $device=daemon,,,$hub_socket"
      
      if [ -n "$tap_address" ]; then
         HUBLIST+=( "$hub_name,$tap_address" )

         KERNELCMD="$KERNELCMD autoconf_$device=$guest_address"

         # TODO: KERNELCMD is an array now
         # Ensure the default route is specified only once
         if [ -z "$enabled_default_route" ]; then
            KERNELCMD="$KERNELCMD def_route=$tap_address"
            enabled_default_route=1
         fi
      else
         HUBLIST+=( "$hub_name" )
      fi

      if $first_iteration; then
         first_iteration=false
      elif [ -z "$BE_QUIET" ]; then
         echo -n "               "
      fi

      [ -z "$BE_QUIET" ] && echo "$device @ $hub_name ($hub_socket)"

      shift
   done
}


###############################################################################
# Invoke uml_mconsole to "wake up" port-helper in the event that it hangs.
# Usage:
#   wakeup_porthelper
# Globals:
#   r- NETKIT_HOME
#   r- VM_NAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
wakeup_porthelper() {
   sleep 5
   "$NETKIT_HOME/bin/uml_mconsole" "$VM_NAME" help > /dev/null 2>&1 &
}


###############################################################################
# Delete .disk file as soon as it is created by the UML instance.
# Usage:
#   remove_fs_command
# Globals:
#   r- VM_FS
# Arguments:
#   None
# Returns:
#   None
# Example:
#   remove_fs_command &
###############################################################################
remove_fs_command() {
   while [ ! -f "$VM_FS" ]; do
      sleep 1
   done
   
   rm -f "$VM_FS" 
}


###############################################################################
# Run relevant kernel invocation setup functions and then invoke the UML kernel
# instance. Upon return, clean up redundant network hubs.
# Usage:
#   run_kernel_command
# Globals:
#   r- CON0_PORTHELPER
#   r- HUBLIST
#   r- JUST_PRINT
#   r- KERNELCMD
#   r- REMOVE_FS
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
run_kernel_command() {
   # If doing a dry run, we want to skip all four commands here.
   if [ -n "$JUST_PRINT" ]; then
      run_command "$JUST_PRINT" "${KERNELCMD[*]}" "${KERNELCMD[@]}"
      return
   fi

   # Invocation of uml_mconsole is needed in order to "wake up" port-helper if
   # it ever hangs when booting the virtual machine.
   [ "$CON0_PORTHELPER" = "yes" ] && wakeup_porthelper
   
   # Remove .disk file, if requested
   if [ -n "$REMOVE_FS" ]; then
      remove_fs_command &
   fi

   run_command "$JUST_PRINT" "${KERNELCMD[*]}" "${KERNELCMD[@]}"

   clean_hubs "${HUBLIST[@]}"
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


# Get command line options
long_opts="append:,con0:,con1:,debug,exec:,filesystem:,foreground,help,\
hide-disk-file,hostlab:,hostwd:,kernel:,mem:,model-fs:,no-cow,no-hosthome,\
print,quiet,test,tmux-attached,tmux-detached,verbose,version,xterm:"
short_opts="De:Ff:Hk:Ll:M:m:pqvWw:"

for i in $(seq 0 $MAX_INTERFACES); do
   long_opts="$long_opts,eth$i:"
done

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      --append)
         KERNEL_APPEND+=( "$2" )
         shift
         ;;
      --con0|--con1)
         OPT=$1
         CON=$2

         case $CON in
            xterm|this|pty|port:*|none)
               [ "$OPT" = "--con0" ] && VM_CON0=$CON || VM_CON1=$CON
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: $CON: Unrecognized console"
               usage 1
               ;;
         esac

         shift
         ;;
      -D|--hide-disk-file)
         REMOVE_FS=1
         ;;
      --debug)
         DEBUG=1
         ;;
      -e|--exec)
         VM_EXEC=$2
         shift
         ;;
      --eth*)
         OPT="$1"
         DOMAIN="$2"

         if string_contains "_" "$DOMAIN"; then
            echo 1>&2 "$SCRIPTNAME: $DOMAIN: Invalid collision domain - underscores are not allowed"
            usage 1
         fi

         if string_contains "," "$DOMAIN" || string_contains "." "$DOMAIN"; then
            # If not a tap specification, but its name contains a comma
            if [ "${DOMAIN#tap,}" = "$DOMAIN" ]; then
               echo 1>&2 "$SCRIPTNAME: $DOMAIN: Invalid collision domain - commas and periods are only valid for tap interface specification"
               usage 1
            fi
         fi

         # TODO: double-check checkSpaces and maybe change ETH_INTERFACES to
         # array.
         if string_contains " " "$DOMAIN"; then
            echo 1>&2 "$SCRIPTNAME: $DOMAIN: Collision domain name cannot contain whitespace"
            exit 1
         fi
         ETH_INTERFACES="$ETH_INTERFACES ${OPT#--}=$DOMAIN"
         shift
         ;;
      -F|--foreground)
         RUN_IN_FOREGROUND=1
         ;;
      -f|--filesystem)
         VM_FS=$2

         if string_contains "," "$VM_FS"; then
            echo 1>&2 "$SCRIPTNAME: $VM_FS: Invalid filesystem - commas are not allowed"
            usage 1
         fi

         # TODO: double-check udb0 argument allows spaces
         VM_FS=$(readlink --canonicalize-missing "$VM_FS")
         shift
         ;;
      -H|--no-hosthome)
         NO_HOSTHOME=1
         ;;
      --help)
         usage 0
         ;;
      -k|--kernel)
         VM_KERNEL=$(readlink --canonicalize-missing "$2")
         shift
         ;;
      -l|--hostlab)
         VM_HOSTLAB=$2
         shift
         ;;
      -M|--mem)
         VM_MEMORY=$2

         if [ "$VM_MEMORY" -lt "$MIN_MEM" ] || [ "$VM_MEMORY" -gt "$MAX_MEM" ]; then
            echo 1>&2 "$SCRIPTNAME: Memory out of permitted range (min: $MIN_MEM MB; max: $MAX_MEM MB)"
            usage 1
         fi

         shift
         ;;
      -m|--model-fs)
         VM_MODEL_FS=$2

         if string_contains "," "$VM_MODEL_FS"; then
            echo 1>&2 "$SCRIPTNAME: $VM_MODEL_FS: Invalid filesystem - commas are not allowed"
            usage 1
         fi

         # TODO: double-check udb0 can take spaces
         VM_MODEL_FS=$(readlink --canonicalize-missing "$VM_MODEL_FS")
         shift
         ;;
      -p|--print)
         JUST_PRINT=1
         ;;
      -q|--quiet)
         BE_QUIET=1
         ;;
      --test)
         KERNEL_APPEND+=( "test" )
         ;;
      --tmux-attached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=yes
         ;;
      --tmux-detached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=no
         ;;
      -v|--verbose)
         VERBOSE=1
         ;;
      --version)
         show_version
         exit 0
         ;;
      -W|--no-cow)
         USE_MODEL_FS=1
         ;;
      -w|--hostwd)
         VM_HOSTWD=$2
         shift
         ;;
      --xterm)
         TERM_TYPE=$2
         shift

         if [[ "$TERM_TYPE" =~ ^(konsole|konsole-tab|gnome|xterm|alacritty|kitty|wsl|wt)$ ]]; then
            echo 1>&2 "$SCRIPTNAME: $TERM_TYPE: Unsupported terminal emulator"
            usage 1
         fi
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Parse virtual machine name
if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
elif [ $# -gt 1 ]; then
   echo 1>&2 "$SCRIPTNAME: Can only specify one machine"
   usage 1
fi

VM_NAME=$1
shift

if string_contains " " "$VM_NAME"; then
   echo 1>&2 "$SCRIPTNAME: Hostname cannot contain whitespace"
   exit 1
fi


# Check whether user is trying to attach more than one console to stdin/stdout
if [ "$VM_CON0" = "this" ] && [ "$VM_CON1" = "this" ]; then
   echo 1>&2 "$SCRIPTNAME: Only one console can be attached to the current terminal"
   usage 1
fi

# Check whether a COW filesystem has been explictly provided when using the --no-cow option
if [ -n "$USE_MODEL_FS" ] && [ -n "$VM_FS" ]; then
   echo 1>&2 "$SCRIPTNAME: Cannot provide a filesystem name with --no-cow"
   usage 1
fi   

# Check whether the user asked to hide the virtual machine filesystem while using the --no-cow option
if [ -n "$REMOVE_FS" ] && [ -n "$USE_MODEL_FS" ]; then
   echo 1>&2 "$SCRIPTNAME: Cannot hide the filesystem when using --no-cow"
   usage 1
fi

# Check whether the path to the current directory contains spaces
if string_contains " " "$PWD"; then
   echo 1>&2 "$SCRIPTNAME: Current working directory path contains spaces"
   usage 1
fi

# Check whether the requested terminal emulator application exists
if [ "$VM_CON0" = "tmux" ] && [ "$TMUX_OPEN_TERMS" = "yes" ] || [ "$VM_CON0" = "xterm" ] || [ "$VM_CON1" = "xterm" ]; then
   # Some xterm option arguments are not their relevant executable's name. We
   # hence map these edge cases here.
   case $TERM_TYPE in
      gnome)         TERM_EXE="gnome-terminal";;
      konsole-tab)   TERM_EXE="konsole";;
      wsl)           TERM_EXE="wsl.exe";;
      wt)            TERM_EXE="wt.exe";;
      *)             TERM_EXE=$TERM_TYPE;;
   esac

   if ! command -v "$TERM_EXE" > /dev/null 2>&1; then
      echo 1>&2 "$SCRIPTNAME: $TERM_EXE: Terminal emulator not found"
      exit 1
   fi
fi


# Start building the kernel command line
KERNELCMD=( "$VM_KERNEL" )


# Check if model fs or cow fs are on a filesystem supporting sparse files
: "${VM_FS:="$PWD/$VM_NAME.disk"}"

if [ -z "$USE_MODEL_FS" ]; then
   check_filesystem "$VM_MODEL_FS"
else
   check_filesystem "$VM_FS"
fi

if [ -z "$BE_QUIET" ]; then
   echo "============= Starting virtual machine '$VM_NAME' ============="
   echo "   Kernel:     $VM_KERNEL"
fi


# Setup kernel modules directory
KERNEL_MODULES_DIRECTORY=$(dirname "$VM_KERNEL")/modules

if [ -d "$KERNEL_MODULES_DIRECTORY" ]; then
   [ -z "$BE_QUIET" ] && echo "   Modules:    $KERNEL_MODULES_DIRECTORY"
   KERNELCMD+=( "modules=$KERNEL_MODULES_DIRECTORY" )
fi


# Set virtual machine name
KERNELCMD+=( "name=$VM_NAME" "title=$VM_NAME" "umid=$VM_NAME" )


# Set memory amount
[ -z "$BE_QUIET" ] && echo "   Memory:     $VM_MEMORY MB"
VM_MEMORY=$((VM_MEMORY + VM_MEMORY_SKEW))
KERNELCMD+=( "mem=${VM_MEMORY}M" )


# Filesystem settings
[ -z "$BE_QUIET" ] && echo "   Model fs:   $VM_MODEL_FS"

if [ -n "$USE_MODEL_FS" ]; then
   [ -z "$BE_QUIET" ] && echo "   Filesystem: using model fs (no COW)"

   # Use model fs as virtual machine filesystem (do not use COW)
   KERNELCMD+=( "ubd0=$VM_MODEL_FS" )

   VM_FS=$VM_MODEL_FS
else
   [ -z "$BE_QUIET" ] && echo -n "   Filesystem: $VM_FS"

   # Explicitly declaring the model fs name is redundant after the COW file has
   # been created. Nevertheless, this is needed in order to later get
   # information about the virtual machine (i.e., by using vlist).
   KERNELCMD+=( "ubd0=$VM_FS,$VM_MODEL_FS" )

   [ -z "$BE_QUIET" ] && [ ! -f "$VM_FS" ] && echo " (new)" || echo
fi


# Append a boot option that specifies the root filesystem.
# NOTE: The following root= options should also be valid: /dev/ubda1 and
# /dev/ubd/disc0/part1.
KERNELCMD+=( "root=98:0" )


# Setup mconsole directory
KERNELCMD+=( "uml_dir=$MCONSOLE_DIR" )


# Setup network interfaces
if [ -n "$ETH_INTERFACES" ]; then
   [ -z "$BE_QUIET" ] && echo -n "   Interfaces: "
   # TODO: Fix SC2086
   setup_interfaces $ETH_INTERFACES
fi


# Set host home directory path
if [ -z "$NO_HOSTHOME" ]; then
   [ -z "$BE_QUIET" ] && echo "   Hostfs at:  $HOME"
   KERNELCMD+=( "hosthome=$HOME" )
fi


# Check whether the virtual machine already exists
if [ -z "$JUST_PRINT" ] && get_machine_state "$USER_ID" "$VM_NAME"; then
   echo 1>&2 "$SCRIPTNAME: Virtual machine '$VM_NAME' is already running. Please halt it before starting a new one or use a different virtual machine name"
   exit 1
fi


# Check whether filesystem is already in use
if [ -z "$JUST_PRINT" ] && file_in_use "$VM_FS"; then
   echo 1>&2 "$SCRIPTNAME: Filesystem '$VM_FS' is already in use. Please use a different filesystem or virtual machine name"
   exit 1
fi


# Append exec, hostlab and hostwd parameters, if any
if [ -n "$VM_EXEC" ]; then
   [ -z "$BE_QUIET" ] && echo "   Boot cmd:   '$VM_EXEC'"
   KERNELCMD+=( "exec=$VM_EXEC" )
fi

if [ -n "$VM_HOSTLAB" ]; then
   [ -z "$BE_QUIET" ] && echo "   Hostlab at: $VM_HOSTLAB"
   KERNELCMD+=( "hostlab=$VM_HOSTLAB" )
fi

if [ -n "$VM_HOSTWD" ]; then
   [ -z "$BE_QUIET" ] && echo "   Host WD at: $VM_HOSTWD"
   KERNELCMD+=( "hostwd=$VM_HOSTWD" )
fi


# Set verbosity parameter (is 'verbose' by default)
if [ -n "$DEBUG" ]; then
   KERNELCMD=( "gdb --args" "${KERNELCMD[@]}" )
elif [ -z "$VERBOSE" ]; then
   KERNELCMD+=( "quiet" )
fi


# Bypass port helper, if required (only allowed for the primary terminal)
if [ $VM_CON0 = "xterm" ] && [ "$CON0_PORTHELPER" != "yes" ]; then
   VM_CON0="this_noporthelper"
fi


# Attach terminals
case $VM_CON0 in
   none)                      KERNELCMD+=( "con0=null" );;
   xterm)                     KERNELCMD+=( "con0=xterm" );;
   this|this_noporthelper)    KERNELCMD+=( "con0=fd:0,fd:1" );;
   pty)                       KERNELCMD+=( "con0=pty" );;
   port:*)                    KERNELCMD+=( "con0=$VM_CON0" );;
esac

case $VM_CON1 in
   none)    KERNELCMD+=( "con1=null" );;
   xterm)   KERNELCMD+=( "con1=xterm" );;
   this)    KERNELCMD+=( "con1=fd:0,fd:1" );;
   pty)     KERNELCMD+=( "con1=pty" );;
   port:*)  KERNELCMD+=( "con1=$VM_CON1" );;
esac


# Disable SELinux
KERNELCMD+=( "SELINUX_INIT=0" )


# Setup a proper terminal emulator
case $TERM_TYPE in
   gnome)         KERNELCMD+=( "xterm=gnome-terminal,-t,-x" );;
   konsole)       KERNELCMD+=( "xterm=konsole,-T,-e" );;
   konsole-tab)   KERNELCMD+=( "xterm=$NETKIT_HOME/bin/konsole-tabs.sh,-T,-e" );;
esac


# Append any other user provided parameters
if [ ${#KERNEL_APPEND[@]} -gt 0 ]; then
   [ -z "$BE_QUIET" ] && echo "   Other args: ${KERNEL_APPEND[*]}"
   KERNELCMD+=( "${KERNEL_APPEND[@]}" )
fi


[ -z "$BE_QUIET" ] && echo


# Add our blocking script to the execution order
if [ "$VM_CON0" = "xterm" ] || [ "$VM_CON0" = "this_noporthelper" ]; then
   KERNELCMD=( "$NETKIT_HOME/bin/block-wrapper" "$TERM_TYPE" "$VM_NAME" "${KERNELCMD[@]}" )
elif [ "$VM_CON0" = "tmux" ]; then
   KERNELCMD=( "$NETKIT_HOME/bin/block-wrapper" "tmux" "$VM_NAME" "${KERNELCMD[@]}" )
fi


# Actually start network hubs
run_hubs "${HUBLIST[@]}"


# Completely hide primary console, if requested to
if [ "$VM_CON0" = "none" ]; then
   # Start machine in background unless otherwise requested
   if [ -z "$RUN_IN_FOREGROUND" ] && [ "$VM_CON1" != "this" ]; then
      run_kernel_command > /dev/null 2>&1 &
   else
      run_kernel_command > /dev/null 2>&1
   fi
else
   # Start machine in background unless otherwise requested
   if [ -z "$RUN_IN_FOREGROUND" ] && [ "$VM_CON0" != "this" ] && [ "$VM_CON1" != "this" ]; then
      run_kernel_command &
   else
      run_kernel_command
   fi
fi


# Connect to the tmux session if TMUX_OPEN_TERMS is set
if [ "$TMUX_OPEN_TERMS" = "yes" ] && [ "$VM_CON0" = "tmux" ]; then
    vconnect -m "$VM_NAME" --terminal --interval 5 --retry-count 20 &> /dev/null &
fi
