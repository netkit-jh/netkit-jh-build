#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vstart script, which is used to start virtual machines with
# given parameters.


###############################################################################
# Write vstart's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE"
}


###############################################################################
# Write vstart's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   local status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Start MACHINE with a given configuration.

You can use the following options to adjust the virtual machine parameters:
      --ethN=DOMAIN   equip machine with a network interface ethN, where N is a
                        number between 0 and $((MAX_INTERFACES - 1)). It will be connected to the
                        DOMAIN collision domain (network segment). The special
                        domain 'tap' is reserved: when connected to it, an
                        external network can be reached through this interface.
                        A 'tap' interface is declared as follows:
                        --ethN=tap,TAP_ADDRESS,GUEST_ADDRESS
                        where TAP_ADDRESS is the IP address of the host side of
                        the interface and GUEST_ADDRESS is the IP address of
                        the interface inside the virtual machine. TAP_ADDRESS
                        and GUEST_ADDRESS must be on the same subnetwork which,
                        in turn, must not exist on your host network.
                        Note:
                        - Using 'tap' domains performs host-side operations
                           with administrative privileges. The script will take
                           care of asking you for the root password if and when
                           required.
                        - TAP_ADDRESS is mandatory, but is only taken into
                           account when a 'tap' collision domain is first used.
                           The script only uses one 'tap' collision domain for
                           each user on the host machine.
                        - Host-side configurations are not automatically
                           removed when halting machines: you should use the
                           vclean script instead.
  -k, --kernel=FILENAME  use FILENAME as the UML kernel for the virtual
                          machine. The default kernel is:
                          $VM_KERNEL
  -M, --mem=MEM       give the virtual machine MEM MB of RAM. Allowed values
                        span from $MIN_MEM MB to $MAX_MEM MB, defaulting to $VM_MEMORY MB

Filesystem settings can be tuned by using the following options:
  -H, --no-hosthome   do not mount host filesystem inside the machine
  -m, --model-fs=FILENAME  use the specified filesystem image as a model for
                            the virtual machine. FILENAME will not be altered
                            in any way unless the --no-cow option is used. The
                            default model filesystem is:
                            $VM_MODEL_FS
  -f, --filesystem=FILENAME  use FILENAME as a filesystem for the machine. By
                              default, MACHINE.disk is used. Do not use this in
                              conjunction with --no-cow
  -D, --hide-disk-file  hide the virtual machine filesystem (.disk file). The
                         virtual machine will continue to operate normally. Do
                         not use this in conjunction with --no-cow
  -W, --no-cow        avoid using copy-on-write (COW); every change to the
                        virtual machine filesystem is applied directly to the
                        model filesystem

Console settings can be altered by the following options:
      --con0=MODE
      --con1=MODE     attach the virtual machine primary (con0) and secondary
                        (con1) consoles to different devices or terminal
                        emulators.
                        Allowed values for MODE are:
                          xterm   attach to a terminal emulator application
                          this    attach to stdin/stdout, i.e., use current
                                   terminal; only one console at a time can be
                                   set to 'this'.
                          tmux    run in a tmux session (only valid with con0 -
                                  see documentation for more details)
                          pty     attach to a pseudo-terminal
                          port:N  attach to TCP port N
                          none    disable console
                        The default modes for con0 and con1, respectively, are
                        ${VM_CON0} and ${VM_CON1}
      --xterm=TYPE    specify the terminal emulator application. The following
                        values are supported:
                          alacritty    use the lightweight Alacritty terminal
                          gnome        use the GNOME Terminal
                          kitty        use the lightweight Kitty terminal
                          konsole      use the KDE Konsole
                          konsole-tab  same as above, but different virtual
                                        machines are opened in different
                                        Konsole tabs of the same window
                          wsl          use Windows Subsystem for Linux (WSL) in
                                        a conhost.exe window
                          wt           use Windows Subsystem for Linux (WSL) in
                                        a Windows Terminal window
                          xterm        use the standard xterm (default)

If wanting to set up a lab, the following options are relevant:
  -e, --exec=FILENAME  run a specified command or script inside the virtual
                        machine during the boot phase
  -l, --hostlab=DIR   tell the virtual machine that the base directory for a
                        Netkit-JH laboratory is DIR

Miscellaneous:
$(help_option)
      --append=PARAM  append additional kernel command line parameters when
                        running the virtual machine kernel; PARAM can also be
                        an OPTION=VALUE pair. This option can be used multiple
                        times. Parameters will be passed to the kernel in the
                        same order in which they are provided
      --debug         run the virtual machine under a GDB instance to report
                        more messages than with --verbose, and for further
                        debugging. The process requires a SIGINT delivery with
                        kill -INT <pid> to start debugging (if the session
                        booted successfully)
  -F, --foreground    do not launch the virtual machine in background (the
                        latter being the default behavior). Note that virtual
                        hubs are always started in background, regardless of
                        this option. This is the default when using 'this' as
                        the console mode
  -p, --print         do not start anything, just show which commands would be
                        executed
  --tmux-attached     run each VM in tmux and start a terminal attached to the
                        tmux session. This is equivalent to VM_CON0=tmux and
                        TMUX_OPEN_TERMS=yes in netkit.conf
  --tmux-detached     run each VM in a tmux session without opening terminals.
                        This is the same as VM_CON0=tmux and TMUX_OPEN_TERMS=no
                        in netkit.conf
  -v, --verbose       show debugging messages during the boot sequence
$(version_option)

Note: unless otherwise stated, whitespace is not permitted in any option
argument. It is also prohibited in filepaths, including the path to the current
directory at the time vstart is invoked.

END_OF_HELP

   exit "$status"
}


###############################################################################
# Check for invalid characters in filepaths for the ubd argument (set with the
# --filesystem and --model-fs options and also by default).
# Usage:
#   validate_ubd_argument [FILE]...
# Globals:
#   r- SCRIPTNAME
# Arguments:
#  ... - filepath(s) of COW or model filesystems
# Returns:
#   None. Exits the script with with usage 1 if invalid.
# Example:
#   None
###############################################################################
validate_ubd_argument() {
   local filepaths=( "$@" )

   local filepath

   for filepath in "${filepaths[@]}"; do
      if string_contains "$filepath" "," ":" " "; then
         echo 1>&2 "$SCRIPTNAME: $filepath: Invalid character in filesystem path"
         usage 1
      fi
   done
}


###############################################################################
# Warn if file is located on a filesystem that does not support sparse files.
# Usage:
#   check_filesystem FILE
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - file on target filesystem
# Returns:
#   None
# Example:
#   None
###############################################################################
check_filesystem() {
   local filepath=$1

   local fs_type

   # Get the host filesystem type
   fs_type=$(stat --file-system --format "%T" "$filepath")

   if [[ ! "$fs_type" =~ ^(ext2?|ext2/ext3|fuse(blk|ctl)|jfs|ntfs|reiserfs|(da|e|fute|v)?xfs)$ ]]; then
      echo 1>&2 "$SCRIPTNAME: Filesystem '$fs_type' may not support sparse files, this could result in performance loss and disk space consumption"
   fi
}


###############################################################################
# Append network interface specifications to the kernel invocation command.
# Usage:
#   setup_interfaces [INTERFACE]...
# Globals:
#   -w HUB_LIST
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- kernel_cmd
#   r- SCRIPTNAME
#   r- USER_ID
# Arguments:
#  ... - list of interfaces
# Returns:
#   None. Will exit with usage 1 on invalid specification.
# Example:
#   None
###############################################################################
setup_interfaces() {
   local interface_specifications=( "$@" )

   local interface_specification
   local hub_specification hub_name tap_address guest_address hub_socket
   local device used_devices
   local enabled_default_route indent

   enabled_default_route=false

   unset HUB_LIST

   for interface_specification in "${interface_specifications[@]}"; do
      device=${interface_specification%%=*}
      hub_specification=${interface_specification#*=}

      # Check if interface has already been configured
      if array_contains "$device" "${used_devices[@]}"; then
         echo 1>&2 "$SCRIPTNAME: $device: Duplicate interface"
         usage 1
      fi

      # Remember that this network interface has been configured
      used_devices+=( "$device" )

      # Check if tap interface (regular hubs cannot be named with commas)
      if [[ "$hub_specification" == tap,* ]]; then
         # Format: tap,tap_address,guest_address
         IFS=, read -r hub_name tap_address guest_address <<< "$hub_specification"

         if ! is_inet_addr "$tap_address"; then
            echo 1>&2 "$SCRIPTNAME: $tap_address: Invalid tap address"
            usage 1
         fi

         if ! is_inet_addr "$guest_address"; then
            echo 1>&2 "$SCRIPTNAME: $guest_address: Invalid guest address"
            usage 1
         fi
      else
         # This is a normal (i.e., not 'tap') collision domain
         unset tap_address guest_address
         hub_name=$hub_specification
      fi

      # Check for invalid characters in hub_name
      if ! validate_collision_domain_names "$hub_name"; then
         echo 1>&2 "$SCRIPTNAME: $hub_name: Invalid collision domain name"
         usage 1
      fi

      hub_socket=$(get_hub_socket "$hub_name")

      kernel_cmd+=( "$device=daemon,,,$hub_socket" )
      
      if [ -n "$tap_address" ]; then
         HUB_LIST+=( "$hub_name,$tap_address" )

         kernel_cmd+=( "autoconf_$device=$guest_address" )

         # Ensure the default route is specified only once
         if ! $enabled_default_route; then
            kernel_cmd+=( "def_route=$tap_address" )
            enabled_default_route=true
         fi
      else
         HUB_LIST+=( "$hub_name" )
      fi

      echo "$indent$device @ $hub_name ($hub_socket)"

      # Indent subsequent lines
      indent="               "
   done
}


###############################################################################
# Delete .disk file as soon as it is created by the UML instance.
# Usage:
#   remove_fs_command FILE
# Globals:
#   None
# Arguments:
#   $1 - filepath of filesystem (.disk file) to remove
# Returns:
#   None
# Example:
#   remove_fs_command "$filepath" &
###############################################################################
remove_fs_command() {
   local filepath=$1

   while [ ! -f "$filepath" ]; do
      sleep 1
   done
   
   rm --force "$filepath"
}


###############################################################################
# Run relevant kernel invocation setup functions and then invoke the UML kernel
# instance. Upon return, clean up redundant network hubs.
# Usage:
#   run_kernel JUST_PRINT FILE MACHINE
# Globals:
#   r- HUB_LIST
#   r- kernel_cmd
# Arguments:
#   $1 - set to 1 if only doing a dry run, otherwise pass an empty string
#   $2 - filesystem (.disk) file to remove. Empty string to not remove it
#   $2 - machine name
# Returns:
#   None
# Example:
#   None
###############################################################################
run_kernel() {
   local just_print=$1
   local filesystem=$2
   local vhost=$3

   # If doing a dry run, we want to skip all four commands here.
   if [ -n "$just_print" ]; then
      run_command "$just_print" "" "${kernel_cmd[@]}"
      return
   fi
   
   # Remove .disk file, if requested
   [ -n "$filesystem" ] && remove_fs_command "$filesystem" &

   run_command "$just_print" "" "${kernel_cmd[@]}"

   clean_hubs "${HUB_LIST[@]}"
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


# Get command line options
long_opts="append:,con0:,con1:,debug,exec:,filesystem:,foreground,help,\
hide-disk-file,hostlab:,kernel:,mem:,model-fs:,no-cow,no-hosthome,\
print,test,tmux-attached,tmux-detached,verbose,version,xterm:"
short_opts="De:Ff:Hk:Ll:M:m:pvWw:"

for i in $(seq 0 $MAX_INTERFACES); do
   long_opts="$long_opts,eth$i:"
done

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      --append)
         kernel_cmd_append+=( "$2" )
         shift
         ;;
      --con0|--con1)
         option=$1
         console=$2
         shift

         case $console in
            xterm|this|tmux|pty|port:*|none)
               [ "$option" = "--con0" ] && VM_CON0=$console || VM_CON1=$console
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: $console: Unrecognized console"
               usage 1
               ;;
         esac
         ;;
      -D|--hide-disk-file)
         remove_fs=1
         ;;
      --debug)
         debug=1
         ;;
      -e|--exec)
         exec_cmd=$2
         shift
         ;;
      --eth*)
         device=${1#--}
         hub_name=$2
         shift

         # Collision domain names are validated later in setup_interfaces
         interface_specifications+=( "$device=$hub_name" )
         ;;
      -F|--foreground)
         foreground=1
         ;;
      -f|--filesystem)
         # Filepath is validated with validate_ubd_argument later
         filesystem=$(readlink --canonicalize-missing "$2")
         shift
         ;;
      -H|--no-hosthome)
         no_hosthome=1
         ;;
      --help)
         usage 0
         ;;
      -k|--kernel)
         VM_KERNEL=$(readlink --canonicalize-missing "$2")
         shift
         ;;
      -l|--hostlab)
         hostlab_dir=$2
         shift
         ;;
      -M|--mem)
         VM_MEMORY=$2

         if [ "$VM_MEMORY" -lt "$MIN_MEM" ] || [ "$VM_MEMORY" -gt "$MAX_MEM" ]; then
            echo 1>&2 "$SCRIPTNAME: Memory out of permitted range (min: $MIN_MEM MB; max: $MAX_MEM MB)"
            usage 1
         fi

         shift
         ;;
      -m|--model-fs)
         # Filepath is validated with validate_ubd_argument later
         VM_MODEL_FS=$(readlink --canonicalize-missing "$2")
         shift
         ;;
      -p|--print)
         just_print=1
         ;;
      --test)
         kernel_cmd_append+=( "test" )
         ;;
      --tmux-attached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=yes
         ;;
      --tmux-detached)
         VM_CON0="tmux"
         TMUX_OPEN_TERMS=no
         ;;
      -v|--verbose)
         verbose=1
         ;;
      --version)
         show_version
         exit 0
         ;;
      -W|--no-cow)
         no_cow=1
         ;;
      --xterm)
         TERM_TYPE=$2
         shift

         if [[ "$TERM_TYPE" =~ ^(konsole|konsole-tab|gnome|xterm|alacritty|kitty|wsl|wt)$ ]]; then
            echo 1>&2 "$SCRIPTNAME: $TERM_TYPE: Unsupported terminal emulator"
            usage 1
         fi
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Parse virtual machine name
if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
elif [ $# -gt 1 ]; then
   echo 1>&2 "$SCRIPTNAME: Can only specify one machine"
   usage 1
fi

vhost=$1
validate_hostnames "$vhost"


# Check whether user is trying to attach more than one console to stdin/stdout
if [ "$VM_CON0" = "this" ] && [ "$VM_CON1" = "this" ]; then
   echo 1>&2 "$SCRIPTNAME: Only one console can be attached to the current terminal"
   usage 1
fi

if [ -n "$no_cow" ]; then
   # Check whether a COW filesystem has been explictly provided when using the --no-cow option
   if [ -n "$filesystem" ]; then
      echo 1>&2 "$SCRIPTNAME: Cannot provide a filesystem name with --no-cow"
      usage 1
   fi   

   # Check whether the user asked to hide the virtual machine filesystem while using the --no-cow option
   if [ -n "$remove_fs" ]; then
      echo 1>&2 "$SCRIPTNAME: Cannot hide the filesystem when using --no-cow"
      usage 1
   fi
fi


# Check whether the requested terminal emulator application exists
if [ "$VM_CON0" = "tmux" ] && [ "$TMUX_OPEN_TERMS" = "yes" ] || [ "$VM_CON0" = "xterm" ] || [ "$VM_CON1" = "xterm" ]; then
   # Some xterm option arguments are not their relevant executable's name. We
   # hence map these edge cases here.
   case $TERM_TYPE in
      gnome)         term_executable="gnome-terminal";;
      konsole-tab)   term_executable="konsole";;
      wsl)           term_executable="wsl.exe";;
      wt)            term_executable="wt.exe";;
      *)             term_executable=$TERM_TYPE;;
   esac

   if ! command -v "$term_executable" > /dev/null 2>&1; then
      echo 1>&2 "$SCRIPTNAME: $term_executable: Terminal emulator not found"
      exit 1
   fi
fi


###############################################################################
# The following code constructs the command to invoke the UML kernel instance
###############################################################################


### BLOCKING SCRIPT ###########################################################
# The blocking script is a wrapper that forces gnome and tmux to block when
# invoked.
if [ "$VM_CON0" = "xterm" ]; then
   kernel_cmd=( "$NETKIT_HOME/bin/block-wrapper" "$TERM_TYPE" "$vhost" )
elif [ "$VM_CON0" = "tmux" ]; then
   kernel_cmd=( "$NETKIT_HOME/bin/block-wrapper" "tmux" "$vhost" )
fi


echo "============= Starting virtual machine '$vhost' ============="

### KERNEL BINARY #############################################################
echo "   Kernel:      $VM_KERNEL"
kernel_cmd+=( "$VM_KERNEL" )


### UML ID ####################################################################
# This is used to assign a unique ID to the instance and to name the PID file
# and mconsole socket.
kernel_cmd+=( "umid=$vhost" )


### MEMORY ####################################################################
echo "   Memory:      $VM_MEMORY MB"
((VM_MEMORY += VM_MEMORY_SKEW))
kernel_cmd+=( "mem=${VM_MEMORY}M" )


### FILESYSTEM(S) #############################################################
echo "   Model fs:   $VM_MODEL_FS"

if [ -n "$no_cow" ]; then
   echo "   Filesystem:  using model fs (no COW)"
   validate_ubd_argument "$VM_MODEL_FS"
   check_filesystem "$VM_MODEL_FS"

   # Use model fs as virtual machine filesystem (do not use COW)
   kernel_cmd+=( "ubd0=$VM_MODEL_FS" )

   filesystem=$VM_MODEL_FS
else
   : "${filesystem:="$PWD/$vhost.disk"}"

   echo -n "   Filesystem:  $filesystem"
   validate_ubd_argument "$VM_MODEL_FS" "$filesystem"
   check_filesystem "$filesystem"

   # Explicitly declaring the model fs name is redundant after the COW file has
   # been created. Nevertheless, this is needed in order to later get
   # information about the virtual machine (i.e., by using vlist).
   kernel_cmd+=( "ubd0=$filesystem,$VM_MODEL_FS" )

   [ ! -f "$filesystem" ] && echo " (new)" || echo
fi


### ROOT FILESYSTEM ###########################################################
# NOTE: The following root= options should also be valid: /dev/ubda1 and
# /dev/ubd/disc0/part1.
kernel_cmd+=( "root=98:0" )


### MCONSOLE DIRECTORY ########################################################
kernel_cmd+=( "uml_dir=$MCONSOLE_DIR" )


### NETWORK INTERFACES ########################################################
echo -n "   Interfaces:  "
setup_interfaces "${interface_specifications[@]}"


### BOOT SEQUENCE VERBOSITY ###################################################
if [ -n "$debug" ]; then
   kernel_cmd=( "gdb --args" "${kernel_cmd[@]}" )
elif [ -z "$verbose" ]; then
   kernel_cmd+=( "quiet" )
fi


### CONSOLES ##################################################################
case $VM_CON0 in
   none)    kernel_cmd+=( "con0=null" );;
   xterm)   kernel_cmd+=( "con0=xterm" );;
   this)    kernel_cmd+=( "con0=fd:0,fd:1" );;
   pty)     kernel_cmd+=( "con0=pty" );;
   port:*)  kernel_cmd+=( "con0=$VM_CON0" );;
esac

case $VM_CON1 in
   none)    kernel_cmd+=( "con1=null" );;
   xterm)   kernel_cmd+=( "con1=xterm" );;
   this)    kernel_cmd+=( "con1=fd:0,fd:1" );;
   pty)     kernel_cmd+=( "con1=pty" );;
   port:*)  kernel_cmd+=( "con1=$VM_CON1" );;
esac


### CREATE "PROPER" TERMINAL EMULATOR #########################################
# Argument format is <terminal emulator>,<title switch>,<exec switch>
case $TERM_TYPE in
   gnome)         kernel_cmd+=( "xterm=gnome-terminal,-t,-x" );;
   konsole)       kernel_cmd+=( "xterm=konsole,-T,-e" );;
   konsole-tab)   kernel_cmd+=( "xterm=$NETKIT_HOME/bin/konsole-tabs.sh,-T,-e" );;
esac


# The following options are ignored by the UML kernel (they are not valid
# command-line options), but used by the Netkit start-up scripts when reading
# /proc/cmdline.

### KERNEL MODULES ####################################### (non-UML option) ###
kernel_modules_dir="$(dirname "$VM_KERNEL")/modules"

if [ -d "$kernel_modules_dir" ]; then
   echo "   Modules:     $kernel_modules_dir"
   kernel_cmd+=( "modules=$kernel_modules_dir" )
fi


### MACHINE NAME ######################################### (non-UML option) ###
kernel_cmd+=( "name=$vhost" "title=$vhost" )


### HOSTHOME DIRECTORY ################################### (non-UML option) ###
if [ -z "$no_hosthome" ]; then
   echo "   Hosthome at: $HOME"
   kernel_cmd+=( "hosthome=$HOME" )
fi


### HOSTLAB DIRECTORY #################################### (non-UML option) ###
if [ -n "$hostlab_dir" ]; then
   echo "   Hostlab at:  $hostlab_dir"
   kernel_cmd+=( "hostlab=$hostlab_dir" )
fi


### BOOT COMMAND ######################################### (non-UML option) ###
if [ -n "$exec_cmd" ]; then
   echo "   Boot cmd:    '$exec_cmd'"
   kernel_cmd+=( "exec=$exec_cmd" )
fi


### DISABLE SELINUX ###################################### (non-UML option) ###
kernel_cmd+=( "SELINUX_INIT=0" )


### OTHER ARGUMENTS ###########################################################
if [ ${#kernel_cmd_append[@]} -gt 0 ]; then
   echo "   Other args: ${kernel_cmd_append[*]}"
   kernel_cmd+=( "${kernel_cmd_append[@]}" )
fi


echo


###############################################################################
# The following code invokes the UML kernel and any virtual network hubs
###############################################################################


if [ -z "$just_print" ]; then
   # Check whether the virtual machine already exists
   if get_machine_state "$USER_ID" "$vhost"; then
      echo 1>&2 "$SCRIPTNAME: Virtual machine '$vhost' is already running; halt it or use a different hostname"
      exit 1
   fi

   # Check whether filesystem is already in use
   if file_in_use "$filesystem"; then
      echo 1>&2 "$SCRIPTNAME: Filesystem '$filesystem' is already in use; specify a different filesystem"
      exit 1
   fi
fi


# Start network hubs
run_hubs "$just_print" "${HUB_LIST[@]}"


# Completely hide primary console, if requested to
if [ "$VM_CON0" = "none" ]; then
   # Start machine in background unless otherwise requested
   if [ -n "$foreground" ] || [ "$VM_CON1" = "this" ]; then
      run_kernel "$just_print" "${remove_fs:+$filesystem}" "$vhost" > /dev/null 2>&1
   else
      run_kernel "$just_print" "${remove_fs:+$filesystem}" "$vhost" > /dev/null 2>&1 &
   fi
else
   if [ -n "$foreground" ] || [ "$VM_CON1" = "this" ]; then
      run_kernel "$just_print" "${remove_fs:+$filesystem}" "$vhost"
   else
      run_kernel "$just_print" "${remove_fs:+$filesystem}" "$vhost" &
   fi
fi


# Connect to the tmux session if TMUX_OPEN_TERMS is set
if [ "$TMUX_OPEN_TERMS" = "yes" ] && [ "$VM_CON0" = "tmux" ]; then
    vconnect --terminal --interval 5 --retry-count 20 "$vhost" &> /dev/null &
fi
