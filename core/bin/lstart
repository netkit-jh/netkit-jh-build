#!/usr/bin/env bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This script can be used to start a Netkit lab or a subportion of it.


###############################################################################
# Write lstart/ltest's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... [MACHINE]..."
}


###############################################################################
# Write lstart/ltest's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   local status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   usage_line

   if [ "$SCRIPTNAME" = "ltest" ]; then
      echo "Test a Netkit lab."
   else
      echo "Start a Netkit lab."
   fi

   cat << END_OF_HELP
It is possible to start up the whole lab or just some of the virtual machines
that compose it.
END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      echo -n "  -d DIRECTORY        test the lab located inside DIRECTORY."
   else
      echo -n "  -d DIRECTORY        start the lab located inside DIRECTORY."
   fi

   cat << END_OF_HELP
 By default, the
                        process takes place in the current directory
END_OF_HELP

   if [ "$SCRIPTNAME" != "ltest" ]; then
      cat << END_OF_HELP
  -F, --force-lab     by default, Netkit refuses to start a lab in a directory
                        that has neither a lab.conf nor a lab.dep file. Enable
                        this option if you really want to start a lab without
                        any of those two files
  -f, --fast          do not wait for a virtual machine to complete the boot
                        phase before starting the next one. This option has no
                        effect when parallel startup is being used, and is not
                        impacted by the use of the -p option
END_OF_HELP
   fi

   cat << END_OF_HELP
  --tmux-attached     run each VM in tmux and start a terminal attached to the
                        tmux session. This is the same as VM_CON0=tmux and
                        TMUX_OPEN_TERMS=yes in netkit.conf
  --tmux-detached     run each VM in a tmux session without opening terminals.
                        This is the same as VM_CON0=tmux and TMUX_OPEN_TERMS=no
                        in netkit.conf
  -l, --list          show a list of running virtual machines after starting up
                        the lab.
  -o, --pass=OPTION   pass OPTION unaltered to vstart. This will affect all the
                        (newly started) virtual machines of the lab.
  -p[VALUE]           enable parallel startup, even if a lab.dep file does not
                        exist inside the lab directory. If a VALUE is provided,
                        it determines the maximum number of virtual machines
                        that can be launched simultaneously. VALUE must be a
                        positive integer. A VALUE of 0 corresponds to setting
                        no limit. This option is incompatible with -s. Default
                        value is $MAX_SIMULTANEOUS_VMS
  -s, --sequential    disable parallel startup, even if a lab.dep file is found
                        to exist inside the lab directory. This option
                        conflicts with -p
  -w, --wait=SECONDS  wait the specified amount of time before launching the
                        next virtual machine. Of course, this is only useful
                        when using either parallel startup or the -f option
END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      cat << END_OF_HELP

ltest-specific options:
  -R, --rebuild-signature  unconditionally rebuild the test signature,
                            overwriting any existing one
  -S, --script-mode   use a terser and prettier output, suitable for automating
                        the test of several labs
  --verify=TESTTYPE   when performing the test, force ltest to verify the
                        outcome of the test specified by TESTTYPE. Allowed
                        values for TESTTYPE are:
                          user     check the outcome of user-defined tests only
                          builtin  check the outcome of builtin tests only
                          both     always check the outcome of all tests
                        By default, for each virtual machine ltest verifies
                        only the user-defined test if one is available in the
                        signature, or only the built-in test otherwise
END_OF_HELP
   fi

   cat << END_OF_HELP

Miscellaneous:
$(help_option)
  -v, --verbose       show details about virtual machines while starting them
$(version_option)

Notice: using parallel startup requires the 'make' utility to be properly
installed.

By default, all the virtual machines of the lab are started. If one or more
MACHINEs are passed on the command line, then only those machines will be
actually started. If any of the MACHINE names is invalid (i.e., it does not
correspond to a virtual machine of the lab), it will simply be skipped.

END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      cat << END_OF_HELP
The return value of ltest is zero (=good) if and only if the test completed
successfully or a new test signature has been produced.

END_OF_HELP
   fi

   exit "$status"
}


###############################################################################
# Check for update status via GitHub's API and write the new release's URL to
# standard output if out-of-date.
# Usage:
#   update_available
# Globals:
#   r- CHECK_FOR_UPDATES
#   r- NETKIT_HOME
#   r- UPDATE_CHECK_PERIOD
# Arguments:
#   None
# Returns:
#   0 when an update is available, non-zero otherwise
# Example:
#   None
###############################################################################
update_available() {
   local last_update_check next_update_check
   local current_date
   local current_version latest_version

   if [ "$CHECK_FOR_UPDATES" = "yes" ]; then
      # Check whether we have polled in the last UPDATE_CHECK_PERIOD days
      touch "$NETKIT_HOME/.new-version"

      if [ -f "$NETKIT_HOME/.last-update-check" ]; then
         last_update_check=$(cat "$NETKIT_HOME/.last-update-check")
      else
         last_update_check=0
      fi

      # Next check = date of the last one + UPDATE_CHECK_PERIOD (in seconds)
      next_update_check=$((last_update_check + UPDATE_CHECK_PERIOD * 86400))
   
      current_date=$(date +%s)

      if [ "$current_date" -gt "$next_update_check" ]; then
         # We haven't checked in the past UPDATE_CHECK_PERIOD days, check now
         echo "$current_date" > "$NETKIT_HOME/.last-update-check"

         # Get the latest release number from the GitHub API.
         # NOTE: we assume the GitHub API will always return JSON formatted as
         # a key-value pair per line. The relevant line should be:
         # "tag_name": "1.2.3",
         curl --silent "https://api.github.com/repos/netkit-jh/netkit-jh-build/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' > "$NETKIT_HOME/.new-version"
      fi

      current_version=$(sed "s/Netkit version //g" "$NETKIT_HOME/netkit-version")
      latest_version=$(cat "$NETKIT_HOME/.new-version")

      if [ "$latest_version" != "$current_version" ]; then
         echo "https://github.com/netkit-jh/netkit-jh-build/releases/$latest_version"
         return 0
      fi
   fi

   # Return 1 if not checking for updates or an update doesn't exist
   return 1
}


###############################################################################
# Start virtual machines of a Netkit lab sequentially.
# Usage:
#   lab_start FAST_MODE TEST_MODE VERBOSE MAKEFILE DIR [PASSTHROUGH]...
# Globals:
#   rw lab_vhosts
# Arguments:
#   $1 - set to 1 for fast mode, empty string otherwise
#   $2 - set to 1 for test mode, empty string otherwise
#   $3 - set to 1 for verbose mode, empty string otherwise
#   $4 - used internally when lstart is invoked with Make
#   $5 - lab directory
#  ... - array of options to pass through into vstart
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start() {
   local fast_mode=$1
   local test_mode=$2
   local verbose=$3
   local makefile=$4
   local lab_directory=$5
   local passthrough_args=( "${@:6}" )

   local vhost

   get_lab_vhosts "$lab_directory"

   if [ "${#lab_vhosts[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi

   [ -n "$test_mode" ] && passthrough_args+=( "--test" )

   for vhost in "${lab_vhosts[@]}"; do
      single_lab_vhost_start "$fast_mode" "$verbose" "$lab_directory" "$vhost" "${passthrough_args[@]}"
   done
   
   # The readyfor.test file should not be created if lstart has been invoked
   # with the --makefile option (launch a single machine and exit).
   [ -n "$test_mode" ] && [ -z "$makefile" ] && : > "$lab_directory/readyfor.test"
}


###############################################################################
# Start virtual machines of a Netkit lab simultaneously with GNU Make.
# Usage:
#   lab_start_parallel TEST_MODE VERBOSE DIR [PASSTHROUGH]...
# Globals:
#   r- MAX_SIMULTANEOUS_VMS
#   rw lab_vhosts
# Arguments:
#   $1 - set to 1 for test mode, empty string otherwise
#   $2 - set to 1 for verbose mode, empty string otherwise
#   $3 - lab directory
#  ... - array of options to pass through into vstart
# Returns:
#   None
# Example:
#   None
###############################################################################
lab_start_parallel() {
   local test_mode=$1
   local verbose=$2
   local lab_directory=$3
   local passthrough_args=( "${@:4}" )

   local lstart_args arg
   local lstart_cmd escaped_lstart_cmd
   local tab makefile_contents

   get_lab_vhosts "$lab_directory"
   
   if [ "${#lab_vhosts[@]}" -eq 0 ]; then
      echo 1>&2 "Warning: there are no virtual machines to be started."
      return
   fi
   
   # Pass "passthrough" options on to the second invocation of lstart/ltest
   [ -n "$verbose" ] && lstart_args+=( "--verbose" )

   for arg in "${passthrough_args[@]}"; do
      lstart_args+=( "--pass" "$arg" )
   done

   # Pass testmode along subsequent invocations of this script
   if [ -n "$test_mode" ]; then
      program_name="ltest"
   else
      program_name="lstart"
   fi
   
   # The make utility expects an empty argument to -j when infinitely many jobs
   # should be used.
   [ "$MAX_SIMULTANEOUS_VMS" -eq 0 ] && unset MAX_SIMULTANEOUS_VMS


   lstart_cmd=( "$program_name" "-d" "$lab_directory" "--makefile" "${lstart_args[@]}" )

   # We expand this array with the Q operator when writing to the Makefile.
   # This ensures escaping sufficient for reuse in a shell command.
   escaped_lstart_cmd=${lstart_cmd[*]@Q}

   # Make requires all dollar signs (whether quoted or not) to be escaped with
   # a second dollar sign.
   escaped_lstart_cmd=${escaped_lstart_cmd//$/\$$}

   # Labs are started in parallel with GNU Make, which automatically handles
   # lab.dep (which is formatted as Makefile targets).
   #
   # The script is invoked with each VM name as a target on the command line,
   # which directs Make to run:
   #   lstart [...] --makefile <machine>
   # for each machine. $* is a GNU Make automatic variable that expands to the
   # % (stem) in the target. In this usage it will expand to the machine name.
   #
   # The contents of lab.dep is copied in if it exists, which creates a target
   # for each machine with dependencies ("prerequisities" in Make).
   # NOTE: The dummy target is required, which has the unwanted side-effect
   # that machines cannot be named "dummy-prerequisite-to-force-remaking".
   # 
   # The Makefile must use Bash as the shell for correct handling of ANSI-C
   # expansions present after the previous Q-operator array expansion.
   tab=$(printf '\t')
   IFS='' read -rd '' makefile_contents << EOF
SHELL := /bin/bash

%: dummy-prerequisite-to-force-remaking
${tab}[ '\$*' != "lab.dep" ] && $escaped_lstart_cmd '\$*'

dummy-prerequisite-to-force-remaking:
${tab}# Dummy line. Unuseful, yet necessary

$(cat "$lab_directory/lab.dep" 2> /dev/null)
EOF

   # Read the Makefile from stdin without implicit rules, and hide the output. It
   # it parallelised to the MAX_SIMULTANEOUS_VMS configuration option.
   make --ignore-errors --no-builtin-rules --silent \
      --directory "$lab_directory" \
      --file - \
      --jobs ${MAX_SIMULTANEOUS_VMS:+"$MAX_SIMULTANEOUS_VMS"} \
      "${lab_vhosts[@]}" \
      <<< "$makefile_contents"

   
   # Signal that every machine is ready for testing once booted.
   [ -n "$test_mode" ] && : > "$lab_directory/readyfor.test"
}


###############################################################################
# Start a single virtual machine within a lab.
# Usage:
#   single_lab_vhost_start FAST_MODE VERBOSE DIR MACHINE [PASSTHROUGH]...
# Globals:
#   r- GRACE_TIME
# Arguments:
#   $1 - set to 1 for fast mode, empty string otherwise
#   $2 - set to 1 for verbose mode, empty string otherwise
#   $3 - lab directory
#   $4 - machine to start up
#  ... - options to passthrough to vstart (appended on)
# Returns:
#   None
# Example:
#   None
###############################################################################
single_lab_vhost_start() {
   local fast_mode=$1
   local verbose=$2
   local lab_directory=$3
   local vhost=$4
   local passthrough_args=( "${@:5}" )

   local configuration option value

   # Specify host lab directory, and place filesystem inside it
   local vstart_args=( "--hostlab" "$lab_directory" "--filesystem" "$lab_directory/$vhost.disk" )

   # Generate vstart argument list
   if [ -e "$lab_directory/lab.conf" ]; then
      while IFS= read -r configuration; do
         # The [][] is ][ inside a bracket expression to match an opening or
         # closing square bracket.
         # NOTE: we assume hostname_regex does not allow square brackets, so
         # the option string is the first instance of them.
         option=$(awk -F"[][]" '{ print $2 }' <<< "$configuration")

         # Everything after the first '='
         value=${configuration#*=}

         # If option is all-digit, it must be a network interface specification
         [[ "$option" =~ ^([0-9]|[1-9][0-9]+)$ ]] && option="eth$option"

         if [ "${#option}" -eq 1 ]; then
            vstart_args+=( "-$option" )
         else
            vstart_args+=( "--$option" )
         fi

         # NOTE: if vstart is ever changed to have an option with an optional
         # argument (denoted with '::' in the option string), an exception when
         # appending the argument must be made (an '=' is required for long
         # options, no delimiter for short ones).
         [ -n "$value" ] && vstart_args+=( "$value" )
      done < <(grep "^$vhost\[.*\]=" "$lab_directory/lab.conf")
   fi
   
   # Remove .ready file, if existing
   rm --force "$lab_directory/$vhost.ready"

   if [ -z "$verbose" ]; then
      bold_print "Starting '$vhost'..."
   else
      bold_print "Starting '$vhost' with options '${vstart_args[*]} ${passthrough_args[*]}'... "
   fi

   if ! vstart "${vstart_args[@]}" "${passthrough_args[@]}" "$vhost"; then
      echo 2>&1 "Error while starting virtual machine '$vhost'"
      exit 1
   fi

   # Wait for virtual host startup script to create .ready file
   if [ -z "$fast_mode" ]; then
      while [ ! -e "$lab_directory/$vhost.ready" ]; do
         sleep 1
      done

      rm --force "$lab_directory/$vhost.ready"
   fi
   
   # Wait for a specified amount of time before returning
   [ "$GRACE_TIME" -gt 0 ] && sleep "$GRACE_TIME"
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"
# shellcheck source=./lcommon
. "$NETKIT_HOME/bin/lcommon"

# Write to the vcommands log
log_write "$0 $*"


# Get command line options
common_long_opts="force-lab,help,list,makefile,pass:,sequential,tmux-attached,tmux-detached,verbose,version,wait:"
common_short_opts="d:Flo:p::svw:"

ltest_long_opts="$common_long_opts,script-mode,rebuild-signature,verify:"
ltest_short_opts="${common_short_opts}RS"

lstart_long_opts="$common_long_opts,fast"
lstart_short_opts="${common_short_opts}f"

if [ "$SCRIPTNAME" = "ltest" ]; then
   if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$ltest_short_opts" --longoptions "$ltest_long_opts" -- "$@"); then
      # getopt will output the errorneous command-line argument
      usage 1
   fi
else
   if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$lstart_short_opts" --longoptions "$lstart_long_opts" -- "$@"); then
      # getopt will output the errorneous command-line argument
      usage 1
   fi
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      -d)
         lab_directory=$(readlink --canonicalize-missing "$2")
         shift
         ;;
      -F|--force-lab)
         force_lab=1
         ;;
      -f|--fast)
         fast_mode=1
         ;;
      --help)
         usage 0
         ;;
      -l|--list)
         list_vhosts=1
         ;;
      --makefile)
         # This is a hidden option which is used by lstart/ltest itself when
         # parallel startup is enabled.
         makefile=1
         ;;
      -o|--pass)
         passthrough_opts+=( "$2" )
         shift
         ;;
      -p)
         parallelisation=$2
         shift

         # Argument is optional - it will be an empty string if omitted.
         case $parallelisation in
            "")
               # No argument implies MAX_SIMULTAENEOUS_VMS will be the 
               ;;
            *[!0-9]*)
               echo 1>&2 "$SCRIPTNAME: Argument to option '-p' must be a positive integer or 0"
               usage 1
               ;;
            *)
               MAX_SIMULTANEOUS_VMS=$parallelisation
               ;;
         esac

         force_parallel_mode=1
         unset force_sequential_mode
         ;;
      -R|--rebuild-signature)
         rebuild_signature=1
         ;;
      -S|--script-mode)
         script_mode=1
         ;;
      -s|--sequential)
         force_sequential_mode=1
         unset force_parallel_mode
         ;;
      --tmux-attached)
         passthrough_opts+=( "$1" )
         ;;
      --tmux-detached)
         passthrough_opts+=( "$1" )
         ;;
      -v|--verbose)
         verbose=1
         ;;
      --verify)
         case $2 in
            user|builtin|both)
               test_type=$2
               shift
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: Invalid argument to option '--verify'"
               exit 1
               ;;
         esac
         ;;
      --version)
         show_version
         exit 0
         ;;
      -w|--wait)
         case $2 in
            ""|*[!0-9]*)
               echo 1>&2 "$SCRIPTNAME: Argument to option '-w' must be a positive integer or 0"
               usage 1
               ;;
            *)
               GRACE_TIME=$2
               shift
               ;;
         esac
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done
   
# Non-option arguments are machine names
lab_vhosts=( "$@" )
validate_hostnames "${lab_vhosts[@]}"


# If no lab directory has been given, assume current directory
lab_directory=${lab_directory:-$PWD}

# Check that the lab directory exists
if [ ! -d "$lab_directory" ]; then
   echo 1>&2 "$SCRIPTNAME: $lab_directory: No such directory"
   exit 1
fi


# Check whether parallel startup and -f are being used together
if [ -f "$lab_directory/lab.dep" ] && [ -n "$fast_mode" ] && [ -z "$force_sequential_mode" ]; then
   echo 1>&2 "$SCRIPTNAME: Fast mode is ignored when using parallel startup"
fi


# Check if the script has been invoked for testing
if [ "$SCRIPTNAME" = "ltest" ]; then
   test_mode=1

   # Default console is "none" for ltest. By prepending, we allow other
   # passthrough options to override this.
   passthrough_opts=( "--con0" "none" "--con1" "none" "${passthrough_opts[@]}" )

   # Hide .disk files when running tests
   passthrough_opts+=( "--hide-disk-file" )
fi


# Quickly start a virtual machine and exit, if asked to
if [ -n "$makefile" ]; then
   # Make sure to wait for .ready files to appear. Otherwise, no dependencies
   # would be satisfied!
   unset fast_mode
   lab_start "$fast_mode" "$test_mode" "$verbose" "$makefile" "$lab_directory" "${passthrough_opts[@]}"
   exit 0
fi


if [ ! -f "$lab_directory/lab.conf" ] && [ ! -f "$lab_directory/lab.dep" ] && [ -z "$force_lab" ]; then
   echo 1>&2 "$SCRIPTNAME: This does not appear to be a lab directory. Use option '-F' to ignore this error"
   exit 1
fi


# Print lab information
if [ -n "$test_mode" ] && [ -z "$script_mode" ]; then
   bold_print "========================== Testing lab =========================="
else
   bold_print "========================== Starting lab ========================="
fi

if [ -z "$script_mode" ]; then
   lab_welcome "$lab_directory"
   echo
   bold_print "Having issues starting the lab? Run 'lclean' before running 'lstart'."

   # Get ready to start the lab
   if update_url=$(update_available); then
      bold_print "Update available for Netkit-JH - download at $update_url"
   fi

   bold_print "================================================================="
fi


# Clean up the lab directory before starting
[ -n "$test_mode" ] && lab_clean "$verbose" "$lab_directory" > /dev/null

[ -n "$script_mode" ] && echo -n "Starting lab... "

# Check whether a lab.dep file exists. If so, enable parallel startup of
# virtual machines.

if [ -z "$force_sequential_mode" ] && [ -f "$lab_directory/lab.dep" ] || [ -n "$force_parallel_mode" ]; then
   # Use parallel startup if not forced to be sequential and either lab.dep or
   # force_parallel_mode is enabled.
   if [ -z "$script_mode" ]; then
      bold_print "You chose to use parallel startup."
      lab_start_parallel "$test_mode" "$verbose" "$lab_directory" "${passthrough_opts[@]}"
   else
      lab_start_parallel "$test_mode" "$verbose" "$lab_directory" "${passthrough_opts[@]}" > /dev/null
   fi
else
   # Use sequential startup

   # If lab_vhosts is not empty, then lab_start takes care of starting only the
   # machines listed in lab_vhosts; those appearing in lab_vhosts but that are
   # not part in the lab will simply be skipped.
   if [ -z "$script_mode" ]; then
      lab_start "$fast_mode" "$test_mode" "$verbose" "$makefile" "$lab_directory" "${passthrough_opts[@]}"
   else
      lab_start "$fast_mode" "$test_mode" "$verbose" "$makefile" "$lab_directory" "${passthrough_opts[@]}" > /dev/null
   fi
fi


if [ -z "$script_mode" ]; then
   echo
   bold_print "The lab has been started."
   bold_print "================================================================="
else
   echo -n "Testing... "
fi

# Return the status of the lab test
exit_code=0

if [ -n "$test_mode" ]; then
   # Wait for the test to finish
   vhost_count=${#lab_vhosts[@]}

   tests_completed=0
   while [ "$tests_completed" -lt "$vhost_count" ]; do
      testdone_files=( "$lab_directory/"*.testdone )

      # Test avoids the need for shopt -s nullglob
      [ -f "${testdone_files[0]}" ] && tests_completed=${#testdone_files[@]}
      sleep 1
   done

   # Test finished: now crash the lab
   if [ -z "$script_mode" ]; then
      bold_print "Stopping lab..."
   else
      echo -n "Stopping lab... "
   fi

   lab_crash "" "$lab_directory" "" "" > /dev/null
   lab_clean "$verbose" "$lab_directory" > /dev/null

   # Check whether we need to build a test signature or to verify the test
   # outcome.
   if [ ! -d "$lab_directory/_test/signature" ] || [ -n "$rebuild_signature" ]; then
      # (Re)create the test signature
      rm --force --recursive "$lab_directory/_test/signature"
      mv "$lab_directory/_test/results" "$lab_directory/_test/signature"

      if [ -z "$script_mode" ]; then
         bold_print "Test signature created."
      else
         echo -e "test completed.\t\t[ ${color_bold_yellow}SIGN$color_normal ]"
      fi
   else
      # Verify the test outcome against the signature
      case $test_type in
         user)
            user_test_outcomes=( "$lab_directory/_test/signature/"*.user )
            if [ -f "${user_test_outcomes[0]}" ]; then
               diff -qEbB "${user_test_outcomes[@]}" --to-file "$lab_directory/_test/results" > /dev/null
               exit_code=$?
            else
               exit_code=1
            fi
            ;;
         builtin)
            default_test_outcomes=( "$lab_directory/_test/signature/"*.default )
            if [ -f "${default_test_outcomes[0]}" ]; then
               diff -qEbB "${default_test_outcomes[@]}" --to-file "$lab_directory/_test/results" > /dev/null
               exit_code=$?
            else
               exit_code=1
            fi
            ;;
         both)
            diff -qEbBr "$lab_directory/_test/signature" --to-file "$lab_directory/_test/results" > /dev/null
            exit_code=$?
            ;;
         *)
            # test_type has not been set
            for vhost in "${lab_vhosts[@]}"; do
               if [ -f "$lab_directory/_test/signature/$vhost.user" ]; then
                  diff -qEbB "$lab_directory/_test/signature/$vhost.user" --to-file "$lab_directory/_test/results" > /dev/null
                  exit_code=$((exit_code + $?))
               elif [ -f "$lab_directory/_test/signature/$vhost.default" ]; then
                  diff -qEbB "$lab_directory/_test/signature/$vhost.default" --to-file "$lab_directory/_test/results" > /dev/null
                  exit_code=$((exit_code + $?))
               fi
            done
            ;;
      esac

      if [ -z "$script_mode" ]; then
         if [ "$exit_code" -eq 0 ]; then
            bold_print "Test succeeded."
         else
            bold_print "Test FAILED!"
         fi
      else
         if [ "$exit_code" -eq 0 ]; then
            echo -e "test completed.\t\t[ $color_bold_green OK $color_normal ]"
         else
            echo -e "test completed.\t\t[ ${color_bold_red}FAIL$color_normal ]"
         fi
      fi
   fi
fi

# Show a list of running virtual machines, if asked to
[ -n "$list_vhosts" ] && vlist

exit $exit_code
