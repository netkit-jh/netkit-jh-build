#!/usr/bin/env bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This script can be used to start a Netkit lab or a subportion of it.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"


# Write to the vcommands log
log_write "$0 $*"

# Used later on to return the status of the lab test
EXIT_VALUE=0


###############################################################################
# Write lstart/ltest's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... [MACHINE]..."
}


###############################################################################
# Write lstart/ltest's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   usage_line

   if [ "$SCRIPTNAME" = "ltest" ]; then
      echo "Test a Netkit lab."
   else
      echo "Start a Netkit lab."
   fi

   cat << END_OF_HELP
It is possible to start up the whole lab or just some of the virtual machines
that compose it.
END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      echo -n "  -d DIRECTORY        test the lab located inside DIRECTORY."
   else
      echo -n "  -d DIRECTORY        start the lab located inside DIRECTORY."
   fi

   cat << END_OF_HELP
 By default, the
                        process takes place in the current directory
END_OF_HELP

   if [ "$SCRIPTNAME" != "ltest" ]; then
      cat << END_OF_HELP
  -F, --force-lab     by default, Netkit refuses to start a lab in a directory
                        that has neither a lab.conf nor a lab.dep file. Enable
                        this option if you really want to start a lab without
                        any of those two files
  -f, --fast          do not wait for a virtual machine to complete the boot
                        phase before starting the next one. This option has no
                        effect when parallel startup is being used, and is not
                        impacted by the use of the -p option
END_OF_HELP
   fi

   cat << END_OF_HELP
  --tmux-attached     run each VM in tmux and start a terminal attached to the
                        tmux session. This is the same as VM_CON0=tmux and
                        TMUX_OPEN_TERMS=yes in netkit.conf
  --tmux-detached     run each VM in a tmux session without opening terminals.
                        This is the same as VM_CON0=tmux and TMUX_OPEN_TERMS=no
                        in netkit.conf
  -l, --list          show a list of running virtual machines after starting up
                        the lab.
  -o, --pass=OPTION   pass OPTION unaltered to vstart. This will affect all the
                        (newly started) virtual machines of the lab.
  -p[VALUE]           enable parallel startup, even if a lab.dep file does not
                        exist inside the lab directory. If a VALUE is provided,
                        it determines the maximum number of virtual machines
                        that can be launched simultaneously. VALUE must be a
                        positive integer. A VALUE of 0 corresponds to setting
                        no limit. This option is incompatible with -s. Default
                        value is $MAX_SIMULTANEOUS_VMS
  -s, --sequential    disable parallel startup, even if a lab.dep file is found
                        to exist inside the lab directory. This option
                        conflicts with -p
  -w, --wait=SECONDS  wait the specified amount of time before launching the
                        next virtual machine. Of course, this is only useful
                        when using either parallel startup or the -f option
END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      cat << END_OF_HELP

ltest-specific options:
  -R, --rebuild-signature  unconditionally rebuild the test signature,
                            overwriting any existing one
  -S, --script-mode   use a terser and prettier output, suitable for automating
                        the test of several labs
  --verify=TESTTYPE   when performing the test, force ltest to verify the
                        outcome of the test specified by TESTTYPE. Allowed
                        values for TESTTYPE are:
                          user     check the outcome of user-defined tests only
                          builtin  check the outcome of builtin tests only
                          both     always check the outcome of all tests
                        By default, for each virtual machine ltest verifies
                        only the user-defined test if one is available in the
                        signature, or only the built-in test otherwise
END_OF_HELP
   fi

   cat << END_OF_HELP

Miscellaneous:
$(help_option)
  -v, --verbose       show details about virtual machines while starting them
$(version_option)

Notice: using parallel startup requires the 'make' utility to be properly
installed.

By default, all the virtual machines of the lab are started. If one or more
MACHINEs are passed on the command line, then only those machines will be
actually started. If any of the MACHINE names is invalid (i.e., it does not
correspond to a virtual machine of the lab), it will simply be skipped.

END_OF_HELP

   if [ "$SCRIPTNAME" = "ltest" ]; then
      cat << END_OF_HELP
The return value of ltest is zero (=good) if and only if the test completed
successfully or a new test signature has been produced.

END_OF_HELP
   fi

   exit "$status"
}


# Get command line options
COMMON_LONG_OPTS="force-lab,help,list,makefile,pass:,sequential,tmux-attached,tmux-detached,verbose,version,wait:"
COMMON_SHORT_OPTS="d:Flo:p::svw:"

LTEST_LONG_OPTS="$COMMON_LONG_OPTS,script-mode,rebuild-signature,verify:"
LTEST_SHORT_OPTS="${COMMON_SHORT_OPTS}RS"

LSTART_LONG_OPTS="$COMMON_LONG_OPTS,fast"
LSTART_SHORT_OPTS="${COMMON_SHORT_OPTS}f"

if [ "$SCRIPTNAME" = "ltest" ]; then
   if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$LTEST_SHORT_OPTS" --longoptions "$LTEST_LONG_OPTS" -- "$@"); then
      # getopt will output the errorneous command-line argument
      usage 1
   fi
else
   if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$LSTART_SHORT_OPTS" --longoptions "$LSTART_LONG_OPTS" -- "$@"); then
      # getopt will output the errorneous command-line argument
      usage 1
   fi
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      -d)
         LAB_DIRECTORY=$(makeAbsolutePath "$2")
         shift
         ;;
      -F|--force-lab)
         FORCE_LAB=1
         ;;
      -f|--fast)
         FASTMODE=1
         ;;
      --help)
         usage 0
         ;;
      -l|--list)
         LISTVM=1
         ;;
      --makefile)
         # This is a hidden option which is used by lstart/ltest itself when
         # parallel startup is enabled.
         MAKEFILE=1
         ;;
      -o|--pass)
         PASSTHROUGH_OPTIONS="$PASSTHROUGH_OPTIONS $2"
         shift
         ;;
      -p)
         # Argument is optional - it will be an empty string if omitted.
         OPT_ARG=$2
         shift

         case $OPT_ARG in
            ""|*[!0-9]*)
               echo 1>&2 "$SCRIPTNAME: Argument to option '-p' must be a positive integer or 0"
               usage 1
               ;;
            *)
               MAX_SIMULTANEOUS_VMS=$OPT_ARG
               ;;
         esac

         # TODO: Maybe merge with BE_SEQUENTIAL into a Boolean?
         FORCE_PARALLEL_MODE=1
         ;;
      -R|--rebuild-signature)
         CREATE_SIGNATURE=1
         ;;
      -S|--script-mode)
         SCRIPTMODE=1
         ;;
      -s|--sequential)
         BE_SEQUENTIAL=1
         ;;
      --tmux-attached)
         PASSTHROUGH_OPTIONS="$PASSTHROUGH_OPTIONS $1"
         ;;
      --tmux-detached)
         PASSTHROUGH_OPTIONS="$PASSTHROUGH_OPTIONS $1"
         ;;
      -v|--verbose)
         VERBOSE=1
         ;;
      --verify)
         OPT_ARG=$2
         shift

         case $OPT_ARG in
            user|builtin|both)
               VERIFY=$OPT_ARG
               ;;
            *)
               echo 1>&2 "$SCRIPTNAME: Invalid argument to option '--verify'"
               exit 1
               ;;
         esac
         ;;
      --version)
         show_version
         exit 0
         ;;
      -w|--wait)
         OPT_ARG=$2
         shift

         case $OPT_ARG in
            ""|*[!0-9]*)
               echo 1>&2 "$SCRIPTNAME: Argument to option '-w' must be a positive integer or 0"
               usage 1
               ;;
            *)
               GRACE_TIME=$OPT_ARG
               ;;
         esac
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done
   
# Non-option arguments are machine names
VHOSTLIST=( "$@" )

for host in "${VHOSTLIST[@]}"; do
   checkSpaces "$host"
done


# If no lab directory has been given, assume current directory
LAB_DIRECTORY=${LAB_DIRECTORY:-$PWD}

# Check that the lab directory exists
if [ ! -d "$LAB_DIRECTORY" ]; then
   echo 1>&2 "$SCRIPTNAME: $LAB_DIRECTORY: No such directory"
   exit 1
fi

# Check whether path to the lab directory contains spaces
if containsRegexp LAB_DIRECTORY " "; then
   echo 1>&2 "$SCRIPTNAME: $LAB_DIRECTORY: Path contains spaces"
   exit 1
fi


# shellcheck source=./lcommon
. "$NETKIT_HOME/bin/lcommon"


# Check whether parallel startup and -f are being used together
if [ -f "$LAB_DIRECTORY/lab.dep" ] && [ -n "$FASTMODE" ] && [ -z "$BE_SEQUENTIAL" ]; then
   echo 1>&2 "$SCRIPTNAME: Fast mode is ignored when using parallel startup"
fi

# TODO: Maybe merge FORCE_PARALLEL_MODE with BE_SEQUENTIAL into a Boolean?
# Check if -p and -s options are being used together
if [ -n "$FORCE_PARALLEL_MODE" ] && [ -n "$BE_SEQUENTIAL" ]; then
   echo 1>&2 "$SCRIPTNAME: Options '-s' and '-p' cannot be used together"
   exit 1
fi


# Check if the script has been invoked for testing
if [ "$SCRIPTNAME" = "ltest" ]; then
   TESTMODE=1

   # Hide .disk files when running tests
   PASSTHROUGH_OPTIONS="$PASSTHROUGH_OPTIONS -D"
fi


# Quickly start a virtual machine and exit, if asked to
if [ -n "$MAKEFILE" ]; then
   # Make sure to wait for .ready files to appear. Otherwise, no dependencies
   # would be satisfied!
   unset FASTMODE

   labStart
   exit 0
fi


if [ ! -f "$LAB_DIRECTORY/lab.conf" ] && [ ! -f "$LAB_DIRECTORY/lab.dep" ] && [ -z "$FORCE_LAB" ]; then
   echo 1>&2 "$SCRIPTNAME: This does not appear to be a lab directory. Use option '-F' to ignore this error"
   exit 1
fi


update_available() {
   if [ "$CHECK_FOR_UPDATES" = "yes" ]; then
      # Check whether we have polled in the last UPDATE_CHECK_PERIOD days
      touch "$NETKIT_HOME/.new-version"

      if [ -f "$NETKIT_HOME/.last-update-check" ]; then
         last_update_check=$(cat "$NETKIT_HOME/.last-update-check")
      else
         last_update_check=0
      fi

      # Next check = date of the last one + UPDATE_CHECK_PERIOD (in seconds)
      next_update_check=$((last_update_check + UPDATE_CHECK_PERIOD * 86400))
   
      now=$(date +%s)

      if [ "$now" -gt "$next_update_check" ]; then
         # We haven't checked in the past UPDATE_CHECK_PERIOD days, check now
         echo "$now" > "$NETKIT_HOME/.last-update-check"

         # Get the latest release number from the GitHub API.
         # NOTE: we assume the GitHub API will always return JSON formatted as
         # a key-value pair per line. The relevant line should be:
         # "tag_name": "1.2.3",
         curl --silent "https://api.github.com/repos/netkit-jh/netkit-jh-build/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' > "$NETKIT_HOME/.new-version"
      fi

      latest_version=$(cat "$NETKIT_HOME/.new-version")
      current_version=$(sed "s/Netkit version //g" "$NETKIT_HOME/netkit-version")

      if [ "$latest_version" != "$current_version" ]; then
         echo "https://github.com/netkit-jh/netkit-jh-build/releases/$latest_version"
      fi
   fi
}


# Get ready to start the lab
update_url=$(update_available)

# Print lab information
if [ -n "$TESTMODE" ]; then
   [ -z "$SCRIPTMODE" ] && bold_print "========================== Testing lab =========================="
else
   bold_print "========================== Starting lab ========================="
fi

if [ -z "$SCRIPTMODE" ]; then
   lab_welcome
   echo
   bold_print "Having issues starting the lab? Run 'lclean' before running 'lstart'."
   [ -n "$update_url" ] && bold_print "Update available for Netkit-JH - download at $update_url"
   bold_print "================================================================="
fi


if [ -n "$TESTMODE" ]; then
   # By default, virtual machines are run without terminals during the tests.
   # We impose this by setting environment variables for vstart, if not alredy
   # set. This still allows the user to override the setting by using an option
   # like --pass=--con0=xterm.
   export NETKIT_CON0 NETKIT_CON1
   : "${NETKIT_CON0:=none}"
   : "${NETKIT_CON1:=none}"
   
   # Clean up the lab directory before starting
   lab_clean > /dev/null
fi

[ -n "$SCRIPTMODE" ] && echo -n "Starting lab... "

# Check whether a lab.dep file exists. If so, enable parallel startup of
# virtual machines.
if [ -f "$LAB_DIRECTORY/lab.dep" ] && [ -z "$BE_SEQUENTIAL" ] || [ -n "$FORCE_PARALLEL_MODE" ]; then
   # Use parallel startup
   if [ -z "$SCRIPTMODE" ]; then
      bold_print "You chose to use parallel startup."
      labStartParallel
   else
      labStartParallel > /dev/null
   fi
else
   # Use sequential startup

   # If VHOSTLIST is not empty, then labStart takes care of starting only the
   # machines listed in VHOSTLIST; those appearing in VHOSTLIST but that are
   # not part in the lab will simply be skipped.
   if [ -z "$SCRIPTMODE" ]; then
      labStart
   else
      labStart > /dev/null
   fi
fi


COLOR_YELLOW='\033[33;1m'
COLOR_RED='\033[31;1m'
COLOR_GREEN='\033[32;1m'
COLOR_NORMAL='\033[0m'


if [ -z "$SCRIPTMODE" ]; then
   echo
   bold_print "The lab has been started."
   bold_print "================================================================="
else
   echo -n "Testing... "
fi

if [ -n "$TESTMODE" ]; then
   # Wait for the test to finish
   MACHINES_COUNT=${#VHOSTLIST[@]}

   testdone_count=0
   until [ "$testdone_count" -ge "$MACHINES_COUNT" ]; do
      testdone_files=( "$LAB_DIRECTORY"/*.testdone )
      testdone_count=${#testdone_files[@]}

      sleep 1
   done

   # Test finished: now crash the lab
   if [ -z "$SCRIPTMODE" ]; then
      bold_print "Stopping lab..."
   else
      echo -n "Stopping lab... "
   fi

   labCrash > /dev/null
   lab_clean > /dev/null

   # Check whether we need to build a test signature or to verify the test
   # outcome.
   if [ ! -d "$LAB_DIRECTORY/_test/signature" ] || [ -n "$CREATE_SIGNATURE" ]; then
      # (Re)create the test signature
      rm -rf "$LAB_DIRECTORY/_test/signature" > /dev/null
      mv "$LAB_DIRECTORY/_test/results" "$LAB_DIRECTORY/_test/signature"

      if [ -z "$SCRIPTMODE" ]; then
         bold_print "Test signature created."
      else
         printf "test completed.\t\t[ %bSIGN%b ]" "$COLOR_YELLOW" "$COLOR_NORMAL"
      fi
   else
      # Verify the test outcome against the signature
      case $VERIFY in
         user)
            diff -qEbB "$LAB_DIRECTORY/_test/signature/"*.user --to-file "$LAB_DIRECTORY/_test/results" > /dev/null
            EXIT_VALUE=$?
            ;;
         builtin)
            diff -qEbB "$LAB_DIRECTORY/_test/signature/"*.default --to-file "$LAB_DIRECTORY/_test/results" > /dev/null
            EXIT_VALUE=$?
            ;;
         both)
            diff -qEbBr "$LAB_DIRECTORY/_test/signature" --to-file "$LAB_DIRECTORY/_test/results" > /dev/null
            EXIT_VALUE=$?
            ;;
         *)
            # VERIFY has not been set
            EXIT_VALUE=0
            for CURRENT_VHOST in "${VHOSTLIST[@]}"; do
               if [ -f "$LAB_DIRECTORY/_test/signature/$CURRENT_VHOST.user" ]; then
                  diff -qEbB "$LAB_DIRECTORY/_test/signature/$CURRENT_VHOST.user" --to-file "$LAB_DIRECTORY/_test/results" > /dev/null
                  EXIT_VALUE=$((EXIT_VALUE + $?))
               else
                  if [ -f "$LAB_DIRECTORY/_test/signature/$CURRENT_VHOST.default" ]; then
                     diff -qEbB "$LAB_DIRECTORY/_test/signature/$CURRENT_VHOST.default" --to-file "$LAB_DIRECTORY/_test/results" > /dev/null
                     EXIT_VALUE=$((EXIT_VALUE + $?))
                  fi
               fi
            done
            ;;
      esac

      if [ -z "$SCRIPTMODE" ]; then
         if [ "$EXIT_VALUE" -eq 0 ]; then
            bold_print "Test succeeded."
         else
            bold_print "Test FAILED!"
         fi
      else
         if [ "$EXIT_VALUE" -eq 0 ]; then
            printf "test completed.\t\t[ %b OK %b ]" "$COLOR_GREEN" "$COLOR_NORMAL"
         else
            printf "test completed.\t\t[ %bFAIL%b ]" "$COLOR_RED" "$COLOR_NORMAL"
         fi
      fi
   fi
fi

# Show a list of running virtual machines, if asked to
if [ -n "$LISTVM" ]; then
   echo
   vlist
fi

[ -z "$SCRIPTMODE" ] && echo
exit $EXIT_VALUE
