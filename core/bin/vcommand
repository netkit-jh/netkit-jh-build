#!/usr/bin/env bash

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


COMMAND_TIMEOUT="1"


###############################################################################
# Enter command to tmux session via send-keys and return the output to standard
# output.
# Usage:
#   tmux_command SESSION TIMEOUT COMMAND
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - tmux session name
# Returns:
#   None
# Example:
#   None
###############################################################################
tmux_command() {
   local session="$1"
   local timeout="$2"
   local cmd="$3"

   local target="$session:netkit-vm.0"

   if ! tmux -L netkit has-session -t "$session" > /dev/null 2>&1; then
      echo 1>&2 "tmux session does not exist for this machine"
      exit 1
   fi

   # Generate UUID to work out where the command starts
   cmd_uuid=$(cat /proc/sys/kernel/random/uuid)

   if [ -n "$VERBOSE" ]; then
      echo "Command UUID: $cmd_uuid"
      echo "Command: $cmd"
   fi

   # Run command prefixed with a NOP of the UUID for output harvesting
   tmux -L netkit send-keys -t "$target" ": $cmd_uuid; $cmd" Enter

   # Wait for output to be generated
   sleep "$timeout"

   # Get output buffer
   tmux_buffer=$(tmux -L netkit capture-pane -t "$target" -S - -p)

   [ -n "$VERBOSE" ] && printf "Buffer after command:\n%s\n" "$tmux_buffer"

   # Print all lines after the final match of ": $cmd_uuid" and remove the last
   # line (which should the next shell prompt.)
   sed -n "/: $cmd_uuid/{n;h;b};H;\${x;p}" <<< "$tmux_buffer" | head -n -1
}


###############################################################################
# Write vcommand's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE"
}


###############################################################################
# Write vcommand's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Send a command to MACHINE through its tmux session.

  -n, --timeout=N     set how long to wait before grabbing the command output
  -c, --command=CMD   command to send to the machine


Miscellaneous:
$(help_option)
  -v, --verbose       display debugging messages
$(version_option)

END_OF_HELP

   exit "$status"
}


# Get command line options
LONG_OPTS="command,help,timeout,verbose,version"
SHORT_OPTS="c:n:v"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      # TODO: make command or machine last command line option
      -c|--command)
         PARAMS=$2
         ;;
      --help)
         usage 0
         ;;
      -n|--timeout)
         COMMAND_TIMEOUT=$2
         shift
         ;;
      -v|--verbose)
         VERBOSE=1
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done


if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
elif [ $# -gt 1 ]; then
   echo 1>&2 "$SCRIPTNAME: Can only specify one machine"
   usage 1
fi

# Parse virtual machine name
MACHINE_NAME=$1
shift


tmux_command "$MACHINE_NAME" "$COMMAND_TIMEOUT" "$PARAMS"
