#!/usr/bin/env bash

# This script essentially wraps around gnome/tmux commands and forces them to
# block. This is needed because gnome-terminal/tmux don't block until the
# command they're finishing has finished. Netkit relies on this to call the
# clean_hubs function, by trusting that the terminal/kernel command will block
# until the VM has ended. However, as gnome/tmux don't do this, the second they
# have booted the VMs, the hubs are cleaned, causing a kernel panic.
#
# We also use this for all other terminal emulators, as it doesn't change their
# functionality. In the event that another terminal emulator suddenly swaps to
# non-blocking behaviour (as gnome did), they won't suddenly stop working.
#
# https://askubuntu.com/questions/627019/blocking-start-of-terminal


# We shift the argument list for assignment of kernel_cmd
terminal_emulator=$1
vhost=$2
kernel_cmd=( "${@:3}" )


# The PID of the current terminal process is stored in a temporary file. This
# is so the program's state can be monitored later on for termination.
pidfile=$(mktemp)

# The reason behind making pid_cmd a string (and not array like kernel_cmd) is
# to enforce the fact it is a command which will experience shell expansion
# upon being processed by Bash inside the terminal emulator session. This
# allows the $ special parameter and output redirection to function normally.
pid_cmd="echo \$\$ > '$pidfile'"


# kernel_cmd is expanded with the Q operator, meaning Bash will sufficiently
# quote and escape the string suitable for reuse as input.
bash_cmd=( "bash" "-c" "$pid_cmd; ${kernel_cmd[*]@Q}" )

# Windows Terminal further requires escaping of semicolons, otherwise they are
# interpreted as splitting commands across multiple windows.
wt_safe_bash_cmd=( "bash" "-c" "$pid_cmd\\; ${kernel_cmd[*]@Q}" )


case $terminal_emulator in
   alacritty)     alacritty                                                  --command "${bash_cmd[@]}";;
   gnome)         gnome-terminal --title "$vhost"                            --        "${bash_cmd[@]}";;
   kitty)         kitty --title "$vhost"                                               "${bash_cmd[@]}";;
   konsole)       konsole --nofork --title "$vhost"                          -e        "${bash_cmd[@]}";;
   konsole-tab)   "$NETKIT_HOME/bin/konsole-tabs.sh"                         -e        "${bash_cmd[@]}";;
   wsl)           cmd.exe /c start wsl.exe                                             "${bash_cmd[@]}";;
   wt)            wt.exe --suppressApplicationTitle --title "$vhost" wsl.exe --exec    "${wt_safe_bash_cmd[@]}";;
   xterm)         xterm -xrm 'XTerm*allowTitleOps: false' -T "$vhost"        -e        "${bash_cmd[@]}";;
   tmux)
      # Check if tmux session already exists
      if tmux -L netkit has-session -t "$vhost" > /dev/null 2>&1; then
         while true; do
            read -rp "tmux session already exists for machine $vhost. Kill session [y/N]? " response
            case $response in
               [Yy]|[Yy][Ee][Ss])
                  # Kill existing tmux session
                  tmux -L netkit kill-session -t "$vhost"
                  break
                  ;;
               [Nn]|[Nn][Oo])
                  echo "tmux session in use - not starting $vhost."
                  exit
                  ;;
               *)
                  ;;
            esac
         done
      fi

      # Start detached tmux session
      tmux -L netkit -f "$NETKIT_HOME/tools/tmux.conf" new-session -d -s "$vhost" "${bash_cmd[@]}"
      ;;

   *)
      echo "Terminal $terminal_emulator not supported, defaulting to xterm."
      xterm -xrm 'XTerm*allowTitleOps: false' -T "$vhost" -e "${bash_cmd[@]}";;
esac


# Wait until the PID file has been written to
until [ -s "$pidfile" ]; do
   sleep 1s
done

# Wait until this process is dead
while ps --pid "$(cat "$pidfile")" > /dev/null; do
   sleep 1s
done

rm "$pidfile"
