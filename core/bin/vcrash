#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vcrash script. This script can be used to kill running virtual
# machines without shutting them down. This roughly corresponds to unplugging
# their power cord. This script is also useful if you want to kill a hanging
# virtual machine.


###############################################################################
# Write vcrash's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
}


###############################################################################
# Write vcrash's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   local status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Kill running virtual machines without halting them. This roughly corresponds to
disconnecting their power plug. MACHINE is either the name or the PID of a
virtual machine.

  -k, --kill          by default, virtual machines are crashed by using their
                        mconsole socket. This method is generally faster, but
                        in some situations it may not work properly (for
                        example, if a virtual machine is somewhy frozen). If
                        crashing a machine via its mconsole fails, vcrash
                        automatically tries hard to kill the virtual machine
                        processes. By using this option, the attempt via the
                        mconsole socket is simply skipped, and virtual machine
                        processes are just killed
  -q, --quick
      --quiet         quiet mode (suppress any output except errors and
                        warnings). Using this option also disables checking
                        whether virtual machines have actually been crashed,
                        and causes vcrash to exit (almost) immediately. The
                        'almost' is due to the fact that vcrash will still wait
                        for the crash directive to reach the virtual machine
                        when mconsole is being used (default behaviour unless
                        -k is used). Of course, a check inside vcrash prevents
                        from waiting endlessly
  -r, --remove-fs     delete virtual machine (COW) filesystem after crashing
                        machine. Using this option has no effect on machines
                        started with the --no-cow option. Log files are not
                        removed
      --test          do not actually crash virtual machines. Just show which
                        processes would be killed or which mconsole socket
                        would be used to send the crash directive. This option
                        cannot be used when working in quiet mode
  -u, --user=USERNAME  crash virtual machine(s) owned by user USERNAME. By
                        using the special user name '-' any virtual machine can
                        be crashed, regardless of its owner (this requires
                        administrative privileges). If MACHINE is a virtual
                        machine name, and the option --user=- is being used,
                        then only the virtual machine reported by
                        'vlist --user=- MACHINE' is crashed

Miscellaneous:
$(help_option)
$(version_option)

END_OF_HELP

   exit "$status"
}


###############################################################################
# Kill a virtual machine by signaling the corresponding processes.
# Usage:
#   kill_by_signaling USER MACHINE
# Globals:
#   r- BE_QUIET
# Arguments:
#   $1 - owner of machine
#   $2 - machine to kill
# Returns:
#   Returns zero on success, non-zero if there was an issue with killing the
#   machine.
# Example:
#   None
###############################################################################
kill_by_signaling() {
   local target_user=$1
   local vhost=$2

   local pids

   [ -z "$BE_QUIET" ] && echo -n "Killing... "

   # Signalling processes twice ensures they stop even if they need to be
   # killed in a certain order
   IFS=" " read -r -a pids <<< "$(get_vm_all_pids_by_name "$target_user" "$vhost")"

   if [ "${#pids[@]}" -eq 0 ]; then
      kill -TERM "${pids[@]}" > /dev/null
      kill -TERM "${pids[@]}" > /dev/null
   fi

   if [ -z "$BE_QUIET" ]; then
      sleep 1

      if get_machine_state "$target_user" "$vhost"; then
         [ -z "$BE_QUIET" ] && echo -n "killing harder... "
         # Recompute PID list (some threads may have been launched in the
         # meantime).
         IFS=" " read -r -a pids <<< "$(get_vm_all_pids_by_name "$target_user" "$vhost")"

         if [ "${#pids[@]}" -eq 0 ]; then
            kill -KILL "${pids[@]}" > /dev/null
            kill -CONT "${pids[@]}" > /dev/null
         fi

         sleep 1

         if get_machine_state "$target_user" "$vhost"; then
            [ -z "$BE_QUIET" ] && echo "failed!"
            echo 1>&2 "Failed to crash virtual machine '$vhost'"
            return 1
         fi
      fi

      [ -z "$BE_QUIET" ] && echo "done."
   fi

   return 0
}


###############################################################################
# Use uml_mconsole to crash a machine.
# TODO: we can remove the reliance on vhost_info by building the dir path here.
# Usage:
#   mconsole_halt MCONSOLE
# Globals:
#   r- BE_QUIET
#   r- NETKIT_HOME
# Arguments:
#   None
# Returns:
#   Returns zero on success, non-zero if there was an issue with killing the
#   machine.
# Example:
#   None
###############################################################################
mconsole_halt() {
   local mconsole=$1

   local uml_mconsole_pid

   "$NETKIT_HOME/bin/uml_mconsole" "$mconsole" halt > /dev/null &
   uml_mconsole_pid=$!

   # Check whether the mconsole process is hanging forever
   for _ in {0..5}; do
      [ ! -e "/proc/$uml_mconsole_pid" ] && return 0
      sleep 1
   done

   [ -z "$BE_QUIET" ] && echo "hangup detected... "
   kill "$uml_mconsole_pid"

   return 1
}


###############################################################################
# Use mconsole_halt to crash a machine.
# Usage:
#   kill_by_mconsole MCONSOLE USER MACHINE
# Globals:
#   r- BE_QUIET
# Arguments:
#   $1 - mconsole socket
#   $2 - owner of machine
#   $3 - machine to kill
# Returns:
#   Returns zero on success, non-zero if there was an issue with killing the
#   machine.
# Example:
#   None
###############################################################################
kill_by_mconsole() {
   local mconsole=$1
   local target_user=$2
   local vhost=$3

   [ -z "$BE_QUIET" ] && echo -n "Crashing... "

   mconsole_halt "$mconsole"

   # When the above command exits, an attempt via the mconsole has been
   # performed. Regardless of whether the virtual machine has actually halted,
   # the above command ensures that the uml_mconsole process has ended.
   if [ -z "$BE_QUIET" ] && get_machine_state "$target_user" "$vhost"; then
      # Make a second attempt if machine is still running
      echo -n "retrying... "
      sleep 1
      mconsole_halt "$mconsole" || return 1
   fi

   [ -z "$BE_QUIET" ] && echo "done."

   return 0
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


target_user=$USER_ID


# Get command line options
long_opts="help,kill,quiet,remove-fs,root,test,user:,version"
short_opts="kqru:"

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      --help)
         usage 0
         ;;
      # TODO: change to --force or something
      -k|--kill)
         force=1
         ;;
      # TODO: Remove --quiet. Have --verbose and --quick (independent).
      -q|--quick|--quiet)
         BE_QUIET=1
         ;;
      -r|--remove-fs)
         remove_fs=1
         ;;
      --test)
         test_mode=1
         ;;
      -u|--user)
         target_user=$2
         [ "$target_user" = "-" ] && unset target_user
         # TODO: change to username regex
         if string_contains " " "$target_user"; then
            echo 1>&2 "$SCRIPTNAME: Username cannot contain whitespace"
            exit 1
         fi
         shift
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Check whether virtual machine name is missing
if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
fi

# Non-option arguments are machine names
# TODO: sort out vhostlist vs vm_ids
vm_ids=( "$@" )
validate_hostnames "${vm_ids[@]}"


# Test mode is senseless if working in quiet mode
if [ -n "$test_mode" ] && [ -n "$BE_QUIET" ]; then
   echo 1>&2 "$SCRIPTNAME: Option --test cannot be used when working in quiet mode"
   usage 1
fi


for vhost in "${vm_ids[@]}"; do
   # Check whether the current machine exists
   if get_machine_state "$target_user" "$vhost"; then
      get_vhost_info_by_name "$target_user" "$vhost"

      if [ -z "$BE_QUIET" ]; then
         echo "============= Crashing virtual machine '$vhost' (PID ${vhost_info[pid]}) ========="
         echo "Virtual machine owner: $target_user"
         echo "Virtual machine mconsole socket: ${vhost_info[mconsole]}"
         echo "Virtual machine PIDs: $(get_vm_all_pids_by_name "$target_user" "$vhost")"
      fi
   
      [ -n "$test_mode" ] && continue

      if [ -n "$force" ]; then
         # Crash virtual machines by simply killing their processes
         kill_by_signaling "$target_user" "$vhost" || continue
      else
         # Crash virtual machines via uml_mconsole
         if ! kill_by_mconsole "${vhost_info[mconsole]}" "$target_user" "$vhost"; then
            kill_by_signaling "$target_user" "$vhost" || continue
         fi
      fi

      # Filesystem and tmux session removal only occurs if the machine
      # successfully shut down (if the previous commands returned 0).

      # Kill tmux Sessions
      [ -z "$BE_QUIET" ] && echo "Checking for '$vhost' tmux session"

      if tmux -L netkit has-session -t="$vhost" 2>/dev/null; then
         [ -z "$BE_QUIET" ] && echo "Killing tmux session '$vhost'"
         tmux -L netkit kill-session -t="$vhost"
      fi

      [ -z "$BE_QUIET" ] && echo "Checking for '$vhost-dead' tmux session"

      if tmux -L netkit has-session -t="$vhost-dead" 2>/dev/null; then
         [ -z "$BE_QUIET" ] && echo "Killing tmux session '$vhost-dead'"
         tmux -L netkit kill-session -t="$vhost-dead"
      fi

      # Remove filesystem (.disk file)
      [ -n "$remove_fs" ] && [ -n "${vhost_info[disk]}" ] && rm_filesystem "${vhost_info[disk]}"
   fi

done
