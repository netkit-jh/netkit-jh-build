#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vcrash script. This script can be used to kill running virtual
# machines without shutting them down. This roughly corresponds to unplugging
# their power cord. This script is also useful if you want to kill a hanging
# virtual machine.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


###############################################################################
# Write vcrash's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE..."
}


###############################################################################
# Write vcrash's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Kill running virtual machines without halting them. This roughly corresponds to
disconnecting their power plug. MACHINE is either the name or the PID of a
virtual machine.

  -k, --kill          by default, virtual machines are crashed by using their
                        mconsole socket. This method is generally faster, but
                        in some situations it may not work properly (for
                        example, if a virtual machine is somewhy frozen). If
                        crashing a machine via its mconsole fails, vcrash
                        automatically tries hard to kill the virtual machine
                        processes. By using this option, the attempt via the
                        mconsole socket is simply skipped, and virtual machine
                        processes are just killed
  -q, --quick
      --quiet         quiet mode (suppress any output except errors and
                        warnings). Using this option also disables checking
                        whether virtual machines have actually been crashed,
                        and causes vcrash to exit (almost) immediately. The
                        'almost' is due to the fact that vcrash will still wait
                        for the crash directive to reach the virtual machine
                        when mconsole is being used (default behaviour unless
                        -k is used). Of course, a check inside vcrash prevents
                        from waiting endlessly
  -r, --remove-fs     delete virtual machine (COW) filesystem after crashing
                        machine. Using this option has no effect on machines
                        started with the --no-cow option. Log files are not
                        removed
      --test          do not actually crash virtual machines. Just show which
                        processes would be killed or which mconsole socket
                        would be used to send the crash directive. This option
                        cannot be used when working in quiet mode
  -u, --user=USERNAME  crash virtual machine(s) owned by user USERNAME. By
                        using the special user name '-' any virtual machine can
                        be crashed, regardless of its owner (this requires
                        administrative privileges). If MACHINE is a virtual
                        machine name, and the option --user=- is being used,
                        then only the virtual machine reported by
                        'vlist --user=- MACHINE' is crashed

Miscellaneous:
$(help_option)
$(version_option)

END_OF_HELP

   exit "$status"
}


# Get command line options
LONG_OPTS="force,help,kill,quiet,remove-fs,root,test,user:,version"
SHORT_OPTS="kqru:"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

USER=$USERID

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      --help)
         usage 0
         ;;
      -k|--kill)
         DO_KILL=1
         ;;

      # TODO: Remove --quiet. Have --verbose and --quick (independent).
      -q|--quick|--quiet)
         BE_QUIET=1
         ;;
      -r|--remove-fs)
         REMOVE_FS=1
         ;;
      --test)
         TEST_MODE=1
         ;;
      -u|--user)
         USER=$2
         [ "$USER" = "-" ] && unset USER
         # TODO: change to username regex
         checkSpaces "$USER"
         shift
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Check whether virtual machine name is missing
if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
fi

# Non-option arguments are machine names
vm_ids=( "$@" )

for host in "${vm_ids[@]}"; do
   checkSpaces "$host"
done


# Test mode is senseless if working in quiet mode
if [ -n "$TEST_MODE" ] && [ -n "$BE_QUIET" ]; then
   echo 1>&2 "$SCRIPTNAME: Option --test cannot be used when working in quiet mode"
   usage 1
fi


# This function kills a virtual machine by simply signaling the corresponding
# processes. It is assumed that vm_info has been populated.
kill_by_signaling() {
   vm=$1

   [ -z "$BE_QUIET" ] && echo -n "Killing... "

   # Signalling processes twice ensures they stop even if they need to be
   # killed in a certain order
   IFS=" " read -r -a pids <<< "$(get_vm_all_pids_by_name "$USER" "$vm")"

   if [ "${#pids[@]}" -eq 0 ]; then
      kill -TERM "${pids[@]}" > /dev/null
      kill -TERM "${pids[@]}" > /dev/null
   fi

   if [ -z "$BE_QUIET" ]; then
      sleep 1

      if get_machine_state "$USER" "$vm"; then
         [ -z "$BE_QUIET" ] && echo -n "killing harder... "
         # Recompute PID list (some threads may have been launched in the
         # meantime).
         IFS=" " read -r -a pids <<< "$(get_vm_all_pids_by_name "$USER" "$vm")"

         if [ "${#pids[@]}" -eq 0 ]; then
            kill -KILL "${pids[@]}" > /dev/null
            kill -CONT "${pids[@]}" > /dev/null
         fi

         sleep 1

         if get_machine_state "$USER" "$vm"; then
            [ -z "$BE_QUIET" ] && echo "failed!"
            echo 1>&2 "Failed to crash virtual machine '$vm'"
            return 1
         fi
      fi

      [ -z "$BE_QUIET" ] && echo "done."
   fi

   # Virtual machine filesystem is removed only if it has been successfully crashed
   [ -n "$REMOVE_FS" ] && [ -n "${vm_info[disk]}" ] && remove_fs "${vm_info[disk]}"
   
   return 0
}



# This function uses a virtual machine management console to immediately crash
# it. The function also takes care of handling the case in which uml_console
# freezes. In such a situations, it kills the uml_mconsole process and returns
# a non-zero value. Please note that the function only fails when uml_mconsole
# hangs, regardless of whether the virtual machine has been actually crashed
# or not. Here it is assumed that vm_info has been populated.
mconsole_halt() {
   "$NETKIT_HOME/bin/uml_mconsole" "${vm_info[mconsole]}" halt > /dev/null &
   uml_mconsole_pid=$!

   # Check whether the mconsole process is hanging forever
   i=0
   while [ $i -le 5 ]; do
      [ ! -e "/proc/$uml_mconsole_pid" ] && return 0
      [ $i -lt 5 ] && sleep 1
      i=$((i + 1))
   done

   [ -z "$BE_QUIET" ] && echo "hangup detected... "
   kill "$uml_mconsole_pid"

   return 1
}



# This function kills a virtual machine by using their management console
# (mconsole) socket. Upon failure, it reverts to killing the virtual machine
# processes. It assumes that vm_info has been populated.
kill_by_mconsole() {
   vm=$1

   [ -z "$BE_QUIET" ] && echo -n "Crashing... "

   mconsole_halt

   # When the above command exits, an attempt via the mconsole has been
   # performed. Regardless of whether the virtual machine has actually halted,
   # the above command ensures that the uml_mconsole process has ended.
   if [ -z "$BE_QUIET" ]; then
      # Make a second attempt if machine is still running
      if get_machine_state "$USER" "$vm"; then
         echo -n "retrying... "
         sleep 1

         if ! mconsole_halt; then
            # uml_mconsole is hanging forever
            
            # The two lines below are necessary in order to retrieve the
            # virtual machine PIDs, which are required by kill_by_signaling.
            # We chose not to retrieve them immediately because this requires
            # time and is only necessary if mconsole does not work.
            kill_by_signaling "$vm"
            return $?
         elif get_machine_state "$USER" "$vm"; then
            # Attempt to kill virtual machine processes
            kill_by_signaling "$vm"
            return $?
         else
            echo "done."
         fi
      else
         echo "done."
      fi
   fi

   [ -n "$REMOVE_FS" ] && [ -n "${vm_info[disk]}" ] && remove_fs "${vm_info[disk]}"
}


for vm in "${vm_ids[@]}"; do
   # Check whether the current machine exists
   if get_machine_state "$USER" "$vm"; then
      get_vm_info_by_name "$USER" "$vm"

      if [ -z "$BE_QUIET" ]; then
         echo "============= Crashing virtual machine '$vm' (PID ${vm_info[pid]}) ========="
         echo "Virtual machine owner: $USER"
         echo "Virtual machine mconsole socket: ${vm_info[mconsole]}"
         echo "Virtual machine PIDs: $(get_vm_all_pids_by_name "$USER" "$vm")"
      fi
   
      [ -n "$TEST_MODE" ] && continue

      if [ -n "$DO_KILL" ]; then
         # Crash virtual machines by simply killing their processes
         kill_by_signaling "$vm"
      else
         # Crash virtual machines via uml_mconsole
         kill_by_mconsole "$vm"
      fi

      # Kill tmux Sessions
      [ -z "$BE_QUIET" ] && echo "Checking for '$vm' tmux session"

      if tmux -L netkit has-session -t="$vm" 2>/dev/null; then
         [ -z "$BE_QUIET" ] && echo "Killing tmux session '$vm'"
         tmux -L netkit kill-session -t="$vm"
      fi

      [ -z "$BE_QUIET" ] && echo "Checking for '$vm-dead' tmux session"

      if tmux -L netkit has-session -t="$vm-dead" 2>/dev/null; then
         [ -z "$BE_QUIET" ] && echo "Killing tmux session '$vm-dead'"
         tmux -L netkit kill-session -t="$vm-dead"
      fi
   fi

done
