#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vclean script, which can be used to remove unused virtual
# hubs, hanging UML kernels and configured tunnels.

SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


###############################################################################
# Write vclean's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]..."
}


###############################################################################
# Write vclean's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Perform a Netkit cleanup operation:
- Kill processes associated to unused (or all) virtual hubs
- Kill running virtual machines
- Remove host-side configurations set up for tap interfaces
By default, the script just removes unused virtual hubs.

This command can be used to clean up a directory containing a Netkit lab. It
takes care of removing any temporary files, that is, '.ready' files, '.log'
files, the 'readyfor.test' file as well as virtual machines (COW) filesystems
('.disk' files). Therefore, any change to the virtual machines filesystems is
lost. Of course, any persistent part of the lab is preserved, including those
files that are automatically copied inside virtual machines during the boot
phase.

      --clean-all     A synonym for -HKT (use with care)
  -H, --remove-hubs   Just kill unused virtual hubs. This is the default,
                        unless another action has been explicitly requested.
  -K, --kill-machines  Kill all running virtual machines and virtual hubs. This
                        corresponds to crashing all running virtual machines
                        (even those that are frozen) and the virtual hubs they
                        are attached to.
  -T, --remove-tunnels  Remove tunnels and other configuration settings that
                         have been altered in order to set up "tap" collision
                         domains. This is not a per-user action: using this
                         option will remove every host-side configuration that
                         has been set up to use tap interfaces. This operation
                         requires administrative privileges. The script will
                         take care of asking for the root password if required.
      --test          Do not actually stop virtual machines and hubs: just show
                        which processes would be killed. This option cannot be
                        used when working in quiet mode. Action
                        --remove-tunnels is not affected by this option
  -u, --user=USERNAME  perform operations on processes and tunnels owned by
                        USERNAME. By using the special user name '-' all the
                        processes are affected, regardless of their user (this
                        requires administrative privileges). Action
                        --remove-tunnels is not affected by this option

  -d DIRECTORY        clean up the lab inside DIRECTORY. By default, the
                        cleaning process takes place in the current directory

Miscellaneous:
$(help_option)
  -q, --quick
      --quiet         quiet mode (suppress any output except errors and
                        warnings). Also, do not check whether processes have been
                        actually stopped. This option cannot be used in
                        conjunction with --test.
$(version_option)

END_OF_HELP

   exit "$status"
}


# USERID is set in script_utils
USER="$USERID"


# Get command line options
LONG_OPTS="clean-all,help,kill-machines,quick,quiet,remove-hubs,remove-tunnels,test,user:,version"
SHORT_OPTS="HKTu:q"

if ! GETOPT_OPTS=$(getopt --name "$SCRIPTNAME" --options "$SHORT_OPTS" --longoptions "$LONG_OPTS" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$GETOPT_OPTS"

while true; do
   case "$1" in
      --clean-all)
         KILL_MACHINES=1
         REMOVE_TUNNELS=1
         ;;
      -H|--remove-hubs)
         REMOVE_UNUSED_HUBS=1
         ;;
      --help)
         usage 0
         ;;
      -K|--kill-machines)
         KILL_MACHINES=1
         ;;
      # TODO: Separate options (and use --verbose)
      -q|--quick|--quiet)
         BE_QUIET=1
         ;;
      -T|--remove-tunnels)
         REMOVE_TUNNELS=1
         ;;
      --test)
         TEST_MODE=1
         ;;
      --user|-u)
         USER="$2"
         [ "$USER" = "-" ] && unset USER
         shift
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Check for further arguments
if [ $# -gt 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Too many arguments"
   usage 1
   exit 1
fi


# Test mode is senseless if working in quiet mode
if [ -n "$TEST_MODE" ] && [ -n "$BE_QUIET" ]; then
   echo 1>&2 "$SCRIPTNAME: test mode cannot function in quiet mode"
   exit 1
fi

# Actions --remove-hubs and --kill-machines are incompatible
if [ -n "$REMOVE_UNUSED_HUBS" ] && [ -n "$KILL_MACHINES" ]; then
   echo 1>&2 "$SCRIPTNAME: Hub removal and machine kill cannot be performed simultaneously"
   exit 1
fi

# Enable default action (remove unused virtual hubs) if none has been requested
if [ -z "$KILL_MACHINES" ] && [ -z "$REMOVE_TUNNELS" ]; then
   REMOVE_UNUSED_HUBS=1
fi


###############################################################################
# Kill all running VMs.
# Usage:
#   kill_all_vms USER
# Globals:
#   r- BE_QUIET
#   r- NETKIT_HOME
#   r- TEST_MODE
# Arguments:
#   $1 - owner of the machines; pass an empty string for all users
# Returns:
#   None. Returns early on test mode (only outputs PIDs without killing them).
# Example:
#   None
###############################################################################
kill_all_vms() {
   local user=$1
   [ -n "$user" ] && pgrep_euid="--euid"

   mapfile -t pids < <(pgrep "${pgrep_euid:+$pgrep_euid}" "${user:+$user}" --full "^$NETKIT_HOME/kernel/netkit-kernel[[:blank:]]")

   [ -z "$BE_QUIET" ] && echo "   PIDs: ${pids[*]}"

   # We are in test mode, just show which processes would be killed
   [ -n "$TEST_MODE" ] && return

   if [ -z "$BE_QUIET" ]; then
      echo -n "   Killing... "

      # Signalling processes twice ensures they stop even if they need to be
      # killed in a certain order
      kill -TERM "${pids[@]}"
      kill -TERM "${pids[@]}"

      sleep 1
      mapfile -t pids < <(pgrep "${pgrep_euid:+$pgrep_euid}" "${user:+$user}" --full "^$NETKIT_HOME/kernel/netkit-kernel[[:blank:]]")

      if [ "${#pids[@]}" -gt 0 ]; then
         echo -n "killing harder... "

         kill -KILL "${pids[@]}"
         kill -CONT "${pids[@]}"

         sleep 1
         mapfile -t pids < <(pgrep "${pgrep_euid:+$pgrep_euid}" "${user:+$user}" --full "^$NETKIT_HOME/kernel/netkit-kernel[[:blank:]]")

         if [ "${#pids[@]}" -gt 0 ]; then
            echo "failed!"
         else
            echo "done."
         fi
      else
         echo "done."
      fi
   else
      # Just kill processes
      kill -KILL "${pids[@]}" > /dev/null
      kill -CONT "${pids[@]}" > /dev/null
   fi
}


###############################################################################
# Kill unused hubs by process ID and remove their socket files.
# Usage:
#   kill_hubs FORCE [PID]...
# Globals:
#   r- BE_QUIET
#   r- TEST_MODE
# Arguments:
#   $1 - set to 1 to kill and remove hubs even if being used, otherwise pass an
#        empty string.
#  ... - the process IDs of the virtual hubs to clean up.
# Returns:
#   None
# Example:
#   None
###############################################################################
kill_hubs() {
   local uml_switch_cmd
   local hub_pid hub_file found_unused_hub

   local force=$1
   shift

   local hub_pids=( "$@" )

   for hub_pid in "${hub_pids[@]}"; do
      # Safely extract the socket filename from argv.
      # NOTE: we assume the final command line argument is the socket filename.
      mapfile -d "" uml_switch_cmd < "/proc/$hub_pid/cmdline"
      hub_file=${uml_switch_cmd[-1]}

      if [ -n "$force" ] || [ "$(lsof -a -U -p "$hub_pid" -Fn | grep -c "^n$hub_file")" -le 1 ]; then
         # Force mode or no more virtual machines are using the hub connected
         # to this socket
         found_unused_hub=1

         [ -z "$BE_QUIET" ] && echo -n "   $hub_file (PID $hub_pid)"

         if [ -z "$TEST_MODE" ]; then
            echo -n ": Killing... "
            kill "$hub_pid" && rm "$hub_file"
            echo -n "done."
         fi

         [ -z "$BE_QUIET" ] && echo
      fi
   done

   [ -n "$found_unused_hub" ] && [ -z "$BE_QUIET" ] && echo "   No unused virtual hubs have been found."
}



if [ -z "$USER" ]; then
   USER_STRING="all users"
else
   # We need the euid option for pgrep to filter by user
   pgrep_euid="--euid"
   USER_STRING=$USER
fi


# Remove unused hubs (if asked to)
if [ -n "$REMOVE_UNUSED_HUBS" ]; then
   # Just remove unused switches
   [ -z "$BE_QUIET" ] && echo "Killing unusued virtual hubs owned by $USER_STRING:"

   # Get the process IDs of running UML virtual hubs
   mapfile -t hub_pids < <(pgrep "${pgrep_euid:+$pgrep_euid}" "${user:+$user}" --full "^$NETKIT_HOME/bin/uml_switch")

   # Kill uml_switch processes and clean up hub files
   kill_hubs "" "${hub_pids[@]}"
fi


# Kill running virtual machines and hubs (if asked to)
if [ -n "$KILL_MACHINES" ]; then
   # Kill all running virtual machine kernels and all virtual hubs
   [ -z "$BE_QUIET" ] && echo "Killing virtual machines owned by $USER_STRING:"

   kill_all_vms "$USER"

   [ -z "$BE_QUIET" ] && echo "Killing virtual hubs owned by $USER_STRING:"

   # Get the process IDs of running UML virtual hubs
   mapfile -t hub_pids < <(pgrep "${pgrep_euid:+$pgrep_euid}" "${user:+$user}" --full "^$NETKIT_HOME/bin/uml_switch")

   # Kill uml_switch processes and clean up hub files
   kill_hubs "1" "${hub_pids[@]}"
fi


# Remove tunnel configurations (if asked to)
if [ -n "$REMOVE_TUNNELS" ]; then
   # Remove any previously configured tunnel
   if [ -z "$BE_QUIET" ]; then
      echo "************* Removing tap configurations *************"
      echo " This will affect tap configurations for $USER_STRING."
      echo "******* This operation requires root privileges *******"
   fi

   # TODO: These commands don't run for the specified user (this is a
   # manage_tuntap limitation).
   if [ "$USE_SUDO" = "yes" ]; then      
      TUNTAP_COMMAND=( "sudo" "-p" "$USER's password: " "$NETKIT_HOME/bin/manage_tuntap" "$NETKIT_HOME" "stop" )
   else
      TUNTAP_COMMAND=( "su" "-mc" "$NETKIT_HOME/bin/manage_tuntap" "$NETKIT_HOME" "stop" )
   fi

   if [ -z "$BE_QUIET" ]; then   
      if ! run_command "" "$NETKIT_HOME/bin/manage_tuntap stop" "${TUNTAP_COMMAND[@]}"; then
         echo 1>&2 "Error while removing tap configurations"
         exit 1
      fi
   else
      if ! run_command "" "$NETKIT_HOME/bin/manage_tuntap stop" "${TUNTAP_COMMAND[@]}" > /dev/null; then
         echo 1>&2 "Error while removing tap configurations"
         exit 1
      fi
   fi

   [ -z "$BE_QUIET" ] && echo "************** Abandoning root privileges *************"
fi
