#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vclean script, which can be used to remove unused virtual
# hubs, hanging UML kernels and configured tunnels.


###############################################################################
# Write vclean's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]..."
}


###############################################################################
# Write vclean's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   local status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Perform a Netkit cleanup operation:
- Kill processes associated to unused (or all) virtual hubs
- Kill running virtual machines
- Remove host-side configurations set up for tap interfaces
By default, the script just removes unused virtual hubs.

This command can be used to clean up a directory containing a Netkit lab. It
takes care of removing any temporary files, that is, '.ready' files, '.log'
files, the 'readyfor.test' file as well as virtual machines (COW) filesystems
('.disk' files). Therefore, any change to the virtual machines filesystems is
lost. Of course, any persistent part of the lab is preserved, including those
files that are automatically copied inside virtual machines during the boot
phase.

      --clean-all     A synonym for -HKT (use with care)
  -H, --remove-hubs   Just kill unused virtual hubs. This is the default,
                        unless another action has been explicitly requested.
  -K, --kill-machines  Kill all running virtual machines and virtual hubs. This
                        corresponds to crashing all running virtual machines
                        (even those that are frozen) and the virtual hubs they
                        are attached to.
  -T, --remove-tunnels  Remove tunnels and other configuration settings that
                         have been altered in order to set up "tap" collision
                         domains. This is not a per-user action: using this
                         option will remove every host-side configuration that
                         has been set up to use tap interfaces. This operation
                         requires administrative privileges. The script will
                         take care of asking for the root password if required.
      --test          Do not actually stop virtual machines and hubs: just show
                        which processes would be killed. --remove-tunnels is
                        not affected by this option.
  -u, --user=USERNAME  perform operations on processes and tunnels owned by
                        USERNAME. By using the special user name '-' all the
                        processes are affected, regardless of their user (this
                        requires administrative privileges). Action
                        --remove-tunnels is not affected by this option

  -d DIRECTORY        clean up the lab inside DIRECTORY. By default, the
                        cleaning process takes place in the current directory

Miscellaneous:
$(help_option)
  -q, --quick         quick mode - do not check if processes have actually
                        stopped.
$(version_option)

END_OF_HELP

   exit "$status"
}


###############################################################################
# Kill all running VMs.
# Usage:
#   kill_all_vhosts TEST_MODE QUICK_MODE USER
# Globals:
#   r- NETKIT_HOME
# Arguments:
#   $1 - set to 1 for test mode, empty string otherwise
#   $2 - set to 1 for quick mode, empty string otherwise
#   $3 - owner of the machines; pass an empty string for all users
# Returns:
#   None. Returns early on test mode (only outputs PIDs without killing them).
# Example:
#   None
###############################################################################
kill_all_vhosts() {
   local test_mode=$1
   local quick_mode=$2
   local target_user=$3

   local pids

   mapfile -t pids < <(pgrep ${target_user:+"--euid=$target_user"} --full "^$VM_KERNEL")

   echo "   PIDs: ${pids[*]}"

   # We are in test mode, just show which processes would be killed
   [ -n "$test_mode" ] && return

   echo -n "   Killing... "

   if [ "${#pids[@]}" -eq 0 ]; then
      echo "done."
      return
   fi

   if [ -n "$quick_mode" ]; then
      # Just kill processes
      kill -KILL "${pids[@]}"
      kill -CONT "${pids[@]}"
      return
   fi

   # Signalling processes twice ensures they stop even if they need to be
   # killed in a certain order
   kill -TERM "${pids[@]}"
   kill -TERM "${pids[@]}"

   sleep 1
   mapfile -t pids < <(pgrep ${target_user:+"--euid=$target_user"} --full "^$VM_KERNEL")

   if [ "${#pids[@]}" -gt 0 ]; then
      echo -n "killing harder... "

      kill -KILL "${pids[@]}"
      kill -CONT "${pids[@]}"

      sleep 1
      mapfile -t pids < <(pgrep ${target_user:+"--euid=$target_user"} --full "^$VM_KERNEL")

      if [ "${#pids[@]}" -gt 0 ]; then
         echo "failed!"
         return 1
      fi
   fi

   echo "done."

   return 0
}


###############################################################################
# Kill unused hubs by process ID and remove their socket files.
# Usage:
#   kill_hubs FORCE TEST_MODE [PID]...
# Globals:
#   None
# Arguments:
#   $1 - set to 1 to kill and remove hubs even if being used, otherwise pass an
#        empty string.
#   $2 - set to 1 for test mode, empty string otherwise
#  ... - the process IDs of the virtual hubs to clean up.
# Returns:
#   None
# Example:
#   None
###############################################################################
kill_hubs() {
   local force=$1
   local test_mode=$2
   local hub_pids=( "${@:3}" )
   
   local hub_pid hub_file
   local uml_switch_cmd
   local found_unused_hub   

   for hub_pid in "${hub_pids[@]}"; do
      # Safely extract the socket filename from argv.
      # NOTE: we assume the final command line argument is the socket filename.
      mapfile -d "" -t uml_switch_cmd < "/proc/$hub_pid/cmdline"
      hub_file=${uml_switch_cmd[-1]}

      if [ -n "$force" ] || [ "$(lsof -a -U -p "$hub_pid" -Fn | grep --count "^n$hub_file")" -le 1 ]; then
         # Force mode or no more virtual machines are using the hub connected
         # to this socket
         found_unused_hub=1

         echo -n "   $hub_file (PID $hub_pid)"

         if [ -z "$test_mode" ]; then
            echo -n ": Killing... "
            kill "$hub_pid" && rm "$hub_file"
            echo -n "done."
         fi

         echo
      fi
   done

   [ -z "$found_unused_hub" ] && echo "   No unused virtual hubs have been found."
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


target_user=$USER_ID


# Get command line options
long_opts="clean-all,help,kill-machines,quick,remove-hubs,remove-tunnels,test,user:,version"
short_opts="HKTu:q"

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      --clean-all)
         kill_machines=1
         remove_tunnels=1
         ;;
      -H|--remove-hubs)
         remove_hubs=1
         ;;
      --help)
         usage 0
         ;;
      -K|--kill-machines)
         kill_machines=1
         ;;
      -q|--quick)
         quick_mode=1
         ;;
      -T|--remove-tunnels)
         remove_tunnels=1
         ;;
      --test)
         test_mode=1
         ;;
      --user|-u)
         target_user=$2
         shift
         if [ "$target_user" = "-" ]; then
            unset target_user
         elif ! id "$target_user" > /dev/null 2>&1; then
            echo 1>&2 "$SCRIPTNAME: $target_user: User does not exist"
            usage 1
         fi
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Check for further arguments
if [ $# -gt 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Too many arguments"
   usage 1
   exit 1
fi


# Actions --remove-hubs and --kill-machines are incompatible
if [ -n "$remove_hubs" ] && [ -n "$kill_machines" ]; then
   echo 1>&2 "$SCRIPTNAME: Hub removal and machine kill cannot be performed simultaneously"
   exit 1
fi

# Enable default action (remove unused virtual hubs) if none has been requested
[ -z "$kill_machines" ] && [ -z "$remove_tunnels" ] && remove_hubs=1


if [ -z "$target_user" ]; then
   user_str="any user"
else
   user_str=$target_user
fi


# Remove unused hubs (if asked to - is also default)
if [ -n "$remove_hubs" ]; then
   # Just remove unused switches
   echo "Killing unusued virtual hubs owned by $user_str:"

   # Get the process IDs of running UML virtual hubs
   mapfile -t hub_pids < <(pgrep ${target_user:+"--euid=$target_user"} --full "^$NETKIT_HOME/bin/uml_switch")

   # Kill uml_switch processes and clean up unused hub files
   kill_hubs "" "$test_mode" "${hub_pids[@]}"
fi


# Kill running virtual machines and hubs (if asked to)
if [ -n "$kill_machines" ]; then
   # Kill all running virtual machine kernels and all virtual hubs
   echo "Killing virtual machines owned by $user_str:"

   kill_all_vhosts "$test_mode" "$quick_mode" "$target_user"

   echo "Killing virtual hubs owned by $user_str:"

   # Get the process IDs of running UML virtual hubs
   mapfile -t hub_pids < <(pgrep ${target_user:+"--euid=$target_user"} --full "^$NETKIT_HOME/bin/uml_switch")

   # Kill uml_switch processes and clean up all hub files
   kill_hubs "1" "$test_mode" "${hub_pids[@]}"
fi


# Remove tunnel configurations (if asked to)
if [ -n "$remove_tunnels" ]; then
   # Remove any previously configured tunnel
   echo "************* Removing tap configurations *************"
   echo " This will affect tap configurations for $user_str."
   echo "******* This operation requires root privileges *******"

   # TODO: These commands don't run for the specified user (this is a
   # manage_tuntap limitation). 
   manage_tuntap_cmd=( "$NETKIT_HOME/bin/manage_tuntap" "stop" )

   echo "Running ==> ${manage_tuntap_cmd[*]}"

   if ! "${manage_tuntap_cmd[@]}"; then
      echo 1>&2 "Error while removing tap configurations"
      exit 1
   fi

   echo "************** Abandoning root privileges *************"
fi
