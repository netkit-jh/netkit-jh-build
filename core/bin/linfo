#!/usr/bin/env bash

#     Copyright 2002-2009 Stefano Pettini, Fabio Ricci, Massimo Rimondini
#     Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This script displays information about a lab without running it. Optionally,
# it can create a PNG file containing the level 2 topology of the lab.


###############################################################################
# Write linfo's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]..."
}


###############################################################################
# Write linfo's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Display information about a Netkit lab without running it.
Displayed information includes the number of virtual machines that make up the
lab. If asked to, the command can create a PNG file containing a graphical map
of the link-level topology of the lab.
Multiple lab directories can be specified by using the -d option. A -d is
needed per directory. The -a option will auto-detect other labs within the
parent directory.

  -d DIRECTORY        assume the lab is located inside DIRECTORY. By default,
                        the lab is assumed to be located in the current
                        directory
  -m, --map=FILE      Create a graphical link-level topology map of the lab and
                        save it into FILE in PNG format. This requires the
                        Graphviz library to be installed
  -a, --auto          Finds sibling folders which all share the same prefix as
                        the current directory bar the final character. E.g.,
                        running in lab3a will find all directories starting
                        with lab3* (lab3a, lab3b, lab3c, etc) can be paired
                        with multiple -d to specify additional folders

Miscellaneous:
$(help_option)
$(version_option)

END_OF_HELP

   exit "$status"
}


###############################################################################
# From a lab info associative array (key is directory basename, value is the
# relevant attribute's value) construct a formatted list suitable for
# lab_welcome output (i.e. value1 (dir1, dir2, ...), value2 (dir3, dir4, ...),
# ...) and write to standard output.
# Usage:
#   generate_lab_info_str LAB_INFO
# Globals:
#   None
# Arguments:
#   $1 - lab information associative array name reference
# Returns:
#   None
# Example:
#   None
###############################################################################
generate_info_str() {
   local -n lab_info=$1

   local lab value
   local lab_info_str separator

   declare -A collated_lab_info_values

   # For each directory chosen, add its lab information value as a key to an
   # array with a value of directory listings. For example, for a lab_info
   # array of version numbers:
   #
   #     lab_info["lab3a"]="1.0"
   #     lab_info["lab3b"]="1.1"
   #     lab_info["lab3c"]="1.0"
   #     lab_info["lab3d"]="2.0"
   #
   # This would be transformed into collated_lab_info_values:
   #
   #     collated_lab_info_values["1.0"]="lab3a, lab3c"
   #     collated_lab_info_values["1.1"]="lab3b"
   #     collated_lab_info_values["2.0"]="lab3d"
   for lab in "${!lab_info[@]}"; do
      value=${lab_info[$lab]}

      # Append the lab name to its relevant value's list if the value has been
      # seen before (exists as a key in the array). If not, start the list.
      if array_contains "$value" "${!collated_lab_info_values[@]}"; then
         collated_lab_info_values[$value]="${collated_lab_info_values[$value]}, $lab"
      else
         collated_lab_info_values[$value]=$lab
      fi
   done

   # collated_lab_info_values is then flattened into a string to display in the
   # lab_welcome dialog.
   if [ ${#collated_lab_info_values[@]} -gt 1 ]; then
      for value in "${!collated_lab_info_values[@]}"; do
         lab_info_str+="$separator$value (${collated_lab_info_values[$value]})"
         separator=", "
      done
   elif [ ${#collated_lab_info_values[@]} -eq 1 ]; then
      # If all labs share the same value, it is not necessary to display the
      # lab names.
      lab_info_str=${!collated_lab_info_values[*]}
   else
      # If no lab has the parameter defined.
      lab_info_str="<unknown>"
   fi

   echo "$lab_info_str"
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"
# shellcheck source=./lcommon
. "$NETKIT_HOME/bin/lcommon"

# Write to the vcommands log
log_write "$0 $*"


# Get command line options
long_opts="auto,help,version,map:"
short_opts="ad:m:"

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      -a|--auto)
         # TODO: Remove or make better.
         for LAB_DIRECTORY in "${PWD%?}"*/; do
            LAB_DIRECTORIES+=( "$LAB_DIRECTORY" )
         done
         ;;
      -d)
         LAB_DIRECTORY=$(readlink --canonicalize-missing "$2")
         LAB_DIRECTORIES+=( "$LAB_DIRECTORY" )
         shift
         ;;
      --help)
         usage 0
         ;;
      -m|--map)
         MAP_FILE=$2
         shift
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

if [ $# -gt 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Too many arguments"
   exit 1
fi


# If no lab directory has been given, assume current directory
[ "${#LAB_DIRECTORIES[@]}" -eq 0 ] && LAB_DIRECTORIES=( "$PWD" )


declare -A LAB_VERSIONS LAB_AUTHORS LAB_EMAILS LAB_WEBS LAB_DESCRIPTIONS

for LAB_DIRECTORY in "${LAB_DIRECTORIES[@]}"; do
   # Check that the lab directory exists
   if [ ! -d "$LAB_DIRECTORY" ]; then
      echo 1>&2 "$SCRIPTNAME: $LAB_DIRECTORY: No such directory"
      exit 1
   fi

   # TODO: change lab variable assignment to an lcommon function
   # shellcheck source=./lcommon
   . "$NETKIT_HOME/bin/lcommon"

   dir=$(basename "$LAB_DIRECTORY")

   # We use associative arrays for printing the values with their respective
   # directory basename. SC2034 (variable appears unused) must be ignored
   # because the arrays are only referenced by name.
   # shellcheck disable=SC2034
   LAB_VERSIONS[$dir]=${LAB_VERSION:-"<unknown>"}
   # shellcheck disable=SC2034
   LAB_AUTHORS[$dir]=${LAB_AUTHOR:-"<unknown>"}
   # shellcheck disable=SC2034
   LAB_EMAILS[$dir]=${LAB_EMAIL:-"<unknown>"}
   # shellcheck disable=SC2034
   LAB_WEBS[$dir]=${LAB_WEB:-"<unknown>"}
   # shellcheck disable=SC2034
   LAB_DESCRIPTIONS[$dir]=${LAB_DESCRIPTION:-"<unknown>"}

   build_vhostlist
   cum_vhostlist+=( "${VHOSTLIST[@]}" )
done


printf -v LAB_DIRECTORY '%s, ' "${LAB_DIRECTORIES[@]}"
LAB_DIRECTORY=${LAB_DIRECTORY%", "}

# Convert the multi-lab arrays to flat lists for lab_welcome
LAB_VERSION=$(generate_info_str LAB_VERSIONS)
LAB_AUTHOR=$(generate_info_str LAB_AUTHOR)
LAB_EMAIL=$(generate_info_str LAB_EMAIL)
LAB_WEB=$(generate_info_str LAB_WEB)
LAB_DESCRIPTION=$(generate_info_str LAB_DESCRIPTION)

printf -v cum_vhostlist_str '%s, ' "${cum_vhostlist[@]}"
cum_vhostlist_str=${cum_vhostlist_str%", "}


# Print lab information
bold_print "======================== Lab information ========================"
lab_welcome
bold_print "The lab is made up of ${#cum_vhostlist_str[@]} virtual machines ($cum_vhostlist_str)."

for dir in "${LAB_DIRECTORIES[@]}"; do
   [ -f "$dir/lab.dep" ] && bold_print "The lab part $dir supports parallel startup."
done

if [ -n "$MAP_FILE" ]; then
   for dir in "${LAB_DIRECTORIES[@]}"; do
      lab_conf="${dir%/}/lab.conf"
      
      if [ ! -f "$lab_conf" ]; then
         echo 1>&2 "$SCRIPTNAME: Unable to find file $lab_conf: Skipping."
         continue
      fi

      lab_confs+=( "$lab_conf" )
   done

   if [ "${#lab_confs[@]}" -eq 0 ]; then
      echo 1>&2 "$SCRIPTNAME: No valid lab.confs found - cannot create topology map."
      exit 1
   fi

   if lab_map "$MAP_FILE" "${lab_confs[@]}"; then
      bold_print "Link-level topology map saved into $MAP_FILE."
   fi
fi

bold_print "================================================================="
