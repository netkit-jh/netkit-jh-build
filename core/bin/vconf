#!/usr/bin/env bash

#     Copyright 2002-2009 Maurizio Patrignani, Maurizio Pizzonia, Fabio Ricci,
#     Massimo Rimondini - Computer Networks Research Group, Roma Tre University.
#
#     This file is part of Netkit.
# 
#     Netkit is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     Netkit is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     You should have received a copy of the GNU General Public License
#     along with Netkit.  If not, see <http://www.gnu.org/licenses/>.

# This is the Netkit vconfig script, which allows to attach virtual machine
# interfaces on the fly. Interface detaching is not supported, because the
# release function for uml-netdev0 is still under development. This script
# already supports interface removal, which can be achieved by using an empty
# collision domain name for an interface. Yet, this feature is currently hidden
# by a check on the presence of a valid collision domain name.


###############################################################################
# Write vconf's usage line to standard output.
# Usage:
#   usage_line
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   None
# Returns:
#   None
# Example:
#   None
###############################################################################
usage_line() {
   echo "Usage: $SCRIPTNAME [OPTION]... MACHINE"
}


###############################################################################
# Write vconf's usage as a full dialog or a "try --help".
# Usage:
#   usage STATUS
# Globals:
#   r- SCRIPTNAME
# Arguments:
#   $1 - status code to exit with. When zero, usage will write to standard
#        output and describe all options (for --help). Else, it will write to
#        standard error and be a brief usage and try-help message.
# Returns:
#   None - exits with a status code of STATUS
# Example:
#   None
###############################################################################
usage() {
   local status=$1

   if [ "$status" -ne 0 ]; then
      usage_line 1>&2
      try_help
      exit "$status"
   fi

   cat << END_OF_HELP
$(usage_line)
Attach network interfaces to running virtual machines.

      --ethN=[DOMAIN] equip virtual machine with a network interface ethN,
                        where N is a number between 0 and $((MAX_INTERFACES - 1)). DOMAIN is the
                        name of the collision domain the interface should be
                        connected to. Using an empty DOMAIN name (e.g.,
                        'eth0=') results in detaching the interface from a
                        running virtual machine. The special name 'tap' is
                        reserved: when connecting an interface to the 'tap'
                        domain, an external network can be reached through this
                        interface. A 'tap' collision domain must be declared
                        with the following syntax:
                          --ethX=tap,TAP_ADDRESS,GUEST_ADDRESS
                        where TAP_ADDRESS is the IP address of the 'host side'
                        of the interface and GUEST_ADDRESS is the IP address of
                        the interface inside the virtual machine. TAP_ADDRESS
                        and GUEST_ADDRESS must be on the same network.
                        Notices:
                        - Using "tap" domains requires administrative
                          privileges. This script will take care of asking you
                          for the root password when needed.
                        - TAP_ADDRESS is mandatory, but is only taken into
                          account when a "tap" collision domain is first used.
                          The script only uses one "tap" collision domain for
                          each user on the host machine.
                        - Tunnel configurations are not automatically removed
                          when halting machines: you should use the vclean
                          script for this purpose.
  -u, --user=USERNAME  attach interfaces to a virtual machine owned by user
                        USERNAME. Using the special user name '-' results in
                        considering all users. If MACHINE is a virtual machine
                        name, and the option --user=- is being used, then
                        interfaces are attached to the virtual machine reported
                        by 'vlist --user=- MACHINE'. By default, interfaces are
                        attached to virtual machines owned by the current user

Miscellaneous:
$(help_option)
  -p, --print         do not actually start anything. Just show which commands
                        would be executed
  -q, --quiet         quiet mode (suppress any output except errors and
                        warnings)
$(version_option)

Notice: arguments containing spaces are not allowed. Interfaces attached by
using this tool will not be shown by vlist, and the corresponding virtual hubs
will not be automatically stopped. Also, when using 'tap' collision domains,
configuration inside virtual machines must be performed by hand.

END_OF_HELP

   exit "$status"
}


###############################################################################
# Append network interface specifications to the kernel invocation command.
# Usage:
#   setup_interfaces [INTERFACE]...
# Globals:
#   r- BE_QUIET
#   -w HUB_LIST
#   r- HUB_SOCKET_DIR
#   r- HUB_SOCKET_EXTENSION
#   r- HUB_SOCKET_PREFIX
#   r- VCONF_DEVICES
#   r- SCRIPTNAME
#   r- USER_ID
# Arguments:
#  ... - array of interface specifications (ethN=DOMAIN)
# Returns:
#   None. Will exit with usage 1 on invalid specification.
# Example:
#   None
###############################################################################
setup_interfaces() {
   local interface_specifications=( "$@" )

   local interface_specification device hub_specification used_devices
   local hub_name tap_address guest_address hub_socket
   local indent
   
   unset HUB_LIST
   unset VCONF_DEVICES

   for interface_specification in "${interface_specifications[@]}"; do
      device=${interface_specification%%=*}
      hub_specification=${interface_specification#*=}

      # Check if interface has already been configured
      if array_contains "$device" "${used_devices[@]}"; then
         echo 1>&2 "$SCRIPTNAME: $device: Duplicate interface"
         usage 1
      fi

      # Remember that this network interface has been configured
      used_devices+=( "$device" )

      # Check if tap interface (regular hubs cannot be named with commas)
      if [[ "$hub_specification" == tap,* ]]; then
         # Format: tap,tap_address,guest_address
         IFS=, read -r hub_name tap_address guest_address <<< "$hub_specification"

         if ! is_inet_addr "$tap_address"; then
            echo 1>&2 "$SCRIPTNAME: $tap_address: Invalid tap address"
            usage 1
         fi

         if ! is_inet_addr "$guest_address"; then
            echo 1>&2 "$SCRIPTNAME: $guest_address: Invalid guest address"
            usage 1
         fi
      else
         # This is a normal (i.e., not 'tap') collision domain
         unset tap_address guest_address
         hub_name=$hub_specification
      fi

      if [ -n "$hub_name" ]; then
         if [ -n "$tap_address" ]; then
            HUB_LIST+=( "$hub_name,$tap_address" )
         else
            HUB_LIST+=( "$hub_name" )
         fi

         hub_socket="$HUB_SOCKET_DIR/${HUB_SOCKET_PREFIX}_${USER_ID}_$hub_name$HUB_SOCKET_EXTENSION"
         
         VCONF_DEVICES+=( "$device=daemon,,,$hub_socket" )
         [ -z "$BE_QUIET" ] && echo "$indent$device @ $hub_name ($hub_socket)"
      else
         VCONF_DEVICES+=( "$device" )
         [ -z "$BE_QUIET" ] && echo "$indent$device removed"
      fi

      # Indent subsequent lines
      indent="               "
   done
}


###############################################################################
# Attach/remove network interfaces from running machines with mconsole.
# Usage:
#   invoke_mconsole MACHINE [VCONF_DEVICES]...
# Globals:
#   r- JUST_PRINT
#   r- NETKIT_HOME
# Arguments:
#   $1 - machine name
#  ... - list of devices to configure. To remove an interface: 'ethN', to add
#        an interface: 'ethN=daemon,,,path/to/socket'.
# Returns:
#   None
# Example:
#   None
###############################################################################
invoke_mconsole() {
   local vm=$1
   local vconf_devices=( "${@:2}" )

   local device_specification device hub_specification
   local action action_desc
   local uml_mconsole_cmd

   for device_specification in "${vconf_devices[@]}"; do
      # Format is either:
      #   To add an interface:
      #     ethN=daemon,,,path/to/socket
      #   To remove an interface:
      #     ethN
      device=${device_specification%%=*}
      hub_specification=${device_specification#*=}

      if [ -n "$hub_specification" ]; then
         action="config"
         action_desc="add"
      else
         action="remove"
         action_desc="remove"
      fi

      uml_mconsole_cmd=( "$NETKIT_HOME/bin/uml_mconsole" "$vm" "$action" "$device" )

      if ! run_command "$JUST_PRINT" "" "${uml_mconsole_cmd[@]}" 2>&1; then
         echo 2>&1 "Failed to $action_desc interface '$device'"
      fi
   done
}


SCRIPTNAME=$(basename "$0")

if [ -z "$NETKIT_HOME" ]; then
   echo 1>&2 "$SCRIPTNAME: The NETKIT_HOME environment variable is not set"
   exit 1
fi

# shellcheck source=./script_utils
. "$NETKIT_HOME/bin/script_utils"

# Write to the vcommands log
log_write "$0 $*"


target_user=$USER_ID


# Get command line options
long_opts="help,print,quiet,version,user:"
short_opts="pqu:"

# Append a new long option for each network interface that can be configured
for ((i = 0; i < MAX_INTERFACES; ++i)); do
   long_opts+=",eth$i:"
done

if ! getopt_opts=$(getopt --name "$SCRIPTNAME" --options "$short_opts" --longoptions "$long_opts" -- "$@"); then
   # getopt will output the errorneous command-line argument
   usage 1
fi

# (Safely) set positional parameters to those reordered by getopt
eval set -- "$getopt_opts"

while true; do
   case $1 in
      --eth*)
         device=${1#--}
         hub_name=$2
         shift

         # Check if tap interface (regular hubs cannot be named with commas)
         if [[ "$hub_name" == tap,* ]]; then
            # Format: tap,tap_address,guest_address
            IFS=, read -r _ tap_address guest_address <<< "$hub_name"

            if ! is_inet_addr "$tap_address"; then
               echo 1>&2 "$SCRIPTNAME: $tap_address: Invalid tap address"
               usage 1
            fi

            if ! is_inet_addr "$guest_address"; then
               echo 1>&2 "$SCRIPTNAME: $guest_address: Invalid guest address"
               usage 1
            fi
         fi

         # Construct array of ethN=hub_name
         network_interfaces+=( "$device=$hub_name" )
         ;;
      --help)
         usage 0
         ;;
      -p|--print)
         JUST_PRINT=1
         ;;
      -q|--quiet)
         BE_QUIET=1
         ;;
      -u|--user)
         target_user=$2
         [ "$target_user" = "-" ] && unset target_user
         shift
         ;;
      --version)
         show_version
         exit 0
         ;;
      --)
         shift
         break
         ;;
      *)
         echo 1>&2 "$SCRIPTNAME: Unknown error parsing command line arguments"
         usage 1
         ;;
   esac

   shift
done

# Parse virtual machine name
if [ $# -eq 0 ]; then
   echo 1>&2 "$SCRIPTNAME: Missing machine name"
   usage 1
elif [ $# -gt 1 ]; then
   echo 1>&2 "$SCRIPTNAME: Can only specify one machine"
   usage 1
fi

vm=$1
validate_hostnames "$vm"


if ! get_machine_state "$target_user" "$vm"; then
   echo -n 1>&2 "$SCRIPTNAME: no virtual machine named '$vm' exists"
   [ -n "$target_user" ] && echo " for user $target_user." || echo "."
   exit 1
fi


# Setup network interfaces
if [ -z "$BE_QUIET" ]; then
   echo "============= Configuring virtual machine '$vm' (PID $(get_vm_pid_by_name "$target_user" "$vm")) ============="
   echo "   Virtual machine owner: $target_user"
fi

if [ ${#network_interfaces[@]} -gt 0 ]; then
   [ -z "$BE_QUIET" ] && echo -n "   Interfaces: "
   setup_interfaces "${network_interfaces[@]}"
fi

# Start network hubs
run_hubs "${HUB_LIST[@]}"

# Attach/remove network interfaces
invoke_mconsole "$vm" "${VCONF_DEVICES[@]}"
